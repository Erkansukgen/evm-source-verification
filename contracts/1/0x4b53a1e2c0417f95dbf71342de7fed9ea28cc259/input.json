{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/rebalancer.sol": {
      "content": "pragma solidity 0.8.0;\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n\ninterface IMassetV2 {\n\n    /** @dev Calc interest */\n    function collectInterest() external returns (uint256 swapFeesGained, uint256 newTotalSupply);\n    function collectPlatformInterest() external returns (uint256 interestGained, uint256 newTotalSupply);\n\n    /** @dev Minting */\n    function mint(address _basset, uint256 _bassetQuantity)\n        external returns (uint256 massetMinted);\n    function mintTo(address _basset, uint256 _bassetQuantity, address _recipient)\n        external returns (uint256 massetMinted);\n    function mintMulti(address[] calldata _bAssets, uint256[] calldata _bassetQuantity, address _recipient)\n        external returns (uint256 massetMinted);\n\n    /** @dev Swapping */\n    function swap( address _input, address _output, uint256 _quantity, address _recipient)\n        external returns (uint256 output);\n    function getSwapOutput( address _input, address _output, uint256 _quantity)\n        external view returns (bool, string memory, uint256 output);\n\n    /** @dev Redeeming */\n    function redeem(address _basset, uint256 _bassetQuantity)\n        external returns (uint256 massetRedeemed);\n    function redeemTo(address _basset, uint256 _bassetQuantity, address _recipient)\n        external returns (uint256 massetRedeemed);\n    function redeemMulti(address[] calldata _bAssets, uint256[] calldata _bassetQuantities, address _recipient)\n        external returns (uint256 massetRedeemed);\n    function redeemMasset(uint256 _mAssetQuantity, address _recipient) external;\n\n    /** @dev Setters for the Manager or Gov to update module info */\n    function upgradeForgeValidator(address _newForgeValidator) external;\n\n    /** @dev Setters for Gov to set system params */\n    function setSwapFee(uint256 _swapFee) external;\n\n    /** @dev Getters */\n    function getBasketManager() external view returns(address);\n    function forgeValidator() external view returns (address);\n    function totalSupply() external view returns (uint256);\n    function swapFee() external view returns (uint256);\n}\n\ninterface Structs {\n    struct Val {\n        uint256 value;\n    }\n\n    enum ActionType {\n      Deposit,   // supply tokens\n      Withdraw,  // borrow tokens\n      Transfer,  // transfer balance between accounts\n      Buy,       // buy an amount of some token (externally)\n      Sell,      // sell an amount of some token (externally)\n      Trade,     // trade tokens against another account\n      Liquidate, // liquidate an undercollateralized or expiring account\n      Vaporize,  // use excess tokens to zero-out a completely negative account\n      Call       // send arbitrary data to an address\n    }\n\n    enum AssetDenomination {\n        Wei // the amount is denominated in wei\n    }\n\n    enum AssetReference {\n        Delta // the amount is given as a delta from the current value\n    }\n\n    struct AssetAmount {\n        bool sign; // true if positive\n        AssetDenomination denomination;\n        AssetReference ref;\n        uint256 value;\n    }\n\n    struct ActionArgs {\n        ActionType actionType;\n        uint256 accountId;\n        AssetAmount amount;\n        uint256 primaryMarketId;\n        uint256 secondaryMarketId;\n        address otherAddress;\n        uint256 otherAccountId;\n        bytes data;\n    }\n\n    struct Info {\n        address owner;  // The address that owns the account\n        uint256 number; // A nonce that allows a single address to control many accounts\n    }\n\n    struct Wei {\n        bool sign; // true if positive\n        uint256 value;\n    }\n}\n\ninterface DyDxPool is Structs {\n    function getAccountWei(Info memory account, uint256 marketId) external view returns (Wei memory);\n    function operate(Info[] memory, ActionArgs[] memory) external;\n}\n\ncontract DyDxFlashLoan is Structs {\n\n    using SafeERC20 for IERC20;\n\n    DyDxPool constant pool = DyDxPool(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);\n\n    // DyDx tokens\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address constant SAI = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\n\n    // Both DyDx and mUSD tokens\n    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    // mUSD tokens\n    address constant sUSD = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\n    address constant TUSD = 0x0000000000085d4780B73119b644AE5ecd22b376;\n    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    \n    mapping(address => uint256) public currencies;\n\n    constructor() public {\n        currencies[WETH] = 1;\n        currencies[SAI] = 2;\n        currencies[USDC] = 3;\n        currencies[DAI] = 4;\n    }\n\n    modifier onlyPool() {\n        require(\n            msg.sender == address(pool),\n            \"FlashLoan: only called by DyDx pool\"\n        );\n        _;\n    }\n\n    function tokenToMarketId(address token) public view returns (uint256) {\n        uint256 marketId = currencies[token];\n        require(marketId != 0, \"FlashLoan: Unsupported token\");\n        return marketId - 1;\n    }\n\n    // the DyDx will call `callFunction(address sender, Info memory accountInfo, bytes memory data) public` after during `operate` call\n    function flashloan(address token, uint256 amount, bytes memory data)\n        internal virtual\n    {\n        IERC20(token).approve(address(pool), amount + 1);\n        Info[] memory infos = new Info[](1);\n        ActionArgs[] memory args = new ActionArgs[](3);\n\n        infos[0] = Info(address(this), 0);\n\n        AssetAmount memory wamt = AssetAmount(\n            false,\n            AssetDenomination.Wei,\n            AssetReference.Delta,\n            amount\n        );\n        ActionArgs memory withdraw;\n        withdraw.actionType = ActionType.Withdraw;\n        withdraw.accountId = 0;\n        withdraw.amount = wamt;\n        withdraw.primaryMarketId = tokenToMarketId(token);\n        withdraw.otherAddress = address(this);\n\n        args[0] = withdraw;\n\n        ActionArgs memory call;\n        call.actionType = ActionType.Call;\n        call.accountId = 0;\n        call.otherAddress = address(this);\n        call.data = data;\n\n        args[1] = call;\n\n        ActionArgs memory deposit;\n        AssetAmount memory damt = AssetAmount(\n            true,\n            AssetDenomination.Wei,\n            AssetReference.Delta,\n            amount + 1\n        );\n        deposit.actionType = ActionType.Deposit;\n        deposit.accountId = 0;\n        deposit.amount = damt;\n        deposit.primaryMarketId = tokenToMarketId(token);\n        deposit.otherAddress = address(this);\n\n        args[2] = deposit;\n\n        pool.operate(infos, args);\n    }\n}\n\ninterface ICurve {\n    function get_virtual_price() external returns (uint256 out);\n\n    function add_liquidity(uint256[2] calldata amounts, uint256 deadline) external;\n\n    function get_dy(int128 i, int128 j, uint256 dx)\n        external\n        returns (uint256 out);\n\n    function get_dy_underlying(int128 i, int128 j, uint256 dx)\n        external\n        returns (uint256 out);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy,\n        uint256 deadline\n    ) external;\n\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy,\n        uint256 deadline\n    ) external;\n\n    function remove_liquidity(\n        uint256 _amount,\n        uint256 deadline,\n        uint256[2] calldata min_amounts\n    ) external;\n\n    function remove_liquidity_imbalance(uint256[2] calldata amounts, uint256 deadline)\n        external;\n\n    function commit_new_parameters(\n        int128 amplification,\n        int128 new_fee,\n        int128 new_admin_fee\n    ) external;\n\n    function apply_new_parameters() external;\n\n    function revert_new_parameters() external;\n\n    function commit_transfer_ownership(address _owner) external;\n\n    function apply_transfer_ownership() external;\n\n    function revert_transfer_ownership() external;\n\n    function withdraw_admin_fees() external;\n\n    function coins(int128 arg0) external returns (address out);\n\n    function underlying_coins(int128 arg0) external returns (address out);\n\n    function balances(int128 arg0) external returns (uint256 out);\n\n    function A() external returns (int128 out);\n\n    function fee() external returns (int128 out);\n\n    function admin_fee() external returns (int128 out);\n\n    function owner() external returns (address out);\n\n    function admin_actions_deadline() external returns (uint256 out);\n\n    function transfer_ownership_deadline() external returns (uint256 out);\n\n    function future_A() external returns (int128 out);\n\n    function future_fee() external returns (int128 out);\n\n    function future_admin_fee() external returns (int128 out);\n\n    function future_owner() external returns (address out);\n}\n\n// SPDX-License-Identifier: AGPL-3.0-or-later\n// import \"hardhat/console.sol\";\n/**\n * @title   Contract to rebalance mUSD bAssets to new weights for the mUSD V3 upgrade.\n * @author  mStable\n * @notice  Either DAI or USDC is flash loaned from DyDx to swap for TUSD or USDT in mUSD.\n *          Curve's TUSD pool (DAI, USDC, USDT and TUSD) or 3pool (DAI, USDC, USDT) is used to\n *          convert TUSD and USDT back to the flash loan currency.\n * @dev     VERSION: 1.0\n *          DATE:    2021-03-22\n */\ncontract MusdV3Rebalance4Pool is DyDxFlashLoan, Ownable {\n\n    using SafeERC20 for IERC20;\n\n    // Contracts that are called to execute swaps\n    IMassetV2 constant mUsdV2 = IMassetV2(0xe2f2a5C287993345a840Db3B0845fbC70f5935a5);\n    ICurve constant curve3pool = ICurve(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);\n    ICurve constant curveYpool = ICurve(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51);\n    ICurve constant curveTUSDpool = ICurve(0xEcd5e75AFb02eFa118AF914515D6521aaBd189F1);\n\n    event FlashLoan(\n        address flashToken,\n        uint256 flashLoanAmount,\n        address funderAccount,\n        uint256 flashLoanShortfall);\n\n    // Events from dependant contracts so Ethers can parse the topics\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    // mUSD\n    event Swapped(address indexed swapper, address input, address output, uint256 outputAmount, address recipient);\n    // Curve\n    event TokenExchange(address indexed buyer, int128 sold_id, uint256 tokens_sold, int128 bought_id, uint256 tokens_bought);\n    event TokenExchangeUnderlying(address indexed buyer, int128 sold_id, uint256 tokens_sold, int128 bought_id, uint256 tokens_bought);\n\n    /***************************************\n                Swap (PUBLIC)\n    ****************************************/\n\n    /**\n     * @notice Convert TUSD in the mUSD basket to USDC or DAI using a DyDx flash loan.\n     * @param flashToken DAI or USDC token address.\n     * @param flashAmount Amount to flash loan. For USDC is 6 decimal places. DAI is 18 decimals places.\n     * @param funderAccount Account that will fund the shortfall of the DyDx USDC flash loan.\n     * @dev Assumes the funder has already approved this contract to transferFrom the shortfall from their account.\n     */\n    function swapOutTusd(\n        address flashToken,\n        uint256 flashAmount,\n        address funderAccount\n    ) external onlyOwner {\n        uint256[] memory swapInputs = new uint256[](2);\n        swapInputs[0] = flashAmount;\n        _getFlashloan(flashToken, funderAccount, swapInputs);\n    }\n\n    /**\n     * @notice Convert TUSD and USDT in the mUSD basket to USDC or DAI using a DyDx flash loan.\n     * @param flashToken DAI or USDC token address.\n     * @param flashAmount Amount to flash loan. For USDC is 6 decimal places. DAI is 18 decimals places.\n     * @param funderAccount Account that will fund the shortfall of the DyDx USDC flash loan.\n     * @param swapInputs This mUSD swap inputs from the flash token to TUSD (at index 0) and USDT (at index 1).\n     * @dev Assumes the funder has already approved this contract to transferFrom the shortfall from their account.\n     */\n    function swapOutTusdAndUsdt(\n        address flashToken,\n        uint256 flashAmount,\n        address funderAccount,\n        uint256[] memory swapInputs\n    ) external onlyOwner {\n        _getFlashloan(flashToken, funderAccount, swapInputs);\n    }\n\n    /***************************************\n                DyDx Flash Loan (Internal)\n    ****************************************/\n\n    /**\n     * @notice Requests a flash loan from DyDx.\n     * @param flashToken DAI or USDC token address.\n     * @param funderAccount Account that will fund the shortfall of the DyDx USDC flash loan.\n     * @param swapInputs This mUSD swap inputs from the flash token to TUSD (at index 0) and USDT (at index 1).\n     */\n    function _getFlashloan(\n        address flashToken,\n        address funderAccount,\n        uint256[] memory swapInputs\n    ) internal {\n        uint256 balanceBefore = IERC20(flashToken).balanceOf(address(this));\n        bytes memory data = abi.encode(flashToken, balanceBefore, funderAccount, swapInputs);\n        uint256 flashAmount = swapInputs[0] + swapInputs[1];\n        // console.log(\"About to flash loan %s %s from DyDx\", flashAmount, flashToken);\n        flashloan(flashToken, flashAmount, data); // execution goes to `callFunction`\n        // and this point we have succefully repaid the flash loan\n    }\n\n    /***************************************\n                DyDx Flash Loan (Public)\n    ****************************************/\n\n    /**\n     * Is called by DyDx after the flash loan has been transferred to this contract.\n     */\n    function callFunction(\n        address, /* sender */\n        Info calldata, /* accountInfo */\n        bytes calldata data\n    ) external onlyPool {\n        (address flashToken, uint256 balanceBefore, address funderAccount, uint256[] memory swapInputs) = abi\n            .decode(data, (address, uint256, address, uint256[]));\n        uint256 balanceAfter = IERC20(flashToken).balanceOf(address(this));\n        require(\n            balanceAfter - balanceBefore == swapInputs[0] + swapInputs[1],\n            \"did not get flash loan\"\n        );\n\n        _balanceTusdAndUsdt(flashToken, funderAccount, swapInputs);\n\n        // the calling DyDx flash loan contract with now repay the flash loan with a transfer from this contract\n    }\n\n    /***************************************\n                Swap (Internal)\n    ****************************************/\n\n    /**\n     * @notice Executes the following swaps to rebalance the mUSD bAssets:\n        Swap flash token for TUSD using mUSD\n        Swap flash token for USDT using mUSD\n        Swap TUSD for flash token using Curve TUSD pool (can be further split across Curve 3pool)\n        Swap USDT for flash token using Curve 3pool\n        Fund the DyDx flash loan shortfall\n     * @param flashToken DAI or USDC token address.\n     * @param funderAccount Account that will fund the shortfall of the DyDx USDC flash loan.\n     * @param swapInputs This mUSD swap inputs from the flash token to TUSD (at index 0) and USDT (at index 1).\n     */\n    function _balanceTusdAndUsdt(\n        address flashToken,\n        address funderAccount,\n        uint256[] memory swapInputs\n    ) internal {\n        uint256 flashAmount = swapInputs[0] + swapInputs[1];\n        // Approve mUSD contract to transfer flash token from this contract\n        // console.log(\"About to approve mUSD contract to transfer %s flash tokens >= %s %s\", flashAmount, swapInputs[0], swapInputs[1]);\n        require(flashAmount >= swapInputs[0] + swapInputs[1], \"flash loan not >= swap inputs\");\n        IERC20(flashToken).safeApprove(address(mUsdV2), flashAmount);\n\n        // If swapping flash token into mUSD for TUSD\n        if (swapInputs[0] > 0) {\n            // Swap flash token for TUSD using mUSD\n            // console.log(\"About to mUSD swap %s flash tokens for TUSD\", swapInputs[0]);\n            uint256 tusdOutput = mUsdV2.swap(flashToken, TUSD, swapInputs[0], address(this));\n            // console.log(\"tusdOutput %s\", tusdOutput);\n\n            uint256 halfTusdOutput = tusdOutput / 2;\n\n            // Convert TUSD back to flash token to repay DyDx flash loan\n\n            // Curve Y pool \n            // Approve Curve Y pool to transfer all TUSD from this contract\n            IERC20(TUSD).safeApprove(address(curveYpool), halfTusdOutput);\n\n            // Swap TUSD for flash token using Curve TUSD pool\n            uint256 minOutput = halfTusdOutput * 99 / 100;\n            uint8 outputIndex = 0;  // DAI\n            if (flashToken == USDC) {\n                outputIndex = 1;\n                // Converting from TUSD with 18 decimals to USDC with 6 decimals\n                minOutput = minOutput / 1e12;\n            }\n            // console.log(\"About to swap on Curve Y pool %s TUSD (3) for flash loan (%s)\", halfTusdOutput, outputIndex);\n            curveYpool.exchange_underlying(3, outputIndex, halfTusdOutput, minOutput);\n            // console.log(\"Curve TUSD pool swap\");\n\n            // Curve TUSD pool \n            // Approve Curve TUSD pool to transfer all TUSD from this contract\n            IERC20(TUSD).safeApprove(address(curveTUSDpool), halfTusdOutput);\n\n            // Swap TUSD for flash token using Curve TUSD pool\n            minOutput = halfTusdOutput * 99 / 100;\n            outputIndex = 1;  // DAI\n            if (flashToken == USDC) {\n                outputIndex = 2;\n                // Converting from TUSD with 18 decimals to USDC with 6 decimals\n                minOutput = minOutput / 1e12;\n            }\n            // console.log(\"About to swap on Curve TUSD pool %s TUSD (0) for flash loan (%s)\", halfTusdOutput, outputIndex);\n            curveTUSDpool.exchange_underlying(0, outputIndex, halfTusdOutput, minOutput);\n            // console.log(\"Curve TUSD pool swap\");\n        }\n\n        // If swapping flash token into mUSD for USDT\n        if (swapInputs[1] > 0) {\n            // Swap flash token for USDT using mUSD\n            // console.log(\"About to mUSD swap %s flash tokens for USDT\", swapInputs[1]);\n            uint256 usdtOutput = mUsdV2.swap(flashToken, USDT, swapInputs[1], address(this));\n            // console.log(\"usdtOutput %s\", usdtOutput);\n\n            // Convert USDT for flash token using Curve 3pool\n            // Approve Curve 3pool to transfer all USDT from this contract\n            IERC20(USDT).safeApprove(address(curve3pool), usdtOutput);\n\n            // Swap USDT for flash token using Curve 3pool\n            uint256 minOutput = usdtOutput * 99 / 100;\n            uint8 outputIndex = 1;  // USDC\n            if (flashToken == DAI) {\n                outputIndex = 0;\n                // Converting from USDT with 6 decimals to DAI with 18 decimals\n                uint256 minOutput = minOutput * 99 / 100 * 1e12;\n            }\n            curve3pool.exchange(2, outputIndex, usdtOutput, minOutput);\n            // console.log(\"Curve 3pool swap\");\n        }\n\n        _fundLoanShortfall(flashToken, flashAmount, funderAccount);\n    }\n\n    /**\n     * @notice Calculates how much the flash loan is short before repayment.\n               Funds the loan shortfall from a nominated funder account.\n     * @param flashToken DAI or USDC token address.\n     * @param flashAmount Amount to flash loan. For USDC is 6 decimal places. DAI is 18 decimals places.\n     * @param funderAccount Account that will fund the shortfall of the DyDx USDC flash loan.\n     */\n    function _fundLoanShortfall(\n        address flashToken,\n        uint256 flashAmount,\n        address funderAccount\n    ) internal {\n        // Caculate flash loan shortfall\n        uint256 flashTokenBalance = IERC20(flashToken).balanceOf(address(this));\n        uint256 flashLoanShortfall;\n        if (flashAmount + 10 > flashTokenBalance) {\n            // Need to add 2 wei to cover the cost of the DyDx flash loan.\n            // using 1000000 wei just to be safe.\n            flashLoanShortfall = flashAmount + 1000000 - flashTokenBalance;\n\n            // Transfer flash loan shortfall to this contract from funded account\n            uint256 funderAllowance = IERC20(flashToken).allowance(funderAccount, address(this));\n            // console.log(\"funderAllowance %s > flashLoanShortfall %s\", funderAllowance, flashLoanShortfall);\n            require(funderAllowance > flashLoanShortfall, \"funder allowance < shortfall\");\n            uint256 funderBalance = IERC20(flashToken).balanceOf(funderAccount);\n            // console.log(\"funderBalance %s > flashLoanShortfall %s\", funderBalance, flashLoanShortfall);\n            require(funderBalance > flashLoanShortfall, \"funder balance < shortfall\");\n            // console.log(\"flashLoanShortfall %s\", flashLoanShortfall);\n\n            // Loan shortfall can not be more than 30k\n            uint256 maxShortfall;\n            if (flashToken == DAI) maxShortfall = 30000e18; // 18 decimal places\n            if (flashToken == USDC) maxShortfall = 30000e6; // 6 decimal places\n            require(flashLoanShortfall <= maxShortfall, \"flashLoanShortfall too big\");\n\n            // console.log(\"About to fund flash loan shortfall from funder\");\n            IERC20(flashToken).safeTransferFrom(funderAccount, address(this), flashLoanShortfall);\n            // console.log(\"shortfall has been repaid\");\n        }\n        \n        emit FlashLoan(flashToken, flashAmount, funderAccount, flashLoanShortfall);\n    }\n}"
    }
  }
}