{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "BribeView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nlibrary Math {\n    function max(uint a, uint b) internal pure returns (uint) {\n        return a >= b ? a : b;\n    }\n    function min(uint a, uint b) internal pure returns (uint) {\n        return a < b ? a : b;\n    }\n}\n\ninterface erc20 {\n    function totalSupply() external view returns (uint256);\n    function transfer(address recipient, uint amount) external returns (bool);\n    function decimals() external view returns (uint8);\n    function balanceOf(address) external view returns (uint);\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n    function approve(address spender, uint value) external returns (bool);\n}\n\ninterface GaugeController {\n    struct VotedSlope {\n        uint slope;\n        uint power;\n        uint end;\n    }\n    \n    struct Point {\n        uint bias;\n        uint slope;\n    }\n    \n    function vote_user_slopes(address, address) external view returns (VotedSlope memory);\n    function last_user_vote(address, address) external view returns (uint);\n    function points_weight(address, uint256) external view returns (Point memory);\n    function checkpoint_gauge(address) external;\n}\n\ninterface ve {\n    function get_last_user_slope(address) external view returns (int128);\n}\n\ninterface bribe {\n    function active_period(address, address) external view returns (uint);\n    function reward_per_token(address, address) external view returns (uint);\n}\n\ncontract BribeV2 {\n    uint constant WEEK = 86400 * 7;\n    uint constant PRECISION = 10**18;\n    GaugeController constant GAUGE = GaugeController(0x2F50D538606Fa9EDD2B11E2446BEb18C9D5846bB);\n    ve constant VE = ve(0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2);\n    bribe constant BRIBE = bribe(0x7893bbb46613d7a4FbcC31Dab4C9b823FfeE1026);\n    \n    function tokens_for_bribe(address user, address gauge, address reward_token) external view returns (uint) {\n        uint _reward_per_token = BRIBE.reward_per_token(gauge, reward_token);\n        uint _active_period = BRIBE.active_period(gauge, reward_token);\n        uint _previous_slope = GAUGE.points_weight(gauge, _active_period).slope;\n        uint _amount = Math.min(_reward_per_token * _previous_slope / PRECISION, erc20(reward_token).balanceOf(address(BRIBE)));\n        uint _slope = GAUGE.points_weight(gauge, _active_period+WEEK).slope;\n        return uint(int(VE.get_last_user_slope(user))) * _amount / _slope;\n    }\n}"
    }
  }
}