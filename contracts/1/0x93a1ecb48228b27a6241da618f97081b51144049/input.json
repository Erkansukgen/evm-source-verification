{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/coinbase.sol": {
      "content": "pragma solidity >=0.8.0;\n// SPDX-License-Identifier: UNLICENSED\n\n// ** 不存资产**\n\ninterface IWETH {\n    /*\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    */\n    function withdraw(uint) external;\n}\n\ninterface IERC20 {\n    /*\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    */\n    function balanceOf(address owner) external view returns (uint);\n    /*\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    */\n}\n\ninterface IUniswapV2Pair {\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\n\ncontract CaV1 {\n    address public owner;\n\n    string public name = \"CaV1\";\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n    //构造函数\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // receive ETH\n    receive() external payable {}\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"CaV1: sender not owner\");\n        _;\n    }\n\n    function changeOwner(address _owner) public onlyOwner {\n        owner = _owner;\n    }\n\n    struct exchangeLocalVars {\n        address token;\n        uint amountBorrow;\n        uint amountRepay;\n        address[] pairs;\n        uint[] amount0Outs;\n        uint[] amount1Outs;\n    }\n    \n    function exchange(\n        address _token, \n        uint _amountBorrow,\n        uint _amountRepay,\n        address[] memory _pairs,\n        uint[] memory _amount0Outs,\n        uint[] memory _amount1Outs\n    ) public onlyOwner returns (uint _profit){\n\n        exchangeLocalVars memory vars;\n        vars.token = _token;\n        vars.amountBorrow = _amountBorrow;\n        vars.amountRepay = _amountRepay;\n        vars.pairs = _pairs;\n        vars.amount0Outs = _amount0Outs;\n        vars.amount1Outs = _amount1Outs;\n\n        uint balanceBefor = IERC20(_token).balanceOf(address(this));\n\n        bytes memory data = abi.encode(vars);\n        // 借款\n\t    IUniswapV2Pair(_pairs[0]).swap(_amount0Outs[0], _amount1Outs[0], address(this), data);\n        // 回调执行了 uniswapV2Call()\n\n        uint balanceAfter = IERC20(_token).balanceOf(address(this));\n\n        require(balanceAfter > balanceBefor, \"CaV1: no profit\");\n\n        _profit = balanceAfter - balanceBefor;\n\n        if(_token == WETH){\n            // 全部提现\n            IWETH(WETH).withdraw(balanceAfter);\n            uint toCoinbase = _profit/2;\n            _safeTransferETH(msg.sender, balanceAfter-toCoinbase);\n            block.coinbase.transfer(toCoinbase);\n        }else{\n            _safeTransfer(_token, msg.sender, balanceAfter);\n        }        \n    }\n\n    //function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {\n    function uniswapV2Call(address, uint, uint, bytes calldata data) external {\n        require(tx.origin == owner, \"CaV1: origin not owner\");\n\n        exchangeLocalVars memory vars = abi.decode(data, (exchangeLocalVars));\n\n        _safeTransfer(vars.token, vars.pairs[1], vars.amountBorrow);\n\n        // amountRepay 为 0，直接在loop里面还了\n        address lastAddress = vars.amountRepay > 0 ? address(this) : vars.pairs[0];\n\n        // 交易\n        uint length = vars.pairs.length;\n        for (uint i=1; i < length; i++) {\n            address to = i < length - 1 ? vars.pairs[i+1] : lastAddress;\n            IUniswapV2Pair(vars.pairs[i]).swap(vars.amount0Outs[i], vars.amount1Outs[i], to, new bytes(0));\n        }\n\n        // 还款\n        if(vars.amountRepay > 0) {\n            _safeTransfer(vars.token, vars.pairs[0], vars.amountRepay);\n        }\n    }\n\n    //万一有token，提现\n    function withdrawToken(address token) public onlyOwner returns (uint balance) {\n        balance = IERC20(token).balanceOf(address(this));\n        if(balance > 0) {\n            _safeTransfer(token, msg.sender, balance);\n        }\n    }\n\n    function withdrawETH() public onlyOwner returns (uint balance) {\n        balance = address(this).balance;\n        if(balance > 0) {\n            _safeTransferETH(msg.sender, balance);\n        }\n    }\n\n    function _safeTransferETH(address to, uint256 value) private {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'CaV1: ETH transfer failed');\n    }\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'CaV1: TRANSFER_FAILED');\n    }\n}"
    }
  }
}