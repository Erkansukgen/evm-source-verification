{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"k.sol":{"content":"/*\nSPDX-License-Identifier: Mines™®©\n*/\n\n\n\npragma solidity ^0.8.4;\n\nabstract contract Context {\nfunction _msgSender() internal view virtual returns (address) {\nreturn msg.sender;\n}\n}\n\ninterface IERC20 {\nfunction totalSupply() external view returns (uint256);\nfunction balanceOf(address account) external view returns (uint256);\nfunction transfer(address recipient, uint256 amount) external returns (bool);\nfunction allowance(address owner, address spender) external view returns (uint256);\nfunction approve(address spender, uint256 amount) external returns (bool);\nfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\nevent Transfer(address indexed from, address indexed to, uint256 value);\nevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\nuint256 c = a + b;\nrequire(c >= a, \"SafeMath: addition overflow\");\nreturn c;\n}\n\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\nreturn sub(a, b, \"SafeMath: subtraction overflow\");\n}\n\nfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\nrequire(b <= a, errorMessage);\nuint256 c = a - b;\nreturn c;\n}\n\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\nif (a == 0) {\nreturn 0;\n}\nuint256 c = a * b;\nrequire(c / a == b, \"SafeMath: multiplication overflow\");\nreturn c;\n}\n\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\nreturn div(a, b, \"SafeMath: division by zero\");\n}\n\nfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\nrequire(b > 0, errorMessage);\nuint256 c = a / b;\nreturn c;\n}\n}\n\ncontract Ownable is Context {\naddress private _owner;\naddress private _previousOwner;\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\nconstructor() {\naddress msgSender = _msgSender();\n_owner = msgSender;\nemit OwnershipTransferred(address(0), msgSender);\n}\n\nfunction owner() public view returns (address) {\nreturn _owner;\n}\n\nmodifier onlyOwner() {\nrequire(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n_;\n}\n\nfunction renounceOwnership() public virtual onlyOwner {\nemit OwnershipTransferred(_owner, address(0));\n_owner = address(0);\n}\n}\n\ninterface IUniswapV2Factory {\nfunction createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ninterface IUniswapV2Router02 {\nfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\nuint256 amountIn,\nuint256 amountOutMin,\naddress[] calldata path,\naddress to,\nuint256 deadline\n) external;\nfunction factory() external pure returns (address);\nfunction WETH() external pure returns (address);\nfunction addLiquidityETH(\naddress token,\nuint256 amountTokenDesired,\nuint256 amountTokenMin,\nuint256 amountETHMin,\naddress to,\nuint256 deadline\n) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\n}\n\ncontract KARMA is Context, IERC20, Ownable {\nusing SafeMath for uint256;\nstring private constant _name = unicode\"KARMA\";\nstring private constant _symbol = \"KARMA\";\nuint8 private constant _decimals = 9;\nmapping(address => uint256) private _rOwned;\nmapping(address => uint256) private _tOwned;\nmapping(address => mapping(address => uint256)) private _allowances;\nmapping(address => bool) private _isExcludedFromFee;\nuint256 private constant MAX = ~uint256(0);\nuint256 private constant _tTotal = 1000000000000 * 10**9;\nuint256 private _rTotal = (MAX - (MAX % _tTotal));\nuint256 private _tFeeTotal;\nuint256 private _taxFee = 7;\nuint256 private _teamFee = 5;\nmapping(address => bool) private bots;\nmapping(address => uint256) private buycooldown;\nmapping(address => uint256) private sellcooldown;\nmapping(address => uint256) private firstsell;\nmapping(address => uint256) private sellnumber;\naddress payable private _teamAddress;\naddress payable private _marketingFunds;\nIUniswapV2Router02 private uniswapV2Router;\naddress private uniswapV2Pair;\nbool private tradingOpen = false;\nbool private liquidityAdded = false;\nbool private inSwap = false;\nbool private swapEnabled = false;\nbool private cooldownEnabled = false;\nuint256 private _maxTxAmount = _tTotal;\nevent MaxTxAmountUpdated(uint256 _maxTxAmount);\nmodifier lockTheSwap {\ninSwap = true;\n_;\ninSwap = false;\n}\nconstructor(address payable addr1, address payable addr2) {\n_teamAddress = addr1;\n_marketingFunds = addr2;\n_rOwned[_msgSender()] = _rTotal;\n_isExcludedFromFee[owner()] = true;\n_isExcludedFromFee[address(this)] = true;\n_isExcludedFromFee[_teamAddress] = true;\n_isExcludedFromFee[_marketingFunds] = true;\nemit Transfer(address(0), _msgSender(), _tTotal);\n}\n\nfunction name() public pure returns (string memory) {\nreturn _name;\n}\n\nfunction symbol() public pure returns (string memory) {\nreturn _symbol;\n}\n\nfunction decimals() public pure returns (uint8) {\nreturn _decimals;\n}\n\nfunction totalSupply() public pure override returns (uint256) {\nreturn _tTotal;\n}\n\nfunction balanceOf(address account) public view override returns (uint256) {\nreturn tokenFromReflection(_rOwned[account]);\n}\n\nfunction transfer(address recipient, uint256 amount) public override returns (bool) {\n_transfer(_msgSender(), recipient, amount);\nreturn true;\n}\n\nfunction allowance(address owner, address spender) public view override returns (uint256) {\nreturn _allowances[owner][spender];\n}\n\nfunction approve(address spender, uint256 amount) public override returns (bool) {\n_approve(_msgSender(), spender, amount);\nreturn true;\n}\n\nfunction transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n_transfer(sender, recipient, amount);\n_approve(sender,_msgSender(),_allowances[sender][_msgSender()].sub(amount,\"ERC20: transfer amount exceeds allowance\"));\nreturn true;\n}\n\nfunction setCooldownEnabled(bool onoff) external onlyOwner() {\ncooldownEnabled = onoff;\n}\n\nfunction tokenFromReflection(uint256 rAmount) private view returns (uint256) {\nrequire(rAmount <= _rTotal,\"Amount must be less than total reflections\");\nuint256 currentRate = _getRate();\nreturn rAmount.div(currentRate);\n}\n\nfunction removeAllFee() private {\nif (_taxFee == 0 && _teamFee == 0) return;\n_taxFee = 0;\n_teamFee = 0;\n}\n\nfunction restoreAllFee() private {\n_taxFee = 7;\n_teamFee = 5;\n}\n\nfunction setFee(uint256 multiplier) private {\n_taxFee = _taxFee * multiplier;\nif (multiplier > 1) {\n_teamFee = 10;\n}\n\n}\n\nfunction _approve(address owner, address spender, uint256 amount) private {\nrequire(owner != address(0), \"ERC20: approve from the zero address\");\nrequire(spender != address(0), \"ERC20: approve to the zero address\");\n_allowances[owner][spender] = amount;\nemit Approval(owner, spender, amount);\n}\n\nfunction _transfer(address from, address to, uint256 amount) private {\nrequire(from != address(0), \"ERC20: transfer from the zero address\");\nrequire(to != address(0), \"ERC20: transfer to the zero address\");\nrequire(amount > 0, \"Transfer amount must be greater than zero\");\n\nif (from != owner() && to != owner()) {\nif (cooldownEnabled) {\nif (from != address(this) && to != address(this) && from != address(uniswapV2Router) && to != address(uniswapV2Router)) {\nrequire(_msgSender() == address(uniswapV2Router) || _msgSender() == uniswapV2Pair,\"ERR: Uniswap only\");\n}\n}\nrequire(!bots[from] && !bots[to]);\nif (from == uniswapV2Pair && to != address(uniswapV2Router) && !_isExcludedFromFee[to] && cooldownEnabled) {\nrequire(tradingOpen);\nrequire(amount <= _maxTxAmount);\nrequire(buycooldown[to] < block.timestamp);\nbuycooldown[to] = block.timestamp + (30 seconds);\n_teamFee = 6;\n_taxFee = 2;\n}\nuint256 contractTokenBalance = balanceOf(address(this));\nif (!inSwap && from != uniswapV2Pair && swapEnabled) {\nrequire(amount <= balanceOf(uniswapV2Pair).mul(3).div(100) && amount <= _maxTxAmount);\nrequire(sellcooldown[from] < block.timestamp);\nif(firstsell[from] + (1 days) < block.timestamp){\nsellnumber[from] = 0;\n}\nif (sellnumber[from] == 0) {\nsellnumber[from]++;\nfirstsell[from] = block.timestamp;\nsellcooldown[from] = block.timestamp + (1 hours);\n}\nelse if (sellnumber[from] == 1) {\nsellnumber[from]++;\nsellcooldown[from] = block.timestamp + (2 hours);\n}\nelse if (sellnumber[from] == 2) {\nsellnumber[from]++;\nsellcooldown[from] = block.timestamp + (6 hours);\n}\nelse if (sellnumber[from] == 3) {\nsellnumber[from]++;\nsellcooldown[from] = firstsell[from] + (1 days);\n}\nswapTokensForEth(contractTokenBalance);\nuint256 contractETHBalance = address(this).balance;\nif (contractETHBalance > 0) {\nsendETHToFee(address(this).balance);\n}\nsetFee(sellnumber[from]);\n}\n}\nbool takeFee = true;\n\nif (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {\ntakeFee = false;\n}\n\n_tokenTransfer(from, to, amount, takeFee);\nrestoreAllFee;\n}\n\nfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\naddress[] memory path = new address[](2);\npath[0] = address(this);\npath[1] = uniswapV2Router.WETH();\n_approve(address(this), address(uniswapV2Router), tokenAmount);\nuniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(tokenAmount, 0, path, address(this), block.timestamp);\n}\n\nfunction sendETHToFee(uint256 amount) private {\n_teamAddress.transfer(amount.div(2));\n_marketingFunds.transfer(amount.div(2));\n}\n\nfunction openTrading() public onlyOwner {\nrequire(liquidityAdded);\ntradingOpen = true;\n}\n\nfunction addLiquidity() external onlyOwner() {\nIUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\nuniswapV2Router = _uniswapV2Router;\n_approve(address(this), address(uniswapV2Router), _tTotal);\nuniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\nuniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);\nswapEnabled = true;\ncooldownEnabled = true;\nliquidityAdded = true;\n_maxTxAmount = 10000000000 * 10**9;\nIERC20(uniswapV2Pair).approve(address(uniswapV2Router),type(uint256).max);\n}\n\nfunction manualswap() external {\nrequire(_msgSender() == _teamAddress);\nuint256 contractBalance = balanceOf(address(this));\nswapTokensForEth(contractBalance);\n}\n\nfunction manualsend() external {\nrequire(_msgSender() == _teamAddress);\nuint256 contractETHBalance = address(this).balance;\nsendETHToFee(contractETHBalance);\n}\n\nfunction _tokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) private {\nif (!takeFee) removeAllFee();\n_transferStandard(sender, recipient, amount);\nif (!takeFee) restoreAllFee();\n}\n\nfunction _transferStandard(address sender, address recipient, uint256 tAmount) private {\n(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\n_rOwned[sender] = _rOwned[sender].sub(rAmount);\n_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n_takeTeam(tTeam);\n_reflectFee(rFee, tFee);\nemit Transfer(sender, recipient, tTransferAmount);\n}\n\nfunction _takeTeam(uint256 tTeam) private {\nuint256 currentRate = _getRate();\nuint256 rTeam = tTeam.mul(currentRate);\n_rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\n}\n\nfunction _reflectFee(uint256 rFee, uint256 tFee) private {\n_rTotal = _rTotal.sub(rFee);\n_tFeeTotal = _tFeeTotal.add(tFee);\n}\n\nreceive() external payable {}\n\nfunction _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n(uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _taxFee, _teamFee);\nuint256 currentRate = _getRate();\n(uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\nreturn (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n}\n\nfunction _getTValues(uint256 tAmount, uint256 taxFee, uint256 teamFee) private pure returns (uint256, uint256, uint256) {\nuint256 tFee = tAmount.mul(taxFee).div(100);\nuint256 tTeam = tAmount.mul(teamFee).div(100);\nuint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\nreturn (tTransferAmount, tFee, tTeam);\n}\n\nfunction _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\nuint256 rAmount = tAmount.mul(currentRate);\nuint256 rFee = tFee.mul(currentRate);\nuint256 rTeam = tTeam.mul(currentRate);\nuint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\nreturn (rAmount, rTransferAmount, rFee);\n}\n\nfunction _getRate() private view returns (uint256) {\n(uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\nreturn rSupply.div(tSupply);\n}\n\nfunction _getCurrentSupply() private view returns (uint256, uint256) {\nuint256 rSupply = _rTotal;\nuint256 tSupply = _tTotal;\nif (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\nreturn (rSupply, tSupply);\n}\n\nfunction setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {\nrequire(maxTxPercent > 0, \"Amount must be greater than 0\");\n_maxTxAmount = _tTotal.mul(maxTxPercent).div(10**2);\nemit MaxTxAmountUpdated(_maxTxAmount);\n}\n}\n"}}}