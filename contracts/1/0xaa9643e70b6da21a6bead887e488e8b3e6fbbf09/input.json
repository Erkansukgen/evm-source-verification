{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Treasure.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n//ropsten\n// router 0x7a250d5630b4cf539739df2c5dacb4c659f2488d\n// token dai 0xad6d458402f60fd3bd25163575031acdce07538d\n\n \n  contract MultiOwnable {\n     address[] public owners;\n     mapping(address => bool) public ownerByAddress;\n     \n     modifier onlyOwner(){\n         require(ownerByAddress[msg.sender] == true);\n         _;\n     }\n     \n     function addOwner(address owner) public onlyOwner {\n         _addOwner(owner);\n     }\n     \n     function _addOwner(address owner) internal {\n         ownerByAddress[owner] = true;\n         owners.push(owner);\n     }\n }\n \n \n contract Treasure is MultiOwnable {\n     IUniswapRouter uniswapRouter;\n     \n     event Debug(string msg);\n     \n     constructor(address _uniswapRouterAddress, address owner0, address owner1) payable {\n         uniswapRouter = IUniswapRouter(_uniswapRouterAddress);\n         _addOwner(owner0);\n         _addOwner(owner1);\n     }\n     \n     function changeRouter(address _router) public onlyOwner {\n         uniswapRouter = IUniswapRouter(_router);\n     }\n     \n     function buyToken(uint value, address token, uint deadline, address buyBeforeAddress, uint buyBeforeBalance) public onlyOwner {\n         uint currentBalance = IERC20(token).balanceOf(buyBeforeAddress);\n         if(currentBalance > buyBeforeBalance) {\n             revert(string(abi.encodePacked(\"Already bought \", uint2str(currentBalance))));\n         }\n         \n         address[] memory path = new address[](2);\n         path[0] = uniswapRouter.WETH();\n         path[1] = token;\n         approveIfNotAllowed(uniswapRouter.WETH(), 500 ether);\n         uniswapRouter.swapExactETHForTokens{value: value}(1, path, address(this), deadline);\n     }\n     \n     function sellToken(address token, uint deadline, address buyBeforeAddress, uint buyBeforeBalance) public onlyOwner {\n         uint currentBalance = IERC20(token).balanceOf(buyBeforeAddress);\n         uint it = 0;\n         while (currentBalance <= buyBeforeBalance) {\n             currentBalance = IERC20(token).balanceOf(buyBeforeAddress);\n             emit Debug(string(abi.encodePacked(\"Balance \", uint2str(currentBalance), \" at iteration \", uint2str(it))));\n              it++;\n         }\n         \n         _internalSellToken(token, deadline);\n     }\n     \n     function forceSell(address token, uint deadline) public onlyOwner {\n         _internalSellToken(token, deadline);\n     }\n     \n     function _internalSellToken(address token, uint deadline) internal {\n        address[] memory reversePath = new address[](2);\n        reversePath[0] = token;\n        reversePath[1] = uniswapRouter.WETH();\n        approveIfNotAllowed(token, 115792089237316195423570985008687907853269984665640564039457584007913129639935);\n        \n        uint tokenAmount = IERC20(token).balanceOf(address(this));\n        uint amountOutMin = 1;\n        uniswapRouter.swapExactTokensForETH(tokenAmount, amountOutMin, reversePath, address(this), deadline);\n     }\n     \n     fallback() external payable {\n         \n     }\n     \n     function widthraw(uint amount) public onlyOwner {\n         msg.sender.transfer(amount);\n     }\n     \n     function approveIfNotAllowed(address token, uint amount) internal {\n        if(IERC20(token).allowance(address(this), address(uniswapRouter)) == 0) {\n             IERC20(token).approve(address(uniswapRouter), amount);\n         }\n     }\n     \n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len;\n        while (_i != 0) {\n            k = k-1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n     \n }\n\n \n  interface IUniswapRouter {\n    function swapExactETHForTokens(\n        uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts\n    );\n    \n    function swapETHForExactTokens(\n        uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts\n    );\n    \n        \n    function swapExactTokensForETH(\n        uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts\n    );\n    \n    function WETH() external pure returns(address);\n }\n \n interface IERC20 {\n     function balanceOf(address account) external view returns (uint256);\n     function approve(address spender, uint256 amount) external returns (bool);\n     function allowance(address owner, address spender) external view returns (uint256);\n }"
    }
  }
}