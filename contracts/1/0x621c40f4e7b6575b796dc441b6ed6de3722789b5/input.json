{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "tset.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.6;\r\n\r\nstruct ExactInputSingleParams {\r\n    address tokenIn;\r\n    address tokenOut;\r\n    uint24 fee;\r\n    address recipient;\r\n    uint256 deadline;\r\n    uint256 amountIn;\r\n    uint256 amountOutMinimum;\r\n    uint160 sqrtPriceLimitX96;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapRouterV3 {\r\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\r\n}\r\n\r\n// https://etherscan.io/address/0x2F9EC37d6CcFFf1caB21733BdaDEdE11c823cCB0#code\r\ninterface IBancorNetwork {\r\n     function conversionPath(\r\n         IERC20 _sourceToken, \r\n         IERC20 _targetToken\r\n    ) external view returns (address[] memory);\r\n    function convert(\r\n        address[] memory path,\r\n        uint256 sourceAmount,\r\n        uint256 minReturn\r\n    ) external payable returns (uint256);\r\n    function convertByPath(\r\n        address[] memory path,\r\n        uint256 sourceAmount,\r\n        uint256 minReturn,\r\n        address payable beneficiary,\r\n        address affiliate,\r\n        uint256 affiliateFee\r\n    ) external payable returns (uint256);\r\n}\r\n\r\ninterface ICRV_PP_128_NP {\r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\r\n}\r\ninterface ICRV_PP_256_NP {\r\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy, bool use_eth) external;\r\n}\r\ninterface ICRV_PP_256_P {\r\n    function exchange_underlying(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external payable returns(uint256);\r\n}\r\ninterface ICRV_MP_256 {\r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external payable returns(uint256);\r\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external payable returns(uint256);\r\n}\r\n\r\n// https://etherscan.io/address/0xd9e1ce17f2641f24ae83637ab66a2cca9c378b9f#code\r\ninterface ISushiRouter {\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external;\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external;\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IVault {\r\n    function flashLoan(\r\n        IFlashLoanRecipient recipient,\r\n        IERC20[] memory tokens,\r\n        uint256[] memory amounts,\r\n        bytes memory userData\r\n    ) external;\r\n}\r\n\r\ninterface IFlashLoanRecipient {\r\n    function receiveFlashLoan(\r\n        IERC20[] memory tokens,\r\n        uint256[] memory amounts,\r\n        uint256[] memory feeAmounts,\r\n        bytes memory userData\r\n    ) external;\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\ncontract DapperFlat {\r\n\r\n    address public owner;\r\n    address public bal_v2_vault;\r\n    address public sushi_router;\r\n    address public uni_v2_router;\r\n    address public uni_v3_router;\r\n    address public bancor_network;\r\n\r\n    IVault internal i_bal_v2_bault;\r\n    ISushiRouter internal i_sushi_router;\r\n    IUniswapV2Router01 internal i_uni_v2_router;\r\n    IUniswapRouterV3 internal i_uni_v3_router;\r\n    IBancorNetwork internal i_bancor_network;\r\n\r\n    address public _3CRV = 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490;\r\n    address public WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address public WETH_NULL = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    IWETH i_weth = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n\r\n    uint private hops;\r\n    uint[12] private venues;\r\n    address[12] private route;\r\n\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        bal_v2_vault = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;\r\n        i_bal_v2_bault = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\r\n        sushi_router = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\r\n        i_sushi_router = ISushiRouter(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\r\n        uni_v2_router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n        i_uni_v2_router = IUniswapV2Router01(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        uni_v3_router = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\r\n        i_uni_v3_router = IUniswapRouterV3(0xE592427A0AEce92De3Edee1F18E0157C05861564);\r\n        bancor_network = 0x2F9EC37d6CcFFf1caB21733BdaDEdE11c823cCB0;\r\n        i_bancor_network = IBancorNetwork(0x2F9EC37d6CcFFf1caB21733BdaDEdE11c823cCB0);\r\n    }\r\n\r\n    modifier isOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function withdrawToken(\r\n        address token\r\n    ) public {\r\n        IERC20(token).transfer(owner, IERC20(token).balanceOf(address(this)));\r\n    }\r\n\r\n    function receiveFlashLoan(\r\n        IERC20[] memory tokens,\r\n        uint256[] memory amounts,\r\n        uint256[] memory feeAmounts,\r\n        bytes calldata userData\r\n    ) public {\r\n\r\n        uint _transferAmt;\r\n        address _from;\r\n        address _to;\r\n\r\n        for (uint i = 0; i < hops; i++) {\r\n\r\n            if (i == hops - 1) {\r\n                _transferAmt = IERC20(route[i]).balanceOf(address(this));\r\n                _from = route[i];\r\n                _to = route[0];\r\n            }\r\n            else {\r\n                _transferAmt = IERC20(route[i]).balanceOf(address(this));\r\n                _from = route[i];\r\n                _to = route[i + 1];\r\n            }\r\n\r\n            // UniswapV2\r\n            if (venues[i] == 0) {\r\n                address[] memory path_uni_v2 = new address[](2);\r\n                path_uni_v2[0] = _from;\r\n                path_uni_v2[1] = _to;\r\n                IERC20(_from).approve(uni_v2_router, _transferAmt);\r\n                i_uni_v2_router.swapExactTokensForTokens(\r\n                    _transferAmt,\r\n                    0,\r\n                    path_uni_v2,\r\n                    address(this),\r\n                    block.timestamp + 120 seconds\r\n                );\r\n                delete path_uni_v2;\r\n            }\r\n            // Sushi\r\n            else if (venues[i] == 1) {\r\n                address[] memory sushi_path = new address[](2);\r\n                sushi_path[0] = _from;\r\n                sushi_path[1] = _to;\r\n                IERC20(_from).approve(sushi_router, _transferAmt);\r\n                i_sushi_router.swapExactTokensForTokens(\r\n                    _transferAmt,\r\n                    0,\r\n                    sushi_path,\r\n                    address(this),\r\n                    block.timestamp + 120 seconds\r\n                );\r\n                delete sushi_path;\r\n            }\r\n            // BancorV2\r\n            else if (venues[i] == 2) {\r\n                if (_from == WETH) {\r\n                    address[] memory bancor_path = i_bancor_network.conversionPath(\r\n                        IERC20(WETH_NULL), IERC20(_to)\r\n                    );\r\n                    i_weth.withdraw(_transferAmt);\r\n                    i_bancor_network.convertByPath{value: _transferAmt}(\r\n                        bancor_path,\r\n                        _transferAmt,\r\n                        1,\r\n                        payable(this),\r\n                        address(this),\r\n                        10\r\n                    );\r\n                }\r\n                else if (_to == WETH) {\r\n                    address[] memory bancor_path = i_bancor_network.conversionPath(\r\n                        IERC20(_from), IERC20(WETH_NULL)\r\n                    );\r\n                    IERC20(_from).approve(address(i_bancor_network), _transferAmt);\r\n                    uint256 swap = i_bancor_network.convertByPath(\r\n                        bancor_path,\r\n                        _transferAmt,\r\n                        1,\r\n                        payable(this),\r\n                        owner,\r\n                        10\r\n                    );\r\n                    i_weth.deposit{value: swap}();\r\n                }\r\n                else {\r\n                    address[] memory bancor_path = i_bancor_network.conversionPath(\r\n                        IERC20(_from), IERC20(_to)\r\n                    );\r\n                    IERC20(_from).approve(address(i_bancor_network), _transferAmt);\r\n                    i_bancor_network.convertByPath(\r\n                        bancor_path,\r\n                        _transferAmt,\r\n                        1,\r\n                        payable(this),\r\n                        owner,\r\n                        10 \r\n                    );\r\n                }\r\n            }\r\n            // CRV_PP_int128\r\n            else if (venues[i] == 3) {\r\n                IERC20(_from).approve(route[i*2 + 4], _transferAmt);\r\n                ICRV_PP_128_NP(route[i*2 + 4]).exchange(\r\n                    int128(int256(venues[i*2 + 4])), int128(int256(venues[i*2 + 5])), _transferAmt, 0\r\n                );\r\n            }\r\n             // CRV_PP_uint256 non-payable\r\n            else if (venues[i] == 4) {\r\n                IERC20(_from).approve(route[i*2 + 4], _transferAmt);\r\n                ICRV_PP_256_NP(route[i*2 + 4]).exchange(\r\n                    venues[i*2 + 4], venues[i*2 + 5], _transferAmt, 0, false\r\n                );\r\n            }\r\n            // CRV_PP_uint256 payable\r\n            else if (venues[i] == 5) {\r\n                if (_from == WETH) {\r\n                    i_weth.withdraw(_transferAmt);\r\n                    ICRV_PP_256_P(route[i*2 + 4]).exchange_underlying{value: _transferAmt}(\r\n                        venues[i*2 + 4], venues[i*2 + 5], _transferAmt, 0\r\n                    );\r\n                }\r\n                else if (_to == WETH) {\r\n                    IERC20(_from).approve(route[i*2 + 4], _transferAmt);\r\n                    uint256 swap = ICRV_PP_256_P(route[i*2 + 4]).exchange_underlying(\r\n                        venues[i*2 + 4], venues[i*2 + 5], _transferAmt, 0\r\n                    );\r\n                    i_weth.deposit{value: swap}();\r\n                }\r\n                else {\r\n                    IERC20(_from).approve(route[i*2 + 4], _transferAmt);\r\n                    ICRV_PP_256_P(route[i*2 + 4]).exchange_underlying(\r\n                        venues[i*2 + 4], venues[i*2 + 5], _transferAmt, 0\r\n                    );\r\n                }\r\n            }\r\n            // CRV_MP_XferThenXfer\r\n            else if (venues[i] == 6) {\r\n                IERC20(_from).approve(route[i*2 + 4], _transferAmt);\r\n                uint _swap = ICRV_MP_256(route[i*2 + 4]).exchange(0, 1, _transferAmt, 0);\r\n                IERC20(_3CRV).approve(route[i*2 + 5], _swap);\r\n                ICRV_MP_256(route[i*2 + 5]).exchange(1, 0, _swap, 0);\r\n            }\r\n            // CRV_MP_MintThenXfer - or - CRV_MP_XferThenBurn\r\n            else if (venues[i] == 7) {\r\n                IERC20(_from).approve(route[i*2 + 4], _transferAmt);\r\n                ICRV_MP_256(route[i*2 + 4]).exchange_underlying(\r\n                    int128(int256(venues[i*2 + 4])), int128(int256(venues[i*2 + 5])), _transferAmt, 0\r\n                );\r\n            }\r\n            // Uniswap V3\r\n            else if (venues[i] == 8) {\r\n                ExactInputSingleParams memory params = ExactInputSingleParams(\r\n                    _from,      // tokenIn\r\n                    _to,        // tokenOut\r\n                    uint24(venues[i*2 + 4]),   // fee (???)\r\n                    address(this),  // recipient\r\n                    block.timestamp + 120 seconds, // deadline\r\n                    _transferAmt,   // amountIn\r\n                    0,              // amountOutMinimum\r\n                    0               // sqrtPriceLimitX96\r\n                );\r\n\r\n                IERC20(_from).approve(uni_v3_router, _transferAmt); // Approve V3 Router\r\n\r\n                i_uni_v3_router.exactInputSingle(params);\r\n            }\r\n            else {\r\n                revert();\r\n            }\r\n\r\n        }\r\n\r\n        delete _transferAmt;\r\n        delete _from;\r\n        delete _to;\r\n\r\n        // Return initial tokens back to vault.\r\n        tokens[0].transfer(bal_v2_vault, amounts[0]);\r\n\r\n        \r\n    }\r\n    \r\n    function get_paid(\r\n        uint _hops,\r\n        address[12] memory _route,\r\n        uint[12] memory _venues,\r\n        address _borrow, \r\n        uint _borrowAmt,\r\n        uint _preBlock\r\n    ) public {\r\n        \r\n        require(_preBlock + 1 == block.number, \"err_1\");\r\n\r\n        hops = _hops;\r\n        venues = _venues;\r\n        route = _route;\r\n        \r\n        IERC20[] memory _passThroughTokens = new IERC20[](1);\r\n        _passThroughTokens[0] = IERC20(_borrow);\r\n\r\n        uint256[] memory _passThroughAmounts = new uint256[](1);\r\n        _passThroughAmounts[0] = _borrowAmt;\r\n\r\n        i_bal_v2_bault.flashLoan(\r\n            IFlashLoanRecipient(address(this)),\r\n            _passThroughTokens,\r\n            _passThroughAmounts,\r\n            ''\r\n        );\r\n\r\n        delete _passThroughTokens;\r\n        delete _passThroughAmounts;\r\n\r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n}\r\n"
    }
  }
}