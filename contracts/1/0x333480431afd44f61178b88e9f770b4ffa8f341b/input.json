{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":1000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Timelock.sol":{"content":"// File contracts/governance/Timelock.sol\r\n\r\n// SPDX-License-Identifier: Unlicense\r\npragma solidity 0.8.9;\r\n\r\ncontract Timelock {\r\n    event NewAdmin(address indexed newAdmin);\r\n    event NewPendingAdmin(address indexed newPendingAdmin);\r\n    event NewDelay(uint256 indexed newDelay);\r\n    event CancelTransaction(\r\n        bytes32 indexed txHash,\r\n        address indexed target,\r\n        uint256 value,\r\n        string signature,\r\n        bytes data,\r\n        uint256 eta\r\n    );\r\n    event ExecuteTransaction(\r\n        bytes32 indexed txHash,\r\n        address indexed target,\r\n        uint256 value,\r\n        string signature,\r\n        bytes data,\r\n        uint256 eta\r\n    );\r\n    event QueueTransaction(\r\n        bytes32 indexed txHash,\r\n        address indexed target,\r\n        uint256 value,\r\n        string signature,\r\n        bytes data,\r\n        uint256 eta\r\n    );\r\n\r\n    uint256 public constant GRACE_PERIOD = 14 days;\r\n    uint256 public constant MINIMUM_DELAY = 2 days;\r\n    uint256 public constant MAXIMUM_DELAY = 30 days;\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    uint256 public delay;\r\n\r\n    mapping(bytes32 => bool) public queuedTransactions;\r\n\r\n    constructor(address admin_, uint256 delay_) {\r\n        require(\r\n            delay_ >= MINIMUM_DELAY,\r\n            \"Timelock::constructor: Delay must exceed minimum delay.\"\r\n        );\r\n        require(\r\n            delay_ <= MAXIMUM_DELAY,\r\n            \"Timelock::setDelay: Delay must not exceed maximum delay.\"\r\n        );\r\n\r\n        admin = admin_;\r\n        delay = delay_;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function setDelay(uint256 delay_) public {\r\n        require(\r\n            msg.sender == address(this),\r\n            \"Timelock::setDelay: Call must come from Timelock.\"\r\n        );\r\n        require(\r\n            delay_ >= MINIMUM_DELAY,\r\n            \"Timelock::setDelay: Delay must exceed minimum delay.\"\r\n        );\r\n        require(\r\n            delay_ <= MAXIMUM_DELAY,\r\n            \"Timelock::setDelay: Delay must not exceed maximum delay.\"\r\n        );\r\n        delay = delay_;\r\n\r\n        emit NewDelay(delay);\r\n    }\r\n\r\n    function acceptAdmin() public {\r\n        require(\r\n            msg.sender == pendingAdmin,\r\n            \"Timelock::acceptAdmin: Call must come from pendingAdmin.\"\r\n        );\r\n        admin = msg.sender;\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(admin);\r\n    }\r\n\r\n    function setPendingAdmin(address pendingAdmin_) public {\r\n        require(\r\n            msg.sender == address(this),\r\n            \"Timelock::setPendingAdmin: Call must come from Timelock.\"\r\n        );\r\n        pendingAdmin = pendingAdmin_;\r\n\r\n        emit NewPendingAdmin(pendingAdmin);\r\n    }\r\n\r\n    function queueTransaction(\r\n        address target,\r\n        uint256 value,\r\n        string calldata signature,\r\n        bytes calldata data,\r\n        uint256 eta\r\n    ) public returns (bytes32) {\r\n        require(\r\n            msg.sender == admin,\r\n            \"Timelock::queueTransaction: Call must come from admin.\"\r\n        );\r\n        require(\r\n            eta >= block.timestamp + delay,\r\n            \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\r\n        );\r\n\r\n        bytes32 txHash = keccak256(\r\n            abi.encode(target, value, signature, data, eta)\r\n        );\r\n        queuedTransactions[txHash] = true;\r\n\r\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\r\n        return txHash;\r\n    }\r\n\r\n    function cancelTransaction(\r\n        address target,\r\n        uint256 value,\r\n        string calldata signature,\r\n        bytes calldata data,\r\n        uint256 eta\r\n    ) public {\r\n        require(\r\n            msg.sender == admin,\r\n            \"Timelock::cancelTransaction: Call must come from admin.\"\r\n        );\r\n\r\n        bytes32 txHash = keccak256(\r\n            abi.encode(target, value, signature, data, eta)\r\n        );\r\n        queuedTransactions[txHash] = false;\r\n\r\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\r\n    }\r\n\r\n    function executeTransaction(\r\n        address target,\r\n        uint256 value,\r\n        string calldata signature,\r\n        bytes calldata data,\r\n        uint256 eta\r\n    ) public payable returns (bytes memory) {\r\n        require(\r\n            msg.sender == admin,\r\n            \"Timelock::executeTransaction: Call must come from admin.\"\r\n        );\r\n\r\n        bytes32 txHash = keccak256(\r\n            abi.encode(target, value, signature, data, eta)\r\n        );\r\n        require(\r\n            queuedTransactions[txHash],\r\n            \"Timelock::executeTransaction: Transaction hasn't been queued.\"\r\n        );\r\n        require(\r\n            block.timestamp >= eta,\r\n            \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\"\r\n        );\r\n        require(\r\n            block.timestamp <= eta + GRACE_PERIOD,\r\n            \"Timelock::executeTransaction: Transaction is stale.\"\r\n        );\r\n\r\n        queuedTransactions[txHash] = false;\r\n\r\n        bytes memory callData;\r\n\r\n        if (bytes(signature).length == 0) {\r\n            callData = data;\r\n        } else {\r\n            callData = abi.encodePacked(\r\n                bytes4(keccak256(bytes(signature))),\r\n                data\r\n            );\r\n        }\r\n\r\n        // solium-disable-next-line security/no-call-value\r\n        (bool success, bytes memory returnData) = target.call{\r\n            value: value\r\n        }(\r\n            callData\r\n        );\r\n        require(\r\n            success,\r\n            \"Timelock::executeTransaction: Transaction execution reverted.\"\r\n        );\r\n\r\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\r\n\r\n        return returnData;\r\n    }\r\n}"}}}