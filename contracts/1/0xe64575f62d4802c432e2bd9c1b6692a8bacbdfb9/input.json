{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/Fixed.sol": {
      "content": "pragma solidity 0.6.7;\n\nabstract contract StabilityFeeTreasuryLike {\n    function getAllowance(address) virtual public view returns (uint256, uint256);\n    function setPerBlockAllowance(address, uint256) virtual external;\n}\nabstract contract TreasuryFundableLike {\n    function authorizedAccounts(address) virtual public view returns (uint256);\n    function fixedReward() virtual public view returns (uint256);\n    function modifyParameters(bytes32, uint256) virtual external;\n}\nabstract contract TreasuryParamAdjusterLike {\n    function adjustMaxReward(address receiver, bytes4 targetFunctionSignature, uint256 newMaxReward) virtual external;\n}\nabstract contract OracleLike {\n    function read() virtual external view returns (uint256);\n}\nabstract contract OracleRelayerLike {\n    function redemptionPrice() virtual public returns (uint256);\n}\n\ncontract FixedRewardsAdjuster {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"FixedRewardsAdjuster/account-not-authorized\");\n        _;\n    }\n\n    // --- Structs ---\n    struct FundingReceiver {\n        // Last timestamp when the funding receiver data was updated\n        uint256 lastUpdateTime;           // [unix timestamp]\n        // Gas amount used to execute this funded function\n        uint256 gasAmountForExecution;    // [gas amount]\n        // Delay between two calls to recompute the fees for this funded function\n        uint256 updateDelay;              // [seconds]\n        // Multiplier applied to the computed fixed reward\n        uint256 fixedRewardMultiplier;     // [hundred]\n    }\n\n    // --- Variables ---\n    // Data about funding receivers\n    mapping(address => mapping(bytes4 => FundingReceiver)) public fundingReceivers;\n\n    // The gas price oracle\n    OracleLike                public gasPriceOracle;\n    // The ETH oracle\n    OracleLike                public ethPriceOracle;\n    // The contract that adjusts SF treasury parameters and needs to be updated with max rewards for each funding receiver\n    TreasuryParamAdjusterLike public treasuryParamAdjuster;\n    // The oracle relayer contract\n    OracleRelayerLike         public oracleRelayer;\n    // The SF treasury contract\n    StabilityFeeTreasuryLike  public treasury;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 parameter, address addr);\n    event ModifyParameters(address receiver, bytes4 targetFunction, bytes32 parameter, uint256 val);\n    event AddFundingReceiver(\n        address indexed receiver,\n        bytes4  targetFunctionSignature,\n        uint256 updateDelay,\n        uint256 gasAmountForExecution,\n        uint256 fixedRewardMultiplier\n    );\n    event RemoveFundingReceiver(address indexed receiver, bytes4 targetFunctionSignature);\n    event RecomputedRewards(address receiver, uint256 newFixedReward);\n\n    constructor(\n        address oracleRelayer_,\n        address treasury_,\n        address gasPriceOracle_,\n        address ethPriceOracle_,\n        address treasuryParamAdjuster_\n    ) public {\n        // Checks\n        require(oracleRelayer_ != address(0), \"FixedRewardsAdjuster/null-oracle-relayer\");\n        require(treasury_ != address(0), \"FixedRewardsAdjuster/null-treasury\");\n        require(gasPriceOracle_ != address(0), \"FixedRewardsAdjuster/null-gas-oracle\");\n        require(ethPriceOracle_ != address(0), \"FixedRewardsAdjuster/null-eth-oracle\");\n        require(treasuryParamAdjuster_ != address(0), \"FixedRewardsAdjuster/null-treasury-adjuster\");\n\n\t      authorizedAccounts[msg.sender]   = 1;\n\n        // Store\n        oracleRelayer         = OracleRelayerLike(oracleRelayer_);\n        treasury              = StabilityFeeTreasuryLike(treasury_);\n        gasPriceOracle        = OracleLike(gasPriceOracle_);\n        ethPriceOracle        = OracleLike(ethPriceOracle_);\n        treasuryParamAdjuster = TreasuryParamAdjusterLike(treasuryParamAdjuster_);\n\n        // Check that the oracle relayer has a redemption price stored\n        oracleRelayer.redemptionPrice();\n\n        // Emit events\n        emit ModifyParameters(\"treasury\", treasury_);\n        emit ModifyParameters(\"oracleRelayer\", oracleRelayer_);\n        emit ModifyParameters(\"gasPriceOracle\", gasPriceOracle_);\n        emit ModifyParameters(\"ethPriceOracle\", ethPriceOracle_);\n        emit ModifyParameters(\"treasuryParamAdjuster\", treasuryParamAdjuster_);\n    }\n\n    // --- Boolean Logic ---\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n\n    // --- Math ---\n    uint256 public constant WAD            = 10**18;\n    uint256 public constant RAY            = 10**27;\n    uint256 public constant HUNDRED        = 100;\n    uint256 public constant THOUSAND       = 1000;\n\n    function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"FixedRewardsAdjuster/add-uint-uint-overflow\");\n    }\n    function subtract(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"FixedRewardsAdjuster/sub-uint-uint-underflow\");\n    }\n    function multiply(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"FixedRewardsAdjuster/multiply-uint-uint-overflow\");\n    }\n    function divide(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y > 0, \"FixedRewardsAdjuster/div-y-null\");\n        z = x / y;\n        require(z <= x, \"FixedRewardsAdjuster/div-invalid\");\n    }\n    function wdivide(uint x, uint y) public pure returns (uint z) {\n        require(y > 0, \"FixedRewardsAdjuster/div-y-null\");\n        z = multiply(x, WAD) / y;\n    }\n\n    // --- Administration ---\n    /*\n    * @notify Update the address of a contract that this adjuster is connected to\n    * @param parameter The name of the contract to update the address for\n    * @param addr The new contract address\n    */\n    function modifyParameters(bytes32 parameter, address addr) external isAuthorized {\n        require(addr != address(0), \"FixedRewardsAdjuster/null-address\");\n        if (parameter == \"oracleRelayer\") {\n            oracleRelayer = OracleRelayerLike(addr);\n            oracleRelayer.redemptionPrice();\n        }\n        else if (parameter == \"treasury\") {\n            treasury = StabilityFeeTreasuryLike(addr);\n        }\n        else if (parameter == \"gasPriceOracle\") {\n            gasPriceOracle = OracleLike(addr);\n        }\n        else if (parameter == \"ethPriceOracle\") {\n            ethPriceOracle = OracleLike(addr);\n        }\n        else if (parameter == \"treasuryParamAdjuster\") {\n            treasuryParamAdjuster = TreasuryParamAdjusterLike(addr);\n        }\n        else revert(\"FixedRewardsAdjuster/modify-unrecognized-params\");\n        emit ModifyParameters(parameter, addr);\n    }\n    /*\n    * @notify Change a parameter for a funding receiver\n    * @param receiver The address of the funding receiver\n    * @param targetFunction The function whose callers receive funding for calling\n    * @param parameter The name of the parameter to change\n    * @param val The new parameter value\n    */\n    function modifyParameters(address receiver, bytes4 targetFunction, bytes32 parameter, uint256 val) external isAuthorized {\n        require(val > 0, \"FixedRewardsAdjuster/null-value\");\n        FundingReceiver storage fundingReceiver = fundingReceivers[receiver][targetFunction];\n        require(fundingReceiver.lastUpdateTime > 0, \"FixedRewardsAdjuster/non-existent-receiver\");\n\n        if (parameter == \"gasAmountForExecution\") {\n            require(val < block.gaslimit, \"FixedRewardsAdjuster/invalid-gas-amount-for-exec\");\n            fundingReceiver.gasAmountForExecution = val;\n        }\n        else if (parameter == \"updateDelay\") {\n            fundingReceiver.updateDelay = val;\n        }\n        else if (parameter == \"fixedRewardMultiplier\") {\n            require(both(val >= HUNDRED, val <= THOUSAND), \"FixedRewardsAdjuster/invalid-fixed-reward-multiplier\");\n            fundingReceiver.fixedRewardMultiplier = val;\n        }\n        else revert(\"FixedRewardsAdjuster/modify-unrecognized-params\");\n        emit ModifyParameters(receiver, targetFunction, parameter, val);\n    }\n\n    /*\n    * @notify Add a new funding receiver\n    * @param receiver The funding receiver address\n    * @param targetFunctionSignature The signature of the function whose callers get funding\n    * @param updateDelay The update delay between two consecutive calls that update the base and max rewards for this receiver\n    * @param gasAmountForExecution The gas amount spent calling the function with signature targetFunctionSignature\n    * @param fixedRewardMultiplier Multiplier applied to the computed base reward\n    * @param maxRewardMultiplier Multiplied applied to the computed max reward\n    */\n    function addFundingReceiver(\n        address receiver,\n        bytes4  targetFunctionSignature,\n        uint256 updateDelay,\n        uint256 gasAmountForExecution,\n        uint256 fixedRewardMultiplier\n    ) external isAuthorized {\n        // Checks\n        require(receiver != address(0), \"FixedRewardsAdjuster/null-receiver\");\n        require(updateDelay > 0, \"FixedRewardsAdjuster/null-update-delay\");\n        require(both(fixedRewardMultiplier >= HUNDRED, fixedRewardMultiplier <= THOUSAND), \"FixedRewardsAdjuster/invalid-fixed-reward-multiplier\");\n        require(gasAmountForExecution > 0, \"FixedRewardsAdjuster/null-gas-amount\");\n        require(gasAmountForExecution < block.gaslimit, \"FixedRewardsAdjuster/large-gas-amount-for-exec\");\n\n        // Check that the receiver hasn't been already added\n        FundingReceiver storage newReceiver = fundingReceivers[receiver][targetFunctionSignature];\n        require(newReceiver.lastUpdateTime == 0, \"FixedRewardsAdjuster/receiver-already-added\");\n\n        // Add the receiver's data\n        newReceiver.lastUpdateTime        = now;\n        newReceiver.updateDelay           = updateDelay;\n        newReceiver.gasAmountForExecution = gasAmountForExecution;\n        newReceiver.fixedRewardMultiplier = fixedRewardMultiplier;\n\n        emit AddFundingReceiver(\n          receiver,\n          targetFunctionSignature,\n          updateDelay,\n          gasAmountForExecution,\n          fixedRewardMultiplier\n        );\n    }\n    /*\n    * @notify Remove an already added funding receiver\n    * @param receiver The funding receiver address\n    * @param targetFunctionSignature The signature of the function whose callers get funding\n    */\n    function removeFundingReceiver(address receiver, bytes4 targetFunctionSignature) external isAuthorized {\n        // Check that the receiver is still stored and then delete it\n        require(fundingReceivers[receiver][targetFunctionSignature].lastUpdateTime > 0, \"FixedRewardsAdjuster/non-existent-receiver\");\n        delete(fundingReceivers[receiver][targetFunctionSignature]);\n        emit RemoveFundingReceiver(receiver, targetFunctionSignature);\n    }\n\n    // --- Core Logic ---\n    /*\n    * @notify Recompute the base and max rewards for a specific funding receiver with a specific function offering funding\n    * @param receiver The funding receiver address\n    * @param targetFunctionSignature The signature of the function whose callers get funding\n    */\n    function recomputeRewards(address receiver, bytes4 targetFunctionSignature) external {\n        FundingReceiver storage targetReceiver = fundingReceivers[receiver][targetFunctionSignature];\n        require(both(targetReceiver.lastUpdateTime > 0, addition(targetReceiver.lastUpdateTime, targetReceiver.updateDelay) <= now), \"FixedRewardsAdjuster/wait-more\");\n\n        // Update last time\n        targetReceiver.lastUpdateTime = now;\n\n        // Read the gas and the ETH prices\n        uint256 gasPrice = gasPriceOracle.read();\n        uint256 ethPrice = ethPriceOracle.read();\n\n        // Calculate the fixed fiat value\n        uint256 fixedRewardDenominatedValue = divide(multiply(multiply(gasPrice, targetReceiver.gasAmountForExecution), ethPrice), WAD);\n\n        // Calculate the fixed reward expressed in system coins\n        uint256 newFixedReward = divide(multiply(fixedRewardDenominatedValue, RAY), oracleRelayer.redemptionPrice());\n        newFixedReward         = divide(multiply(newFixedReward, targetReceiver.fixedRewardMultiplier), HUNDRED);\n        require(newFixedReward > 0, \"FixedRewardsAdjuster/null-fixed-reward\");\n\n        // Notify the treasury param adjuster about the new fixed reward\n        treasuryParamAdjuster.adjustMaxReward(receiver, targetFunctionSignature, newFixedReward);\n\n        // Approve the reward in the treasury\n        treasury.setPerBlockAllowance(receiver, multiply(newFixedReward, RAY));\n\n        // Set the new rewards inside the receiver contract\n        TreasuryFundableLike(receiver).modifyParameters(\"fixedReward\", newFixedReward);\n\n        emit RecomputedRewards(receiver, newFixedReward);\n    }\n}\n"
    }
  }
}