{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Untitled.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2019-07-11\n*/\n\npragma solidity ^0.5.10;\n\n/*\n * MintHelper and MultiSend for BSOV Mining Pool\n * BitcoinSoV (BSOV) Mineable & Deflationary\n *\n * https://www.btcsov.com\n * https://bsov-pool.hashtables.net\n *\n * Based off https://github.com/0xbitcoin/mint-helper\n */\n\n\ncontract Ownable {\n    address private _owner;\n    address private _payoutWallet;  // Added to prevent payouts interfering with minting requests. \n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () internal {\n        _owner = msg.sender;\n        _payoutWallet = msg.sender;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n    \n    function payoutWallet() public view returns (address) {\n        return _payoutWallet;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == _owner, \"Ownable: caller is not the owner, minter, or payer.\");\n        _;\n    }\n    \n    modifier onlyPayoutWallet() {\n        require(msg.sender == _owner || msg.sender == _payoutWallet, \"Ownable: caller is not the owner or payer.\");\n        _;\n    }\n\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n    \n    function setPayoutWallet(address newAddress) public onlyOwner {\n        _payoutWallet = newAddress;\n    }\n    \n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract ERC20Interface {\n    function totalSupply() public view returns (uint);\n    function balanceOf(address tokenOwner) public view returns (uint balance);\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\ncontract ERC918Interface {\n  function totalSupply() public view returns (uint);\n  function getMiningDifficulty() public view returns (uint);\n  function getMiningTarget() public view returns (uint);\n  function getMiningReward() public view returns (uint);\n  function balanceOf(address tokenOwner) public view returns (uint balance);\n\n  function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n\n  event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n}\n\n/*\nThe mintingWallet will proxy mint requests to be credited to the contract address.\nThe payoutWallet will call the multisend method to send out payments.\n*/\n\ncontract PoolHelper is Ownable {\n    string public name;\n    address public mintableToken;\n    mapping(bytes32 => bool) successfulPayments;\n\n    event Payment(bytes32 _paymentId);\n    \n    constructor(address mToken, string memory mName)\n    public\n    {\n      mintableToken = mToken;\n      name = mName;\n    }\n\n    function setMintableToken(address mToken)\n    public onlyOwner\n    returns (bool)\n    {\n      mintableToken = mToken;\n      return true;\n    }\n\n    function paymentSuccessful(bytes32 paymentId) public view returns (bool){\n        return (successfulPayments[paymentId] == true);\n    }\n    \n    function proxyMint(uint256 nonce, bytes32 challenge_digest )\n    public\n    returns (bool)\n    {\n      require(ERC918Interface(mintableToken).mint(nonce, challenge_digest), \"Could not mint token\");\n      return true;\n    }\n\n    //withdraw any eth inside\n    function withdraw()\n    public onlyOwner\n    {\n        msg.sender.transfer(address(this).balance);\n    }\n    \n    //send tokens out\n    function send(address _tokenAddr, bytes32 paymentId, address dest, uint value)\n    public onlyPayoutWallet\n    returns (bool)\n    {\n        require(successfulPayments[paymentId] != true, \"Payment ID already exists and was successful\");\n        successfulPayments[paymentId] = true;\n        emit Payment(paymentId);\n        return ERC20Interface(_tokenAddr).transfer(dest, value);\n    }\n\n    //batch send tokens\n    function multisend(address _tokenAddr, bytes32 paymentId, address[] memory dests, uint256[] memory values)\n    public onlyPayoutWallet\n    returns (uint256)\n    {\n        require(dests.length > 0, \"Must have more than 1 destination address\");\n        require(values.length >= dests.length, \"Address to Value array size mismatch\");\n        require(successfulPayments[paymentId] != true, \"Payment ID already exists and was successful\");\n\n        uint256 i = 0;\n        while (i < dests.length) {\n           require(ERC20Interface(_tokenAddr).transfer(dests[i], values[i]));\n           i += 1;\n        }\n\n        successfulPayments[paymentId] = true;\n        emit Payment(paymentId);\n        return (i);\n    }\n}"}}}