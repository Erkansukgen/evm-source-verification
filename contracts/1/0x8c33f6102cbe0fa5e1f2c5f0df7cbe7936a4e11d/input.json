{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/interfaces/v3pool.sol":{"content":"pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface v3pool {\n  function swap(address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data) external payable returns (int256 amount0, int256 amount1);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n    \n    function fee() external view returns (uint24);\n\n}\n"},"contracts/lib/BytesLib.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\r\n/*\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\r\n */\r\npragma solidity >=0.5.0 <0.8.0;\r\n\r\nlibrary BytesLib {\r\n\r\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\r\n        require(_start + 20 >= _start, 'toAddress_overflow');\r\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\r\n        require(_start + 3 >= _start, 'toUint24_overflow');\r\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\r\n        uint24 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x3), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n}\r\n"},"contracts/lib/Path.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.6.0;\r\n\r\nimport './BytesLib.sol';\r\n\r\n/// @title Functions for manipulating path data for multihop swaps\r\nlibrary Path {\r\n    using BytesLib for bytes;\r\n\r\n    /// @dev The length of the bytes encoded address\r\n    uint256 private constant ADDR_SIZE = 20;\r\n\r\n    /// @dev The length of the bytes encoded fee\r\n    uint256 private constant FEE_SIZE = 3;\r\n    /// @dev The offset of a single token address and pool fee\r\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\r\n\r\n\r\n\r\n    /// @notice Decodes the first pool in path\r\n    /// @param path The bytes encoded swap path\r\n    /// @return tokenA The first token of the given pool\r\n    /// @return tokenB The second token of the given pool\r\n    /// @return fee The fee level of the pool\r\n    function decodeFirstPool(bytes memory path)\r\n        internal\r\n        pure\r\n        returns (\r\n            address tokenA,\r\n            address tokenB,\r\n            uint24 fee\r\n        )\r\n    {\r\n        tokenA = path.toAddress(0);\r\n        fee = path.toUint24(ADDR_SIZE);\r\n        tokenB = path.toAddress(NEXT_OFFSET);\r\n    }\r\n\r\n}\r\n"},"contracts/lib/SafeMath.sol":{"content":"pragma solidity >=0.6.6;\n\n// SPDX-License-Identifier: MIT\n\nlibrary SafeMath {\n\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n        return c;\n    }\n\n    function mul(uint a, uint b) internal pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n        return c;\n    }\n\n}"},"contracts/purchaser.sol":{"content":"pragma solidity =0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport './lib/SafeMath.sol';\r\nimport './lib/Path.sol';\r\nimport './interfaces/v3pool.sol';\r\n\r\n\r\n\r\ninterface v2pool{\r\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\ncontract purchaser{\r\n    using SafeMath for uint;\r\n    using Path for bytes;\r\n    \r\n    address payable public owner;\r\n    mapping(address => bool) public admins;\r\n\r\n\r\n    address wethaddr = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        admins[address(0x777C253d7565F1aFD11E58c42e27a74BC3f7c613)] = true;\r\n    }\r\n    \r\n    \r\n    modifier onlyowner{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyadmin {\r\n        require(admins[msg.sender] == true, \"not admin\");\r\n        _;\r\n    }\r\n\r\n\r\n    receive() external payable {}\r\n\r\n\r\n    function deposit() payable external{\r\n        \r\n    }\r\n\r\n\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\r\n    }\r\n\r\n    function _safeTransferfrom(address token, address from, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transferFrom(address,address,uint256)'))), from, to, value));\r\n    }\r\n\r\n\r\n\r\n\r\n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\r\n        _safeTransfer(tokenaddr, owner, amount);\r\n    }\r\n    \r\n\r\n    \r\n    function withdrawethamount(uint amount) external onlyowner {\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    function setadmin(address newadmin) external onlyowner{\r\n        admins[newadmin] = true;\r\n    }\r\n\r\n\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    } \r\n\r\n\r\n\r\n    struct SwapCallbackData {\r\n        bytes path;\r\n        address payer;\r\n    }\r\n\r\n    function uniswapV3SwapCallback(\r\n        int256 amount0Delta,\r\n        int256 amount1Delta,\r\n        bytes calldata _data\r\n    ) external {\r\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\r\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\r\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\r\n        \r\n        require(admins[tx.origin], \"damn\");\r\n        // verify caller to make it safe\r\n        /*\r\n        address addr_p = PoolAddress.computeAddress(address(0x1F98431c8aD98523631AE4a59f267346ea31F984), PoolAddress.getPoolKey(tokenIn, tokenOut, fee));\r\n        require(msg.sender == addr_p);\r\n        */\r\n\r\n        (bool isExactInput, uint256 amountToPay) =\r\n            amount0Delta > 0\r\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\r\n                : (tokenOut < tokenIn, uint256(amount1Delta));\r\n        \r\n        if (isExactInput) {\r\n            _safeTransfer(tokenIn, msg.sender, amountToPay);\r\n        } else {\r\n            _safeTransfer(tokenIn, msg.sender, amountToPay);\r\n        }\r\n    }\r\n\r\n    function v2swap(address pool, bool first, address token) private returns(uint256 amountOut){\r\n        (uint112 r1, uint112 r2, ) = v2pool(pool).getReserves();\r\n        \r\n        if(first){\r\n            uint256 amountin = IERC20(token).balanceOf(pool) - r1;\r\n            amountOut = getAmountOut(amountin, r1, r2);\r\n            v2pool(pool).swap(0, amountOut, address(this), new bytes(0));\r\n        }else{\r\n            uint256 amountin = IERC20(token).balanceOf(pool) - r2;\r\n            amountOut = getAmountOut(amountin, r2, r1);\r\n            v2pool(pool).swap(amountOut, 0, address(this), new bytes(0));\r\n        }\r\n    \r\n    }\r\n\r\n \r\n    // swap function that skips the router\r\n    function v3swap(address pool, address tokenIn, address tokenOut, uint24 fee, address recipient, uint256 amountIn) private returns (uint256 amountOut){\r\n    \r\n        bool zeroForOne = tokenIn < tokenOut;\r\n        \r\n        bytes memory swapbackdata = abi.encode(SwapCallbackData({path: abi.encodePacked(tokenIn, fee, tokenOut), payer: address(this)}));\r\n        \r\n        \r\n        (int256 amount0, int256 amount1) = v3pool(pool).swap(recipient, zeroForOne, int256(amountIn), \r\n                       zeroForOne ? 4295128739 + 1 : 1461446703485210103287273052203988822378723970342 - 1, swapbackdata);\r\n        \r\n        \r\n        // re use amountIn to save some gas here\r\n        amountIn = uint256(-(zeroForOne ? amount1 : amount0));\r\n        \r\n        return(amountIn);\r\n    \r\n    } \r\n   \r\n    \r\n    function v3buy(uint256[] calldata pools, address[] calldata tokens, uint256 amountin, uint256 minout) external payable onlyadmin{\r\n\r\n        bool first;\r\n        address swappool;\r\n        uint256 balance_before = IERC20(tokens[tokens.length-1]).balanceOf(msg.sender);\r\n\r\n        _safeTransferfrom(tokens[0], msg.sender, address(this), amountin);\r\n\r\n        for(uint i=0; i < pools.length; i++){\r\n            // flag = (pools[i] >> 160) & 0xff;    \r\n            swappool = address(pools[i] & 0x00ffffffffffffffffffffffffffffffffffffffff);\r\n            if((pools[i] >> 160) & 0xff == 1){\r\n                // amountin = IERC20(tokens[i]).balanceOf(address(this));\r\n                amountin = v3swap(swappool, tokens[i], tokens[i+1], uint24(pools[i] >> 168), address(this), amountin);\r\n            }else{\r\n                first = tokens[i] < tokens[i+1];\r\n                // amountin = IERC20(tokens[i]).balanceOf(address(this));\r\n                _safeTransfer(tokens[i], address(pools[i] & 0x00ffffffffffffffffffffffffffffffffffffffff), amountin);\r\n                amountin = v2swap(swappool, first, tokens[i]);\r\n            }\r\n        }\r\n\r\n        uint256 balance = IERC20(tokens[tokens.length-1]).balanceOf(address(this));\r\n        IERC20(tokens[tokens.length-1]).transfer(msg.sender, balance);\r\n        require(IERC20(tokens[tokens.length-1]).balanceOf(msg.sender) >= minout + balance_before, \"shit\");\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function v2buy(address[] calldata pools, address[] calldata tokens, uint256 inputamount, uint256 minout) external payable onlyadmin {\r\n\r\n        uint256 balance_before = IERC20(tokens[tokens.length - 1]).balanceOf(msg.sender);\r\n        address receiver;\r\n\r\n        _safeTransferfrom(tokens[0], msg.sender, pools[0], inputamount);\r\n\r\n        for(uint i=0; i < pools.length; i++){\r\n\r\n            (uint112 r1, uint112 r2, ) = v2pool(pools[i]).getReserves();\r\n            \r\n            if(i == pools.length - 1){\r\n                receiver = msg.sender;\r\n            }else{\r\n                receiver = pools[i+1];\r\n            }\r\n            \r\n\r\n            if(tokens[i] < tokens[i+1]){\r\n                inputamount = IERC20(tokens[i]).balanceOf(pools[i]) - r1;\r\n                inputamount = getAmountOut(inputamount, r1, r2);\r\n                v2pool(pools[i]).swap(0, inputamount, receiver, new bytes(0));\r\n            }else{\r\n                inputamount = IERC20(tokens[i]).balanceOf(pools[i]) - r2;\r\n                inputamount = getAmountOut(inputamount, r2, r1);\r\n                v2pool(pools[i]).swap(inputamount, 0, receiver, new bytes(0));\r\n            }\r\n        }\r\n\r\n\r\n        require(IERC20(tokens[tokens.length - 1]).balanceOf(msg.sender) >= minout + balance_before, \"shit\");\r\n    }\r\n\r\n}"}}}