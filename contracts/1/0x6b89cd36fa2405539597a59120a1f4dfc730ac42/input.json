{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/AddTokenAndValueToBehodler.sol":{"content":"// File: contracts/openzeppelin/Ownable.sol\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\n\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    \n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/Powers.sol\n\n// SPDX-L MIT\npragma solidity ^0.7.1;\n\n\n\nabstract contract AngbandLike{\n    function getAddress(bytes32 _key) public virtual view returns (address); \n    bytes32 public constant POWERREGISTRY = \"POWERREGISTRY\";\n}\n\nstruct Power {\n    bytes32 name;\n    bytes32 domain; //Thangorodrim mapping\n    bool transferrable;\n    bool unique;\n}\n\nabstract contract PowerInvoker {\n    event PowerInvoked(address user, bytes32 minion, bytes32 domain);\n\n    Power public power;\n    PowersRegistry public registry;\n    AngbandLike public angband;\n    bool invoked;\n\n    constructor(bytes32 _power, address _angband) {\n        angband = AngbandLike(_angband);\n        address _registry = angband.getAddress(angband.POWERREGISTRY());\n        registry = PowersRegistry(_registry);\n        (bytes32 name, bytes32 domain, bool transferrable, bool unique) =\n            registry.powers(_power);\n        power = Power(name, domain, transferrable, unique);\n    }\n\n    modifier revertOwnership {\n        _;\n        address ownableContract = angband.getAddress(power.domain);\n        if (ownableContract != address(angband))\n            Ownable(ownableContract).transferOwnership(address(angband));\n    }\n\n    function destruct() public {\n        require(invoked, \"MORGOTH: awaiting invocation\");\n        selfdestruct(msg.sender);\n    }\n\n    function orchestrate() internal virtual returns (bool);\n\n    function invoke(bytes32 minion, address sender) public revertOwnership {\n        require(msg.sender == address(angband), \"MORGOTH: angband only\");\n        require(\n            registry.isUserMinion(sender, minion),\n            \"MORGOTH: Invocation by minions only.\"\n        );\n        require(!invoked, \"MORGOTH: Power cannot be invoked.\");\n        require(orchestrate(), \"MORGOTH: Power invocation\");\n        invoked = true;\n        emit PowerInvoked(sender, minion, power.domain);\n    }\n}\n\ncontract Empowered is Ownable {\n    PowersRegistry internal powersRegistry;\n    bool initialized;\n\n    function changePower(address _powers)\n        public\n        requiresPowerOrInitialCondition(\n            powersRegistry.CHANGE_POWERS(),\n            address(powersRegistry) == address(0)\n        )\n    {\n        bytes32 _power = PowersRegistry(_powers).CHANGE_POWERS();\n        powersRegistry = PowersRegistry(_powers);\n        require(\n            msg.sender == address(this) ||\n                !initialized ||\n                powersRegistry.userHasPower(_power, msg.sender),\n            \"MORGOTH: forbidden power\"\n        );\n        initialized = true;\n    }\n\n    modifier requiresPower(bytes32 power) {\n        require(initialized, \"MORGOTH: powers not allocated.\");\n        require(\n            msg.sender == address(this) ||\n                powersRegistry.userHasPower(power, msg.sender),\n            \"MORGOTH: forbidden power\"\n        );\n        _;\n    }\n\n    modifier requiresPowerOnInvocation(address invoker) {\n        (bytes32 power, , , ) = PowerInvoker(invoker).power();\n        require(initialized, \"MORGOTH: powers not allocated.\");\n        require(\n            powersRegistry.userHasPower(power, msg.sender),\n            \"MORGOTH: forbidden power\"\n        );\n        _;\n    }\n\n    modifier requiresPowerOrInitialCondition(\n        bytes32 power,\n        bool initialCondition\n    ) {\n        require(initialized, \"MORGOTH: powersRegistry not allocated.\");\n        require(\n            initialCondition || powersRegistry.userHasPower(power, msg.sender),\n            \"MORGOTH: forbidden power\"\n        );\n        _;\n    }\n\n    modifier hasEitherPower(bytes32 power1, bytes32 power2) {\n        require(initialized, \".\");\n        require(\n            msg.sender == address(this) ||\n                powersRegistry.userHasPower(power1, msg.sender) ||\n                powersRegistry.userHasPower(power2, msg.sender),\n            \"MORGOTH: forbidden powers\"\n        );\n        _;\n    }\n}\n\n/*\nEvery user privilege is a power in MorgothDAO. At first these powers will be controlled by personalities. Over time they can be handed over to increasingly\ndecentralized mechanisms.\n*/\n\ncontract PowersRegistry is Empowered {\n    bytes32 public constant NULL = \"NULL\";\n    bytes32 public constant POINT_TO_BEHODLER = \"POINT_TO_BEHODLER\"; // set all behodler addresses\n    bytes32 public constant WIRE_ANGBAND = \"WIRE_ANGBAND\";\n    bytes32 public constant CHANGE_POWERS = \"CHANGE_POWERS\"; // change the power registry\n    bytes32 public constant CONFIGURE_THANGORODRIM = \"CONFIGURE_THANGORODRIM\"; // set the registry of contract addresses\n    bytes32 public constant SEIZE_POWER = \"SEIZE_POWER\"; //reclaim a delegated power.\n    bytes32 public constant CREATE_NEW_POWER = \"CREATE_NEW_POWER\";\n    bytes32 public constant BOND_USER_TO_MINION = \"BOND_USER_TO_MINION\";\n    bytes32 public constant ADD_TOKEN_TO_BEHODLER = \"ADD_TOKEN_TO_BEHODLER\";\n    bytes32 public constant CONFIGURE_SCARCITY = \"CONFIGURE_SCARCITY\";\n    bytes32 public constant VETO_BAD_OUTCOME = \"VETO_BAD_OUTCOME\";\n    bytes32 public constant DISPUTE_DECISION = \"DISPUTE_DECISION\";\n    bytes32 public constant SET_DISPUTE_TIMEOUT = \"SET_DISPUTE_TIMEOUT\";\n    bytes32 public constant INSERT_SILMARIL = \"INSERT_SILMARIL\";\n    bytes32 public constant AUTHORIZE_INVOKER = \"AUTHORIZE_INVOKER\";\n    bytes32 public constant TREASURER = \"TREASURER\";\n    bytes32 public constant ORDER66 = \"ORDER66\";\n\n    mapping(bytes32 => Power) public powers;\n\n    mapping(address => mapping(bytes32 => bool)) userIsMinion;\n    mapping(bytes32 => mapping(bytes32 => bool)) powerIsInMinion; //power,minion,bool\n    mapping(bytes32 => mapping(bytes32 => bool)) minionHasPower; // minion,power,bool\n    mapping(address => bytes32) public userMinion;\n    mapping(bytes32 => address) public minionUser;\n    bytes32[] minions;\n\n    constructor() {\n        minions.push(\"Melkor\");\n        minions.push(\"Ungoliant\");\n        minions.push(\"Sauron\");\n        minions.push(\"Saruman\");\n        minions.push(\"Glaurung\");\n        minions.push(\"Gothmog\");\n        minions.push(\"Carcharoth\");\n        minions.push(\"Witchking\");\n        minions.push(\"Smaug\");\n        minions.push(\"dragon\");\n        minions.push(\"balrog\");\n        minions.push(\"orc\");\n        userIsMinion[msg.sender][\"Melkor\"] = true;\n        powerIsInMinion[CREATE_NEW_POWER][\"Melkor\"] = true;\n        powerIsInMinion[SEIZE_POWER][\"Melkor\"] = true;\n        powerIsInMinion[BOND_USER_TO_MINION][\"Melkor\"] = true;\n\n        minionHasPower[\"Melkor\"][CREATE_NEW_POWER] = true;\n        minionHasPower[\"Melkor\"][SEIZE_POWER] = true;\n        minionHasPower[\"Melkor\"][BOND_USER_TO_MINION] = true;\n\n        userMinion[msg.sender] = \"Melkor\";\n        minionUser[\"Melkor\"] = msg.sender;\n\n        initialized = true;\n    }\n\n    function seed() public {\n        powersRegistry = PowersRegistry(address(this));\n\n        create(\"ADD_TOKEN_TO_BEHODLER\", \"LACHESIS\", true, false);\n        pour(\"ADD_TOKEN_TO_BEHODLER\", \"Melkor\");\n\n        create(\"WIRE_ANGBAND\", \"ANGBAND\", true, false);\n        pour(\"WIRE_ANGBAND\", \"Melkor\");\n\n        create(\"POINT_TO_BEHODLER\", \"LACHESIS\", true, false);\n        pour(\"POINT_TO_BEHODLER\", \"Melkor\");\n\n        create(\"INSERT_SILMARIL\", \"IRON_CROWN\", true, false);\n        pour(\"INSERT_SILMARIL\", \"Melkor\");\n\n        create(\"AUTHORIZE_INVOKER\", \"ANGBAND\", true, false);\n        pour(\"AUTHORIZE_INVOKER\", \"Melkor\");\n\n        create(\"TREASURER\", \"ANGBAND\", true, false);\n        pour(\"TREASURER\", \"Melkor\");\n    }\n\n    function userHasPower(bytes32 power, address user)\n        public\n        view\n        returns (bool)\n    {\n        bytes32 minion = userMinion[user];\n        return minionHasPower[minion][power];\n    }\n\n    function isUserMinion(address user, bytes32 minion)\n        public\n        view\n        returns (bool)\n    {\n        return userIsMinion[user][minion];\n    }\n\n    function create(\n        bytes32 power,\n        bytes32 domain,\n        bool transferrable,\n        bool unique\n    ) public requiresPower(CREATE_NEW_POWER) {\n        powers[power] = Power(power, domain, transferrable, unique);\n    }\n\n    function destroy(bytes32 power)\n        public\n        hasEitherPower(CREATE_NEW_POWER, CHANGE_POWERS)\n    {\n        powers[power] = Power(NULL, NULL, false, false);\n    }\n\n    function pour(bytes32 power, bytes32 minion_to)\n        public\n        hasEitherPower(power, SEIZE_POWER)\n    {\n        Power memory currentPower = powers[power];\n        require(currentPower.transferrable, \"MORGOTH: power not transferrable\");\n\n        bytes32 fromMinion = userMinion[msg.sender];\n        powerIsInMinion[power][fromMinion] = false;\n        minionHasPower[fromMinion][power] = false;\n\n        _spread(power, minion_to);\n    }\n\n    function spread(bytes32 power, bytes32 minion_to)\n        public\n        requiresPower(power)\n    {\n        Power memory currentPower = powers[power];\n        require(!currentPower.unique, \"MORGOTH: power not divisible.\");\n        _spread(power, minion_to);\n    }\n\n    function castIntoVoid(address user, bytes32 minion)\n        public\n        requiresPower(BOND_USER_TO_MINION)\n    {\n        userIsMinion[user][minion] = false;\n        userMinion[user] = \"\";\n    }\n\n    function bondUserToMinion(address user, bytes32 minion)\n        public\n        requiresPower(BOND_USER_TO_MINION)\n    {\n        require(\n            !userIsMinion[user][minion],\n            \"MORGOTH: minion already assigned\"\n        );\n        userIsMinion[user][minion] = true;\n        userMinion[user] = minion;\n        minionUser[minion] = user;\n    }\n\n    function _spread(bytes32 name, bytes32 minion_to) internal {\n        powerIsInMinion[name][minion_to] = true;\n        minionHasPower[minion_to][name] = true;\n    }\n}\n\n// File: contracts/behodlerPowers/LachesisFacade.sol\n\nabstract contract LachesisFacade {\n    function measure(\n        address token,\n        bool valid,\n        bool burnable\n    ) public virtual;\n\n    function updateBehodler(address token) public virtual;\n}\n\n// File: contracts/openzeppelin/IERC20.sol\n\n// SPDX-L MIT\npragma solidity ^0.7.1;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function decimals() external returns (uint8);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n// File: contracts/behodlerPowers/AddTokenAndValueToBehodlerPower.sol\n\n// SPDX-L MIT\npragma solidity ^0.7.1;\n\n\n\n\ninterface BehodlerLike {\n        function addLiquidity(address inputToken, uint256 amount)\n        external\n        payable\n        returns (uint256 deltaSCX)  ;\n}\n\ncontract AddTokenAndValueToBehodlerPower is PowerInvoker {\n    address token;\n    bool burnable;\n    address behodler;\n    address rewardContract;\n\n    constructor(\n        address _token,\n        bool _burnable,\n        address _angband,\n        address _rewardContract,\n        address _behodler\n    ) PowerInvoker(\"ADD_TOKEN_TO_BEHODLER\", _angband) {\n        token = _token;\n        burnable = _burnable;\n        behodler = _behodler;\n        rewardContract = _rewardContract;\n    }\n\n    function orchestrate() internal override returns (bool) {\n        address _lachesis = angband.getAddress(power.domain);\n        LachesisFacade lachesis = LachesisFacade(_lachesis);\n        lachesis.measure(token, true, burnable);\n        lachesis.updateBehodler(token);\n        uint balanceOfToken = IERC20(token).balanceOf(address(this));\n        require(balanceOfToken>0, \"remember to seed contract\");\n        BehodlerLike(behodler).addLiquidity(token,balanceOfToken);\n        uint scxBal = IERC20(behodler).balanceOf(address(this));\n        IERC20(behodler).transfer(rewardContract,scxBal);\n        return true;\n    }\n}\n"}}}