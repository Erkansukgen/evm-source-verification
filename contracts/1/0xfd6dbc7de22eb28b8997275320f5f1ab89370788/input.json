{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/CryptographKYCLogicV1.sol": {
      "content": "// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\nimport \"./VCProxy.sol\";\nimport \"./CryptographKYCV1.sol\";\n\n/// @title Cryptograph KYC Logic Contract\n/// @author Guillaume Gonnaud 2020\n/// @notice Provides the logic code for the KYC of bidders\n/// @dev Price feed is in ETH and NOT an oracle because it's a KYC price feed (We have to verify transaction above a certain GBP amount)\ncontract CryptographKYCLogicV1 is VCProxyData, CryptographKYCHeaderV1, CryptographKYCStoragePublicV1  {\n\n    /// @notice Generic constructor, empty\n    /// @dev This contract is meant to be used in a delegatecall and hence its memory state is irrelevant\n    constructor() public\n    {\n        //Self intialize (nothing)\n    }\n\n    modifier restrictedToOperators(){\n        require((msg.sender == perpetualAltruism || authorizedOperators[msg.sender]), \"Only operators can call this function\");\n        _;\n    }\n\n    /// @notice Init function of the KYC contract\n    /// @dev Callable only once after deployment\n    function init() external {\n        require(perpetualAltruism == address(0), \"Already initalized\");\n        perpetualAltruism = msg.sender;\n        priceLimit = uint256(0) - uint256(1);\n        emit PriceLimit(priceLimit);\n    }\n\n    /// @notice Used to allow other wallets to manage the KYC\n    /// @dev Only callable by Perpetual Altruism/Other operators\n    /// @param _operator The address of the operator\n    /// @param _operating If the operator is allowed to operate\n    function setOperator(address _operator, bool _operating) external restrictedToOperators(){\n        authorizedOperators[_operator] = _operating;\n    }\n\n\n    /// @notice Used to set a price limit above which wallets need to be KYCed\n    /// @dev Only callable by Perpetual Altruism/Other operators\n    /// @param _newPrice The new price limit\n    function setPriceLimit(uint256 _newPrice) external restrictedToOperators(){\n        priceLimit = _newPrice;\n        emit PriceLimit(_newPrice);\n    }\n\n    /// @notice Used to allow other wallets to manage the KYC\n    /// @dev Only callable by Perpetual Altruism/Other operators\n    /// @param _user The address of the user\n    /// @param _kyc Is the user allowed to bid for any amount ?\n    function setKyc(address _user, bool _kyc) external restrictedToOperators(){\n        kycUsers[_user] = _kyc;\n        emit KYCed(_user, _kyc);\n    }\n\n\n    /// @notice Check if a user is allowed to transact this amount\n    /// @dev Anyone can check\n    /// @param _user The address of the user\n    /// @param _amount The amount of the bid\n    function checkKyc(address _user, uint256 _amount) external view returns(bool){\n        return (_amount <= priceLimit || kycUsers[_user]);\n    }\n\n}"
    },
    "browser/CryptographKYCV1.sol": {
      "content": "// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\n\n/// @author Guillaume Gonnaud 2020\n/// @title Cryptograph KYC header\n/// @notice Contain all the events emitted by the Cryptograph KYC\ncontract CryptographKYCHeaderV1 {\n\n    /// @dev Event fired whenever a wallet address is added or removed from the list of KYCED wallet\n    event KYCed(address indexed _user, bool indexed _isValid);\n\n    /// @dev Event fired whenever a new price (in wei) is set for the KYC limit\n    event PriceLimit(uint256 indexed _newPrice);\n}\n\n\n\n/// @author Guillaume Gonnaud 2020\n/// @title Cryptograph KYC  Storage Internal\n/// @notice Contain all the storage of the Cryptograph KYC  declared in a way that don't generate getters for Proxy use\ncontract CryptographKYCStorageInternalV1 {\n\n    //Perpetual Altruism, the creator of this smart contract\n    address internal perpetualAltruism;\n\n    //The list of wallets that can publish a new price limit  & add/remove wallets from the kyc\n    mapping(address => bool) internal authorizedOperators;\n\n    //The price in wei above which a transaction need a KYC. set to 0 to refuse all transactions, to UINT256MAX to allow all.\n    uint256 internal priceLimit;\n\n    //The mapping of KYCED users\n    mapping(address => bool) internal kycUsers;\n\n}\n\n/// @author Guillaume Gonnaud 2020\n/// @title Cryptograph KYC  Storage Internal\n/// @notice Contain all the storage of the Cryptograph KYC  declared in a way that don't generate getters for Proxy use\ncontract CryptographKYCStoragePublicV1 {\n\n    //Perpetual Altruism, the creator of this smart contract\n    address public perpetualAltruism;\n\n    //The list of wallets that can publish a new price limit  & add/remove wallets from the kyc\n    mapping(address => bool) public authorizedOperators;\n\n    //The price in wei above which a transaction need a KYC. set to 0 to refuse all transactions, to UINT256MAX to allow all.\n    uint256 public priceLimit;\n\n    //The mapping of KYCED users\n    mapping(address => bool) public kycUsers;\n}"
    },
    "browser/VCProxy.sol": {
      "content": "// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\n/* Based on a variation of https://blog.gnosis.pm/solidity-delegateproxy-contracts-e09957d0f201\nThis generic proxy is gonna ask a version control smart contract for its logic code instead\nof storing the remote address himself\n*/\n\n/*\nSmart contract only containing a public array named the same as VC so that the compiler call the proper\nfunction signature in our generic proxy\n*/\ncontract VersionControlStoragePublic {\n    address[] public code;\n}\n\n\n/*\nStorage stack of a proxy contract. VCproxy inherit this, as well as ALL logic contracts associated to a proxy for storage alignment reasons.\n*/\ncontract VCProxyData {\n    address internal vc; //Version Control Smart Contract Address\n    uint256 internal version; //The index of our logic code in the Version Control array.\n}\n\n\n/*\nLogic of a proxy contract. EVERY proxied contract inherit this\n*/\ncontract VCProxy is VCProxyData {\n    constructor(uint256 _version, address _vc) public {\n        version = _version;\n        vc = _vc;\n    }\n\n    fallback () virtual external payable {\n\n        address addr = VersionControlStoragePublic(vc).code(version);\n        assembly {\n            let freememstart := mload(0x40)\n            calldatacopy(freememstart, 0, calldatasize())\n            let success := delegatecall(not(0), addr, freememstart, calldatasize(), freememstart, 0)\n            returndatacopy(freememstart, 0, returndatasize())\n            switch success\n            case 0 { revert(freememstart, returndatasize()) }\n            default { return(freememstart, returndatasize()) }\n        }\n    }\n\n    \n    /// @notice Generic catch-all function that refuse payments to prevent accidental Eth burn.\n    receive() virtual external payable{\n       require(false, \"Do not send me Eth without a reason\");\n    }\n}"
    }
  }
}