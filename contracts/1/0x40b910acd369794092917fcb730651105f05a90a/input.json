{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"foo.sol":{"content":"// Sources flattened with hardhat v2.4.1 https://hardhat.org\n\n// File contracts/Interfaces/ERC20.sol\n\npragma solidity ^0.8.0;\n\ninterface ERC20 {\n    function approve(address, uint256) external returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n\n    function transfer(address, uint256) external returns (bool);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function allowance(address, address) external view returns (uint256);\n}\n\n\n// File contracts/Interfaces/GnosisSafe.sol\n\n\npragma solidity ^0.8.4;\n\ninterface GnosisSafe {\n    enum Operation {\n        Call,\n        DelegateCall\n    }\n\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Operation operation\n    ) external returns (bool);\n\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Operation operation\n    ) external returns (bool, bytes memory);\n\n    function isOwner(address owner) external view returns (bool);\n}\n\n\n// File contracts/Modules/Strategies/AbstractStrategy.sol\n\n\npragma solidity ^0.8.4;\n\n\nabstract contract AbstractStrategy {\n    struct Harvest {\n        ERC20 token;\n        uint256 amount;\n    }\n\n    /// The harvesters for the safe.\n    mapping(address => mapping(address => bool)) harvesters;\n\n    event Harvested(GnosisSafe indexed safe, address indexed token, uint256 amount);\n    event Deposited(GnosisSafe indexed safe, uint256 amount);\n    event Withdrew(GnosisSafe indexed safe, uint256 amount);\n\n    modifier onlyOwner(GnosisSafe safe) {\n        require(safe.isOwner(msg.sender), \"not owner\");\n        _;\n    }\n\n    modifier onlyHarvesters(GnosisSafe safe) {\n        require(harvesters[address(safe)][msg.sender] || safe.isOwner(msg.sender), \"not harvester\");\n        _;\n    }\n\n    function addHarvester(address harvester) external {\n        harvesters[msg.sender][harvester] = true;\n    }\n\n    function removeHarvester(address harvester) external {\n        harvesters[msg.sender][harvester] = false;\n    }\n\n    function harvest(GnosisSafe safe) external virtual;\n\n    function withdraw(GnosisSafe safe, uint256 amount) external virtual;\n\n    function deposit(GnosisSafe safe, uint256 amount) external virtual;\n\n    function depositToken() external view virtual returns (ERC20);\n\n    function depositedAmount(GnosisSafe safe) external view virtual returns (uint256);\n\n    function harvestableAmount(GnosisSafe safe) external view virtual returns (Harvest[] memory);\n\n    function NAME() external view virtual returns (string memory);\n}\n\n\n// File contracts/Interfaces/TokenKit/StakingRewards.sol\n\n\npragma solidity ^0.8.4;\n\ninterface StakingRewards {\n    function stake(uint256) external;\n\n    function withdraw(uint256) external;\n\n    function getReward() external;\n\n    function earned(address) external view returns (uint256);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function rewardsToken() external view returns (ERC20);\n\n    function stakingToken() external view returns (ERC20);\n}\n\n\n// File contracts/Interfaces/Uniswap.sol\n\n\npragma solidity ^0.8.4;\n\ninterface Uniswap {\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    function getAmountsOut(uint256 amountIn, address[] memory path) external view returns (uint256[] memory);\n\n    function getAmountsIn(uint256 amountOut, address[] memory path) external view returns (uint256[] memory);\n}\n\n\n// File contracts/Libraries/SafeHelper.sol\n\n\npragma solidity ^0.8.4;\n\n\n\nlibrary SafeHelper {\n    function approve(\n        GnosisSafe safe,\n        ERC20 token,\n        address spender,\n        uint256 amount\n    ) internal {\n        call(safe, address(token), abi.encodeWithSelector(token.approve.selector, spender, amount), \"failed to approve\");\n    }\n\n    function execute(\n        GnosisSafe safe,\n        address to,\n        bytes memory data\n    ) internal {\n        call(safe, to, data, \"could not execute\");\n    }\n\n    function call(\n        GnosisSafe safe,\n        address to,\n        bytes memory data,\n        string memory reason\n    ) internal {\n        require(safe.execTransactionFromModule(to, 0, data, GnosisSafe.Operation.Call), reason);\n    }\n\n    function swapExactTokensForTokens(\n        GnosisSafe safe,\n        Uniswap exchange,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) internal returns (uint256[] memory) {\n        (bool success, bytes memory data) = safe.execTransactionFromModuleReturnData(\n            address(exchange),\n            0,\n            abi.encodeWithSelector(exchange.swapExactTokensForTokens.selector, amountIn, amountOutMin, path, to, deadline),\n            GnosisSafe.Operation.Call\n        );\n        require(success);\n\n        return abi.decode(data, (uint256[]));\n    }\n}\n\n\n// File contracts/Libraries/ExchangeHelper.sol\n\n\npragma solidity ^0.8.4;\n\n\n\nlibrary ExchangeHelper {\n    Uniswap public constant uni = Uniswap(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    Uniswap public constant sushi = Uniswap(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\n\n    event Traded(GnosisSafe indexed safe, address from, address to, uint256 amountFrom, uint256 amountTo);\n\n    function amountOutFor(\n        Uniswap exchange,\n        address[] memory path,\n        uint256 amountIn\n    ) internal returns (uint256) {\n        uint256[] memory amountsOut = exchange.getAmountsOut(amountIn, path);\n        return amountsOut[amountsOut.length - 1];\n    }\n\n    function dataForBestExchange(\n        Uniswap a,\n        Uniswap b,\n        address[] memory path,\n        uint256 amount\n    ) internal returns (Uniswap, uint256) {\n        uint256 aAmount = amountOutFor(a, path, amount);\n        uint256 bAmount = amountOutFor(b, path, amount);\n\n        if (aAmount > bAmount) {\n            return (a, aAmount);\n        } else {\n            return (b, bAmount);\n        }\n    }\n\n    // @TODO THIS FEELS A BIT MESSY\n\n    function sellForBestPriceWithSlippage(\n        GnosisSafe safe,\n        address[] memory path,\n        uint256 sellAmount,\n        uint256 slippage\n    ) internal returns (uint256) {\n        // Check for best price\n        (Uniswap exchange, uint256 amount) = dataForBestExchange(uni, sushi, path, sellAmount);\n\n        // Return if we won't be able to sell any\n        if (amount == 0) {\n            return 0;\n        }\n\n        // Approve Token on best exchange\n        SafeHelper.approve(safe, ERC20(path[0]), address(exchange), sellAmount);\n\n        // Trade\n        uint256[] memory balances = SafeHelper.swapExactTokensForTokens(\n            safe,\n            exchange,\n            sellAmount,\n            (amount * (1000 - slippage)) / 1000,\n            path,\n            address(safe),\n            block.timestamp + 180\n        );\n\n        emit Traded(safe, path[0], path[2], sellAmount, balances[2]);\n\n        return balances[2];\n    }\n}\n\n\n// File contracts/Modules/Strategies/InverseFinanceStrategy.sol\n\n\npragma solidity ^0.8.4;\n\n\n\n\n\ncontract InverseFinanceStrategy is AbstractStrategy {\n    using ExchangeHelper for Uniswap;\n    using SafeHelper for GnosisSafe;\n\n    string public constant VERSION = \"2.0.0\";\n\n    ERC20 public constant USDC = ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    ERC20 public constant WETH = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    Uniswap public constant SUSHI = Uniswap(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\n\n    StakingRewards public immutable rewards;\n\n    ERC20 public immutable rewardsToken;\n    ERC20 public immutable stakingToken;\n\n    address[] public path;\n\n    constructor(StakingRewards _rewards) {\n        rewards = _rewards;\n\n        rewardsToken = _rewards.rewardsToken();\n        stakingToken = _rewards.stakingToken();\n\n        path = [address(_rewards.rewardsToken()), address(WETH), address(USDC)];\n    }\n\n    function harvest(GnosisSafe safe) external override onlyHarvesters(safe) {\n        uint256 amountBefore = rewardsToken.balanceOf(address(safe));\n\n        // Redeem\n        safe.call(address(rewards), abi.encodeWithSelector(rewards.getReward.selector), \"failed to withdraw\");\n\n        uint256 amountAfter = rewardsToken.balanceOf(address(safe));\n        uint256 balance = amountAfter - amountBefore;\n\n        require(balance > 0, \"balance was 0\");\n\n        // Approve Token on best exchange\n        SafeHelper.approve(safe, ERC20(path[0]), address(SUSHI), balance);\n\n        uint256 amount = ExchangeHelper.amountOutFor(SUSHI, path, balance);\n        if (amount == 0) {\n            return;\n        }\n\n        // Trade\n        uint256[] memory amountsOut = SafeHelper.swapExactTokensForTokens(\n            safe,\n            SUSHI,\n            balance,\n            (amount * (1000 - 20)) / 1000,\n            path,\n            address(safe),\n            block.timestamp + 180\n        );\n\n        emit Harvested(safe, path[path.length - 1], amountsOut[amountsOut.length - 1]);\n    }\n\n    function withdraw(GnosisSafe safe, uint256 amount) public override onlyOwner(safe) {\n        safe.call(address(rewards), abi.encodeWithSelector(rewards.withdraw.selector, amount), \"could not withdraw\");\n\n        emit Withdrew(safe, amount);\n    }\n\n    function harvestableAmount(GnosisSafe safe) external view override returns (Harvest[] memory) {\n        Harvest[] memory harvests = new Harvest[](1);\n        harvests[0] = Harvest({token: rewardsToken, amount: rewards.earned(address(safe))});\n        return harvests;\n    }\n\n    function deposit(GnosisSafe safe, uint256 amount) external override onlyOwner(safe) {\n        // Approve Staking Token\n        safe.approve(stakingToken, address(rewards), amount);\n\n        // Deposit\n        safe.call(address(rewards), abi.encodeWithSelector(rewards.stake.selector, amount), \"could not deposit\");\n\n        emit Deposited(safe, amount);\n    }\n\n    function depositToken() external view override returns (ERC20) {\n        return stakingToken;\n    }\n\n    function depositedAmount(GnosisSafe safe) external view override returns (uint256) {\n        return rewards.balanceOf(address(safe));\n    }\n\n    function NAME() external view override returns (string memory) {\n        return string(abi.encodePacked(\"Inverse Finance \", stakingToken.name(), \" Strategy Module\"));\n    }\n}\n"}}}