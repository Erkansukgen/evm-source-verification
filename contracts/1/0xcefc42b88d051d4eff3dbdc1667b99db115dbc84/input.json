{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/ProtocolTokenMinter.sol":{"content":"pragma solidity 0.6.7;\n\ncontract GebMath {\n    uint256 public constant RAY = 10 ** 27;\n    uint256 public constant WAD = 10 ** 18;\n\n    function ray(uint x) public pure returns (uint z) {\n        z = multiply(x, 10 ** 9);\n    }\n    function rad(uint x) public pure returns (uint z) {\n        z = multiply(x, 10 ** 27);\n    }\n    function minimum(uint x, uint y) public pure returns (uint z) {\n        z = (x <= y) ? x : y;\n    }\n    function addition(uint x, uint y) public pure returns (uint z) {\n        z = x + y;\n        require(z >= x, \"uint-uint-add-overflow\");\n    }\n    function subtract(uint x, uint y) public pure returns (uint z) {\n        z = x - y;\n        require(z <= x, \"uint-uint-sub-underflow\");\n    }\n    function multiply(uint x, uint y) public pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"uint-uint-mul-overflow\");\n    }\n    function rmultiply(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, y) / RAY;\n    }\n    function rdivide(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, RAY) / y;\n    }\n    function wdivide(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, WAD) / y;\n    }\n    function wmultiply(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, y) / WAD;\n    }\n    function rpower(uint x, uint n, uint base) public pure returns (uint z) {\n        assembly {\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\n            default {\n                switch mod(n, 2) case 0 { z := base } default { z := x }\n                let half := div(base, 2)  // for rounding.\n                for { n := div(n, 2) } n { n := div(n,2) } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) { revert(0,0) }\n                    x := div(xxRound, base)\n                    if mod(n,2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) { revert(0,0) }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n}\n\nabstract contract DSTokenLike {\n    function totalSupply() virtual public view returns (uint256);\n    function mint(address, uint256) virtual public;\n    function transfer(address, uint256) virtual public;\n}\n\ncontract ProtocolTokenMinter is GebMath {\n    // --- Auth ---\n    mapping (address => uint256) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"ProtocolTokenMinter/account-not-authorized\");\n        _;\n    }\n\n    // --- Variables ---\n    // Current amount to mint per week\n    uint256 public amountToMintPerWeek;                                   // wad\n    // Last timestamp when the contract accrued inflation\n    uint256 public lastWeeklyMint;                                        // timestamp\n    // Last week number when the contract accrued inflation\n    uint256 public lastTaggedWeek;\n    // Decay for the weekly amount to mint\n    uint256 public weeklyMintDecay;                                       // wad\n    // Timestamp when minting starts\n    uint256 public mintStartTime;\n    // Whether minting is currently allowed\n    uint256 public mintAllowed = 1;\n\n    uint256 public constant WEEK                     = 1 weeks;\n    uint256 public constant WEEKS_IN_YEAR            = 52;\n    uint256 public constant INITIAL_INFLATION_PERIOD = WEEKS_IN_YEAR * 3; // 3 years\n    uint256 public constant TERMINAL_INFLATION       = 1.02E18;           // 2% compounded weekly\n\n    // Address that receives minted tokens\n    address     public mintReceiver;\n\n    // The token being minted\n    DSTokenLike public protocolToken;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event Mint(uint256 weeklyAmount);\n    event ModifyParameters(bytes32 parameter, address data);\n    event ModifyParameters(bytes32 parameter, uint256 data);\n\n    constructor(\n      address mintReceiver_,\n      address protocolToken_,\n      uint256 mintStartTime_,\n      uint256 amountToMintPerWeek_,\n      uint256 weeklyMintDecay_\n    ) public {\n      require(mintReceiver_ != address(0), \"ProtocolTokenMinter/null-mint-receiver\");\n      require(protocolToken_ != address(0), \"ProtocolTokenMinter/null-prot-token\");\n\n      require(mintStartTime_ > now, \"ProtocolTokenMinter/invalid-start-time\");\n      require(amountToMintPerWeek_ > 0, \"ProtocolTokenMinter/null-amount-to-mint\");\n      require(weeklyMintDecay_ < WAD, \"ProtocolTokenMinter/invalid-mint-decay\");\n\n      authorizedAccounts[msg.sender] = 1;\n\n      mintReceiver        = mintReceiver_;\n      protocolToken       = DSTokenLike(protocolToken_);\n      mintStartTime       = mintStartTime_;\n      amountToMintPerWeek = amountToMintPerWeek_;\n      weeklyMintDecay     = weeklyMintDecay_;\n\n      emit AddAuthorization(msg.sender);\n    }\n\n    // --- Administration ---\n    /*\n    * @notify Change the mintReceiver\n    * @param parameter The parameter name\n    * @param data The new address for the receiver\n    */\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        if (parameter == \"mintReceiver\") {\n          mintReceiver = data;\n        }\n        else revert(\"ProtocolTokenMinter/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n    /*\n    * @notify Change mintAllowed\n    * @param parameter The parameter name\n    * @param data The new value for mintAllowed\n    */\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n        if (parameter == \"mintAllowed\") {\n          mintAllowed = data;\n        }\n        else revert(\"ProtocolTokenMinter/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n\n    // --- Core Logic ---\n    /*\n    * @notice Mint tokens for this contract\n    */\n    function mint() external {\n      require(now > mintStartTime, \"ProtocolTokenMinter/too-early\");\n      require(mintAllowed == 1, \"ProtocolTokenMinter/mint-not-allowed\");\n      require(addition(lastWeeklyMint, WEEK) <= now, \"ProtocolTokenMinter/week-not-elapsed\");\n\n      uint256 weeklyAmount;\n      lastWeeklyMint = (lastWeeklyMint == 0) ? now : addition(lastWeeklyMint, WEEK);\n\n      if (lastTaggedWeek < INITIAL_INFLATION_PERIOD) {\n        weeklyAmount        = amountToMintPerWeek;\n        amountToMintPerWeek = multiply(amountToMintPerWeek, weeklyMintDecay) / WAD;\n      } else {\n        weeklyAmount = wdivide(protocolToken.totalSupply(), TERMINAL_INFLATION) / WEEKS_IN_YEAR;\n      }\n\n      lastTaggedWeek = addition(lastTaggedWeek, 1);\n\n      protocolToken.mint(address(this), weeklyAmount);\n\n      emit Mint(weeklyAmount);\n    }\n\n    /*\n    * @notice Transfer minted tokens\n    * @param amount The amount to transfer\n    */\n    function transferMintedAmount(uint256 amount) external isAuthorized {\n      protocolToken.transfer(mintReceiver, amount);\n    }\n}"}}}