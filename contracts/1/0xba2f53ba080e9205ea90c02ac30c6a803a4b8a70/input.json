{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "halBotProxy.sol": {
      "content": "// SPDX-License-Identifier: none\r\n\r\npragma solidity ^0.8.1;\r\n\r\ninterface IRouter {\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts); \r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IFactory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\nabstract contract AccessControl {\r\n    address private owner;\r\n    mapping (address => bool) private whitelist;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        whitelist[msg.sender] = true;\r\n    }\r\n\r\n    modifier onlyOwner(){\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyWhitelist(){\r\n        require(whitelist[msg.sender] || msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function addNewUser(address user) external onlyOwner {\r\n        whitelist[user] = true;  \r\n    }\r\n    \r\n    function removeUser(address user) external onlyOwner {\r\n        require(user != msg.sender);\r\n        whitelist[user] = false;\r\n    }\r\n}\r\n\r\ncontract BotProxy is AccessControl {\r\n    mapping(uint => bool) txids;\r\n\r\n    constructor(){}\r\n\r\n    fallback() external {}\r\n    \r\n    /**\r\n     * Withdraws any tokens that may have gotten stuck\r\n     */\r\n    function withdrawTokens(\r\n        address tokenAddress,\r\n        uint tokenAmount\r\n    ) external onlyOwner() {\r\n        IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * Withdraws any eth/bnb/etc that may have gotten stuck\r\n     */\r\n    function withdrawCurrency() external onlyOwner() {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n     * Given a router addres, sells all given tokens (first token in path)\r\n     * for as many tokens as possible (second token in path)\r\n     *\r\n     * Sends output tokens to _to, pulls input tokens from _from\r\n     */\r\n    function sellAllTokens(\r\n        address _routerAddress,\r\n        address _inputTokenAddress,\r\n        address _outputTokenAddress,\r\n        address _fromAddress,\r\n        address _toAddress,\r\n        uint _deadline\r\n    ) external onlyWhitelist() {\r\n        // Sanity checks\r\n        require(_routerAddress != address(0) && _fromAddress != address(0) && _toAddress != address(0), \"Router, from, and to cannot be the zero address!\");\r\n        require(_inputTokenAddress != address(0) && _outputTokenAddress != address(0), \"Tokens cannot be the zero address!\");\r\n\r\n        // Calculate token balance & transfer in\r\n        uint tokenBalance = IERC20(_inputTokenAddress).balanceOf(_fromAddress);\r\n        require(IERC20(_inputTokenAddress).transferFrom(_fromAddress, address(this), tokenBalance), 'Transfer from failed!'); \r\n\r\n        // Swap all tokens - approve first!\r\n        IERC20(_inputTokenAddress).approve(_routerAddress, tokenBalance);\r\n        address[] memory sellPath = new address[](2);\r\n        sellPath[0] = _inputTokenAddress;\r\n        sellPath[1] = _outputTokenAddress;\r\n\r\n        IRouter(_routerAddress).swapExactTokensForTokens(\r\n            tokenBalance,\r\n            1,\r\n            sellPath,\r\n            _toAddress,\r\n            _deadline\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Given a router address, performs a swapExactTokensForTokens swap after\r\n     * performing a transferFrom(from, amountIn) on the first token in the\r\n     * provided path\r\n     *\r\n     * @param _routerAddress address of the router we want to swap with\r\n     * @param _factoryAddress address of the factory; only needed if _minimumInputTokenLiquidity is used\r\n     * @param _fromAddress address to _transferFrom the input tokens\r\n     * @param _toAddress address to send output tokens + input dust to\r\n     * @param _inputTokenAddress first address of path\r\n     * @param _outputTokenAddress second address/output of path\r\n     * @param _amountIn see swapExactTokensForTokens\r\n     * @param _amountOutMin see swapExactTokensForTokens\r\n     * @param _deadline see swapExactTokensForTokens\r\n     * @param _buySellCheckPercentage if nonzero, the percentage of our input amount to sell to test for scammy contracts\r\n     * @param _minimumInputTokenLiquidity if nonzero, the amount of input tokens the pair must have to not abort this swap\r\n     * @param _uniqueTransactionId if nonzero, enforces a unique transaction via custom txid\r\n     */\r\n    function swapExactTokensForTokens(\r\n        address _routerAddress,\r\n        address _factoryAddress,\r\n        address _fromAddress,\r\n        address _toAddress,\r\n        address _inputTokenAddress,\r\n        address _outputTokenAddress,\r\n        uint _amountIn, \r\n        uint _amountOutMin, \r\n        uint _deadline,\r\n        uint _buySellCheckPercentage,\r\n        uint _minimumInputTokenLiquidity,\r\n        uint _uniqueTransactionId\r\n    ) external onlyWhitelist() {\r\n        // Sanity checks\r\n        require(_routerAddress != address(0) && _fromAddress != address(0) && _toAddress != address(0), \"Router, from, and to cannot be the zero address!\");\r\n        require(_inputTokenAddress != address(0) && _outputTokenAddress != address(0), \"Tokens cannot be the zero address!\");\r\n        \r\n        // Unique tx id check\r\n        if (_uniqueTransactionId != 0) require(!txids[_uniqueTransactionId], \"This transaciton has already occurred.\");\r\n        \r\n        // Transfer in & approve the input token to the router\r\n        IERC20(_inputTokenAddress).transferFrom(_fromAddress, address(this), _amountIn);\r\n        IERC20(_inputTokenAddress).approve(_routerAddress, _amountIn);\r\n        \r\n        // Check for token minimum liquidity\r\n        if (_minimumInputTokenLiquidity != 0) {\r\n            IFactory factory = IFactory(_factoryAddress);\r\n            address pairAddress = factory.getPair(_inputTokenAddress, _outputTokenAddress);\r\n            require(pairAddress != address(0), \"Pair zero\");\r\n\r\n            uint pairInputTokenBalance = IERC20(_inputTokenAddress).balanceOf(pairAddress);\r\n            require(pairInputTokenBalance >= _minimumInputTokenLiquidity, \"Not enough liquidity.\");\r\n        }\r\n        \r\n        // Contruct the sell params\r\n        address[] memory buyPath = new address[](2);\r\n        buyPath[0] = _inputTokenAddress;\r\n        buyPath[1] = _outputTokenAddress;  \r\n\r\n        if (_buySellCheckPercentage == 0) {\r\n            // Perform buy - no buy/sell check\r\n            IRouter(_routerAddress).swapExactTokensForTokens(\r\n                _amountIn, \r\n                _amountOutMin, \r\n                buyPath, \r\n                _toAddress, \r\n                _deadline\r\n            );\r\n        } else {\r\n            // Perform buy, but send tokens here so that we can sell a tiny amount\r\n            // to ensure that sells work. Note that the contract can't trick us\r\n            // by transferring a smaller amount than what is expected; this is enforced\r\n            // by the router itself.\r\n            uint[] memory amounts = IRouter(_routerAddress).swapExactTokensForTokens(\r\n                _amountIn, \r\n                _amountOutMin, \r\n                buyPath, \r\n                address(this), \r\n                _deadline\r\n            );\r\n\r\n            require(IERC20(_outputTokenAddress).approve(address(_routerAddress), amounts[1]), 'Approval of output token failed');\r\n\r\n            // Contruct the sell params\r\n            address[] memory sellPath = new address[](2);\r\n            sellPath[0] = _outputTokenAddress;\r\n            sellPath[1] = _inputTokenAddress;   \r\n\r\n            // The token amount we wish to sell is a percentage represented by a number out of 1000.  \r\n            uint outputTokenAmountToSell = (amounts[1] * _buySellCheckPercentage) / 1000;\r\n\r\n            // Perform the sell. This will automatically revert if most shenaniganry happens.\r\n            IRouter(_routerAddress).swapExactTokensForTokens(\r\n                outputTokenAmountToSell, \r\n                1, \r\n                sellPath, \r\n                address(this), \r\n                _deadline\r\n            );\r\n\r\n            // Finally, transfer all input & output tokens to _toAddress\r\n            if (IERC20(_inputTokenAddress).balanceOf(address(this)) != 0) IERC20(_inputTokenAddress).transfer(_toAddress, IERC20(_inputTokenAddress).balanceOf(address(this)));\r\n            if (IERC20(_outputTokenAddress).balanceOf(address(this)) != 0) IERC20(_outputTokenAddress).transfer(_toAddress, IERC20(_outputTokenAddress).balanceOf(address(this)));\r\n        }\r\n\r\n        // Finally, if we're here, tx has succeeded - mark this tx as done\r\n        // if the uniqueTransactionId check is not zero/false!\r\n        if (_uniqueTransactionId != 0) txids[_uniqueTransactionId] = true;      \r\n    }\r\n}"
    }
  }
}