{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":20000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/BetHorde.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.7;\n\n/** @title BetHorde: decentralised bets.\n  * @author u/bethorde\n  * @notice Truly decentralised bets. No trust. No oracles. Provably random.\n  *\n  *  Anyone can be a player or a house. Randomness through RSA signatures.\n  *\n  *  Takes:\n  *    If player loses, they lose amount that they bet.\n  *    If player wins, they receive:\n  *      odds * bet price * (1 - (house take + contract take)).\n  *    House take: 0% <= house take <= 10% (0.01% increments, set by house).\n  *    Contract take (where pot = odds * bet price):\n  *      Pot < 0.1 ETH:         1.0% take\n  *      0.1 ETH < Pot < 1 ETH: 0.5% take\n  *      1 ETH < Pot < 5 ETH:   0.2% take\n  *      Pot > 5 ETH:           0.1% take\n  *\n  *  Play:\n  *    Players call 'CreatePlayer' to create an account and play with 'PlaceBet'.\n  *      Funds can be added during calls to 'PlaceBet'.\n  *      Withdrawals can be made using 'PlayerWithdraw'.\n  *      If house takes over 24 hours to decide a bet, 'ForceBet' can be called.\n  *    Houses call 'OpenOrAdjustHouse' to set up a house.\n  *      Set min_bet and max_loss parameters to limit incoming bets.\n  *      Call 'DecideBet' on incoming bets within 24 hours (or a house loss can be forced).\n  *      Call 'FundHouse' to add funds to a house,\n  *      Call 'TogglePauseHouse' to pause/unpause a house. While a house is\n  *      paused, and if all bets have been decided, house can call\n  *      'HouseWithdraw' and 'OpenOrAdjustHouse'. No new bets can be placed while a house is paused.\n  *    Anyone can call `ForceBet` if a house has not decided a bet within 24 hours.\n  *      Results in player winning.\n  *      House take goes to house address that called `ForceBet`.\n  *      Funds can only be withdrawn if house exists.\n  *      House can be set up after funds arrive without losing funds.\n  * \n  *  Randomness:\n  *    House provides public part of an RSA key in advance.\n  *    Player provides randomness when placing a bet.\n  *    Randomness is combined with a nonce and hashed.\n  *    House signs hash in bet with house private key.\n  *    Unless player knows the key, there is no way to cheat.\n  *\n  *  This scheme works on four facts/assumptions:\n  *    1. House uses a secure 2048 bit RSA key.\n  *    2. House cannot control random input from player.\n  *    3. Player cannot predict how private key will sign random value.\n  *    4. An RSA key can only sign a given message in one way.\n  *\n  *  A few ways to cheat are dealt with:\n  *    1. Players can replay winning 'random' values to keep winning.\n  *      - Randomness combined with other data, including a nonce, and hashed.\n  *    2. Changing house parameters or withdrawing funds to avoid incoming bets.\n  *      - Houses must be paused and have no unresolved bets to take these actions.\n  *      - Pauses start 250 blocks after being requested.\n  *      - 'PlaceBet' function has a bet_placed_timestamp parameter, preventing\n  *        bets from being placed after house parameters have changed.\n  *    3. House bets against itself to run out of funds for upcoming losing bets.\n  *      - Last_low_balance_timestamp marks recent low funds.\n  *    4. Private keys could be insecure/leaked.\n  *      - House can change keys and is incentivised not to pick insecure keys.\n  *      - 2048 bit RSA keys.\n  * \n  *  Signing:\n  *    (EMSA-PKCS1-v1_5 in RFC 3447)\n  *    1. Generate 2048 bit RSA key.\n  *      - d: private exponent.\n  *      - n: modulus (public, 2048 bits).\n  *      - e: public exponent (must be 17).\n  *    2. When creating (or adjusting) a house, supply n as bytes32[8].\n  *    3. When signing a bet, pad the 32 byte bet.randomness value:\n  *      [0x0001ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,\n  *       0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,\n  *       0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,\n  *       0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,\n  *       0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,\n  *       0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,\n  *       0x0001fffffffffffffffffff0013031300d060960864801650304020105000420,\n  *       <32 byte bet.randomness>]\n  *    5. Sign array (treat it as a large hexadecimal integer):\n  *      - (padded ^ d) % n.\n  *    6. Supply signed value as bytes32[8] to 'DecideBet'.\n  */\n\ncontract BetHorde {\n\n  /* --- PLAYER ACTIONS --- */\n  /** @notice Create a new player for msg.sender (required before placing bets). */\n  function CreatePlayer() external {\n    require(players[msg.sender].creation_block == 0, \"Player exists\");\n    players[msg.sender].nonce = 1;\n    players[msg.sender].creation_block = block.number;\n  }\n\n  /** @notice Place bet. Adds msg.value to player account before deducting bet.\n    * @param house House to bet against.\n    * @param odds Bet odds: 1 / odds chance of winning odds * amount_gwei.\n    *  Winnings are subject to house and contract takes. 2 <= odds <= 1 million.\n    * @param amount_gwei GWEI to bet.\n    * @param randomness Random 32 byte value.\n    * @param nonce A value larger than current nonce, but not by more than 10.\n    * @param bet_placed_timestamp When player created the bet (protects against\n    *  house changing parameters after bet is sent).\n    */\n  function PlaceBet(address house, uint256 odds, uint256 amount_gwei,\n                    bytes32 randomness, uint256 nonce,\n                    uint256 bet_placed_timestamp) payable external {\n    uint256 amount = amount_gwei * 1 gwei;\n    require(state.bet_counter < type(uint32).max);\n    require(houses[house].pause_block > block.number,\n            \"House unavailable\");\n    require(players[msg.sender].creation_block > 0,\n            \"Create player\");\n    require(odds > 1 && odds <= 1e6, \"Invalid odds\");\n    // House updated after bet was placed.\n    require(bet_placed_timestamp > houses[house].last_update_timestamp,\n            \"House updated\");\n    require(amount <= players[msg.sender].balance + msg.value,\n            \"Insufficient funds\");\n    players[msg.sender].balance = players[msg.sender].balance + msg.value - amount;\n    require(nonce > players[msg.sender].nonce\n            && nonce <= players[msg.sender].nonce + 10,\n            \"Nonce\");\n    require(amount >= houses[house].min_bet, \"Bet too low\");\n    require(amount * odds <= houses[house].max_loss, \"Exceeds max loss\");\n    // Subtract 1 from odds (player pays for bet).\n    require(amount * (odds - 1) <= houses[house].balance, \"Exceeds house balance\");\n    state.bet_counter++;\n    bets[state.bet_counter] = Bet({\n      house: house,\n      price_gwei: uint56(amount_gwei),\n      timestamp: uint32(block.timestamp),\n      player: msg.sender,\n      previous_house_bet: houses[house].last_bet,\n      next_house_bet: 0,\n      odds: uint32(odds),\n      randomness: keccak256(abi.encode(players[msg.sender].creation_block, nonce,\n                            msg.sender, randomness))\n    });\n    if(houses[house].first_bet == 0) {\n      houses[house].first_bet = state.bet_counter;\n    } else {\n      bets[houses[house].last_bet].next_house_bet = state.bet_counter;\n    }\n    houses[house].last_bet = state.bet_counter;\n    houses[house].bet_balance += amount * odds;\n    houses[house].balance -= (amount * odds) - amount;\n    houses[house].active_bets++;\n    if(houses[house].balance < houses[house].max_loss) {\n      houses[house].last_low_balance_timestamp = block.timestamp;\n    }\n    \n    state.reserved_eth += msg.value;\n    state.last_bet_time = block.timestamp;\n    players[msg.sender].active_bets++;\n    players[msg.sender].nonce = nonce;\n\n    emit BetPlaced(house, state.bet_counter);\n  }\n  \n  /** @notice Withdraw funds from player account.\n    * @param amount How much to withdraw (WEI)\n    */\n  function PlayerWithdraw(uint256 amount) external {\n    require(players[msg.sender].balance >= amount, \"Insufficient funds\");\n    state.reserved_eth -= amount;\n    players[msg.sender].balance -= amount;\n    _VerifiedTransfer(msg.sender, amount);\n  }\n\n  /** @notice If house has not decided bet within 24 hours, force player win.\n    *  Address calling this function receives house take (into house balance).\n    */\n  function ForceBet(uint256 bet_id) external {\n    require(bets[bet_id].timestamp + 1 days < block.timestamp, \"< 24h old\");\n    _PlayerWin(bet_id);\n    _DeleteBet(bet_id);\n  }\n  /* --- END PLAYER ACTIONS --- */\n\n  /* --- HOUSE ACTIONS --- */\n  /** @notice Open a new house for players to bet against or adjust house parameters.\n    *  Note on adjusting parameters: house must be paused and this will\n    *  update last_update_timestamp.\n    * @param modulus bytes32[8] representing modulus of a 2048 bit RSA key.\n    * @param max_loss Maximum WEI that house will tolerate losing on a single bet.\n    *  Applies to pot value, so small bets with high odds or large bets with smaller odds\n    *  can both exceed this value.\n    * @param min_bet Minimum bet price that house is willing to accept.\n    *  Setting this too low can result in gas prices exceeding earnings.\n    * @param take House take. Can be from 0 to 1000 and goes up in 0.01% increments.\n    *  Applied only for player wins (except if 'ForceBet' is called).\n    */\n  function OpenOrAdjustHouse(bytes32[8] calldata modulus, uint256 max_loss,\n                             uint256 min_bet, uint256 take)\n           PausedOnly payable external {\n    // Open house\n    if(houses[msg.sender].pause_block == 0) {\n      require(msg.value > 1e8 gwei, \"Insufficient funds\");\n      require(msg.sender != address(0), \"Invalid address\");\n      houses[msg.sender].pause_block = type(uint256).max;\n      houses[msg.sender].house_address_index = uint128(state.num_houses);\n      house_addresses.push(msg.sender);\n      state.num_houses++;\n    }\n    houses[msg.sender].balance += msg.value;\n    houses[msg.sender].modulus = modulus;\n    houses[msg.sender].max_loss = max_loss;\n    houses[msg.sender].min_bet = min_bet;\n    houses[msg.sender].take = take;\n    houses[msg.sender].last_update_timestamp = block.timestamp;\n    // Reserve funds owned by house\n    state.reserved_eth += msg.value;\n    _ValidateHouseParameters(msg.sender);\n  }\n\n  /** @notice Decide outcome of a bet by providing a signature for bet randomness.\n    * @param bet_id Identifier of bet to be decided.\n    * @param signed_randomness RSA signature (see top of file) for bet.randomness.\n    */ \n  function DecideBet(uint256 bet_id, bytes32[8] memory signed_randomness) external {\n    require(bets[bet_id].house == msg.sender, \"Must be called by house\");\n    require(bets[bet_id].randomness ==\n            _ExtractSigned(signed_randomness, houses[bets[bet_id].house].modulus),\n            \"Signature mismatch\");\n    uint256 pot = uint256(bets[bet_id].price_gwei) * bets[bet_id].odds * 1 gwei;\n    // 1 / odds chance of winning.\n    if(uint256(keccak256(abi.encode(signed_randomness))) % bets[bet_id].odds == 0) {\n      _PlayerWin(bet_id);\n    } else {\n      // If player loses, no house or contract takes are applicable.\n      houses[msg.sender].bet_balance -= pot;\n      houses[msg.sender].balance += pot;\n      emit BetResolved(msg.sender, false, uint88(bets[bet_id].odds),\n                       bets[bet_id].player, uint96(pot));\n    }\n    _DeleteBet(bet_id);\n    // Completed bets incremented here to only count decided bets.\n    houses[msg.sender].completed_bets++;\n    // Neverending bubble sort keeps active houses near top of array.\n    uint128 house_idx = houses[msg.sender].house_address_index;\n    if(house_idx > 0) {\n      // Swap addresses.\n      house_addresses[house_idx] = house_addresses[house_idx - 1];\n      house_addresses[house_idx - 1] = msg.sender;\n      // Update indices.\n      houses[msg.sender].house_address_index--;\n      houses[house_addresses[house_idx]].house_address_index++;\n    }\n  }\n\n  /** @notice Withdraw funds from house. House must be paused.\n    * @param amount Amount to withdraw (WEI).\n    **/\n  function HouseWithdraw(uint256 amount) external PausedOnly {\n    require(amount <= houses[msg.sender].balance, \"Insufficient funds\");\n    houses[msg.sender].balance -= amount;\n    state.reserved_eth -= amount;\n    _VerifiedTransfer(msg.sender, amount);\n  }\n  \n  /** @notice Add funds to house. */\n  function FundHouse() external payable HouseExists {\n    houses[msg.sender].balance += msg.value;\n    state.reserved_eth += msg.value;\n  }\n  \n  /** @notice Pause/unpause house.\n   *   Pause takes 250 blocks to start and cannot be changed before that.\n   *   Unpause takes effect immediately.\n   */\n  function TogglePauseHouse() external HouseExists {\n    // House must either be paused or or have no pending pauses.\n    require(houses[msg.sender].pause_block <= block.number ||\n            houses[msg.sender].pause_block == type(uint256).max,\n            \"Pause pending\");\n    // Pause in future to prevent reactions to an incoming losing bet.\n    if(houses[msg.sender].pause_block == type(uint256).max) {\n      houses[msg.sender].pause_block = block.number + PAUSE_DELAY_BLOCKS;\n    // Unpause.\n    } else {\n      houses[msg.sender].pause_block = type(uint256).max;\n    }\n  }\n  /* --- END HOUSE ACTIONS --- */\n\n  /* --- CONTRACT ACTIONS --- */\n   constructor() {\n    state.owner = msg.sender;\n    state.sale_price = type(uint256).max;\n    // Prevent dismantling right after deployment\n    state.last_bet_time = block.timestamp;\n  }\n\n  // Allow any address to send money to owner so owner wallet can be kept cold.\n  function OwnerWithdraw() external {\n    _VerifiedTransfer(state.owner, address(this).balance - state.reserved_eth);\n  }\n  \n  function ChangeOwner(address new_owner) external OnlyOwner {\n    state.owner = new_owner;\n  }\n  \n  /** @notice Contract can be bought by anyone if owner lowers price. */\n  function BuyContract(uint256 new_price) external payable {\n    require(msg.value >= state.sale_price, \"Price\");\n    address owner = state.owner;\n    state.owner = msg.sender;\n    state.sale_price = new_price;\n    // Old owner receives payment and earnings up to now.\n    _VerifiedTransfer(owner, address(this).balance - state.reserved_eth);\n  }\n  \n  function SetPrice(uint256 sale_price) external OnlyOwner {\n    state.sale_price = sale_price;\n  }\n\n  function Dismantle() external OnlyOwner {\n    require(state.last_bet_time + 90 days < block.timestamp, \"90 days\");\n    selfdestruct(payable(state.owner));\n  }\n  /* --- END CONTRACT ACTIONS --- */\n\n  /* --- DATA & EVENTS --- */\n  /** @notice A bet struct is created for each bet, so it is optimised for data size\n    *  Bets are stored as a doubly linked list per house, so previous_house_bet\n    *  and next_house_bet are pointers within global bets mapping.\n    *  Resolved bets are deleted and removed from relevant house list.\n    */\n  struct Bet {\n    address house;              // House.\n    uint56 price_gwei;          // Price of bet in GWEI.\n    uint40 timestamp;           // Bet creation time.\n\n    address player;             // Player.\n    uint32 previous_house_bet;  // Previous undecided bet for same house.\n    uint32 next_house_bet;      // Next undecided bet for same house.\n\n    uint32 odds;                // Odds of winning (odds to 1).\n\n    bytes32 randomness;         // Random value provided by player.\n  }\n\n  /** @dev Event for creation of bets. */\n  event BetPlaced(address house, uint32 bet_id);\n  /** @dev Event for bet resolution (not emitted if 'ForceBet' was used). */\n  event BetResolved(address house, bool player_win, uint88 odds,\n                    address player, uint96 pot);\n  \n  struct House {\n    uint256 balance;                     // Available balance (excludes bet_balance).\n    uint256 bet_balance;                 // Balance blocked by bets.\n    uint256 max_loss;                    // Maximum loss house accepts on one bet.\n    uint256 min_bet;                     // Minimum bet price house will accept.\n    uint256 take;                        // House take in units of 0.01% (<= 10%).\n    bytes32[8] modulus;                  // RSA key modulus.\n    uint256 pause_block;                 // Block number for pausing house.\n\n    // Next four values optimised to interact with entries in Bet structs.\n    // First bet and last bet are pointers to a doubly linked list of unresolved bets.\n    uint32 first_bet;                    // First undecided bet.\n    uint32 last_bet;                     // Last undecided bet.\n    uint32 active_bets;                  // Number of active bets.\n    uint32 completed_bets;               // Number of decided bets.\n    uint128 house_address_index;         // Index in house_addresses.\n\n    uint256 last_update_timestamp;       // Timestamp of last update to house parameters.\n    uint256 last_low_balance_timestamp;  // Last time that house balance was below max loss.\n  }\n  struct Player {\n    uint256 balance;         // Available balance (excludes money in active bets).\n    uint256 nonce;           // Current nonce (increase by 1 to 10 for each bet).\n    uint256 active_bets;     // Number of undecided bets.\n    uint256 creation_block;  // Block number of player creation.\n    uint256 winnings;        // Total player winnings.\n  }\n  struct State {\n    address owner;          // Contract owner address.\n    uint32 bet_counter;     // Total number of bets placed.\n    uint64 winnings_micro;  // Total player winnings in micro ETH.\n    uint256 reserved_eth;   // ETH reserved in WEI (owner cannot withdraw).\n    uint256 sale_price;     // Price to buy contract.\n    uint256 last_bet_time;  // Last time that a bet was placed.\n    uint256 num_houses;     // Number of houses that have been opened.\n  }\n  \n  // Houses mapping (private, use `ViewHouse` function).\n  mapping(address => House) private houses;\n  /** @notice House struct holds state for a house. */\n  function ViewHouse(address house) external view returns (House memory) {\n    return houses[house];\n  }\n\n  /** @notice Player struct holds state for player */\n  mapping(address => Player) public players;\n\n  /** @notice A bet struct is created for each bet, so it is optimised for data size\n    *  Bets are stored as a doubly linked list per house, so previous_house_bet\n    *  and next_house_bet are pointers within global bets mapping.\n    *  Resolved bets are deleted and removed from relevant house list.\n    */\n  mapping(uint256 => Bet) public bets;\n\n  /** @dev List of house addresses (which can be used to access houses mapping).\n    *  Continuously reordered to bring more active houses to top of list (see 'DecideBet').\n    */\n  address[] public house_addresses;\n  /** @dev State struct contains overall contract state. */\n  State public state;\n  /* --- END DATA & EVENTS --- */\n\n  /* --- INTERNAL FUNCTIONS --- */\n  function _ValidateHouseParameters(address house_id) internal view {\n    require(houses[house_id].min_bet >= 1e4 gwei, \"Min bet too low\");\n    require(houses[house_id].max_loss >= 1e7 gwei, \"Max loss too low\");  // At least 0.01 ETH\n    require(houses[house_id].take <= 1e3, \"Take too high\");  // Max 10%.\n    // Too expensive to check modulus, but it should at least be big and odd.\n    require(uint256(houses[house_id].modulus[7]) & 1 == 1, \"Use prime modulus\");\n    require(uint256(houses[house_id].modulus[0]) > MIN_MOD, \"Use 2048 bit key\");\n  }\n  \n  function _VerifiedTransfer(address recipient, uint256 amount) internal {\n    (bool success, ) = payable(recipient).call{value: amount}('');\n    require(success, \"Transfer failed\");\n  }\n\n  function _GetContractTake(uint256 pot_amount_gwei) internal pure returns (uint256 take_wei) {\n    if(pot_amount_gwei < 1e8) {         // < 0.1 ETH: 1% take.\n      take_wei = pot_amount_gwei * 1e7;\n    } else if(pot_amount_gwei < 1e9) {  // < 1 ETH: 0.5% take.\n      take_wei = pot_amount_gwei * 5e6;\n    } else if(pot_amount_gwei < 5e9) {  // < 5 ETH: 0.2% take.\n      take_wei = pot_amount_gwei * 2e6;\n    } else {                            // > 5 ETH: 0.1% take.\n      take_wei = pot_amount_gwei * 1e6;\n    }\n  }\n  \n  function _PlayerWin(uint256 bet_id) internal {\n    uint256 pot = uint256(bets[bet_id].price_gwei) * bets[bet_id].odds;\n    // Pot value in GWEI is used here to avoid division.\n    uint256 contract_take_wei = _GetContractTake(pot);\n    // Multiplying GWEI value by 1e5 gives 1/10000 WEI value.\n    // Since take <= 1000, this means up to 10% house take.\n    uint256 house_take_wei = pot * houses[bets[bet_id].house].take * 1e5;\n\n    state.winnings_micro += uint64(pot / 1e3);  // Micro ETH to fit in 1e64.\n    pot *= 1 gwei;  // Convert to WEI.\n    uint256 winnings = pot - contract_take_wei - house_take_wei;\n    players[bets[bet_id].player].winnings += winnings;\n    players[bets[bet_id].player].balance += winnings;\n    houses[bets[bet_id].house].bet_balance -= pot;\n    // msg.sender different to bets[bet_id].house iff bet is forced.\n    houses[msg.sender].balance += house_take_wei;\n    state.reserved_eth -= contract_take_wei;\n    \n    emit BetResolved(bets[bet_id].house, true, uint88(bets[bet_id].odds),\n                     bets[bet_id].player, uint96(pot));\n  }\n  \n  function _DeleteBet(uint256 bet_id) internal {\n    uint32 previous = bets[bet_id].previous_house_bet;\n    uint32 next = bets[bet_id].next_house_bet;\n    if(previous == 0) {\n      houses[bets[bet_id].house].first_bet = next;\n    } else {\n      bets[previous].next_house_bet = next;\n    }\n    if(next == 0) {\n      houses[bets[bet_id].house].last_bet = previous;\n    } else {\n      bets[next].previous_house_bet = previous;\n    }\n    houses[bets[bet_id].house].active_bets--;\n    players[bets[bet_id].player].active_bets--;\n    delete bets[bet_id];\n  }\n\n  function _ExtractSigned(bytes32[8] memory signature,\n      bytes32[8] memory modulus) internal view returns (bytes32) {\n    // Assembly for modular exponentiation (check RSA signature).\n    assembly {\n      let ptr:= mload(0x40)\n      mstore(ptr, 0x100)             // Signature length (2048 bits).\n      mstore(add(ptr, 0x20), 0x20)   // Public exponent length (256 bits).\n      mstore(add(ptr, 0x40), 0x100)  // Modulus length (2048 bits).\n      mstore(add(ptr, 0x160), 17)    // Public exponent always 17.\n      // Signature and modulus are too long for simple assignment.\n      let sigptr := add(ptr, 0x60)   // Signature pointer.\n      let modptr := add(ptr, 0x180)  // Modulus pointer.\n      // Loop through both (same lengths).\n      for { let i:= 0} lt(i, 0x100) { i := add(i, 0x20) } {\n        mstore(add(modptr, i), mload(add(modulus, i)))\n        mstore(add(sigptr, i), mload(add(signature, i)))\n      }\n      // Overwrite modulus with message.\n      if iszero(staticcall(sub(gas(), 2000), 0x05, ptr, 0x280, modulus, 0x100)) {\n        revert(0, 0)\n      }\n    }\n    // End assembly.\n    // Verify message prefix.\n    require(\n      modulus[0] == SIGNATURE_START &&\n      modulus[1] == PADDING_BLOCK &&\n      modulus[2] == PADDING_BLOCK &&\n      modulus[3] == PADDING_BLOCK &&\n      modulus[4] == PADDING_BLOCK &&\n      modulus[5] == PADDING_BLOCK &&\n      modulus[6] == MESSAGE_PREFIX,\n      \"Padding\");\n    // Last entry in modulus is the recovered message (should be bet randomness).\n    return modulus[7];\n  }\n  /* --- END INTERNAL FUNCTIONS --- */\n\n  /* --- ACCESS MODIFIERS --- */\n   // Revert if house does not exist.\n   modifier HouseExists() {\n    require(houses[msg.sender].pause_block > 0, \"House does not exist\");\n    _;\n  }\n\n  // Revert if an existing house is not paused or has unresolved bets.\n  modifier PausedOnly() {\n    require(houses[msg.sender].pause_block < block.number, \"Pause house\");\n    require(houses[msg.sender].active_bets == 0, \"Resolve bets\");\n    _;\n  }\n\n  modifier OnlyOwner() {\n    require(msg.sender == state.owner, \"Owner\");\n    _;\n  }\n  /* --- END ACCESS MODIFIERS --- */\n\n  /* --- CONSTANTS --- */\n  // Ensure signature is large enough to sign messages.\n  uint256 private constant MIN_MOD =\n    0x8000000000000000000000000000000000000000000000000000000000000000;\n  uint256 private constant PAUSE_DELAY_BLOCKS = 250;\n  // Following 3 constants are used for signature padding.\n  bytes32 private constant SIGNATURE_START = \n    0x0001ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n  bytes32 private constant PADDING_BLOCK =\n    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n  // Uses encoding for SHA-256.\n  bytes32 private constant MESSAGE_PREFIX =\n    0xffffffffffffffffffffffff003031300d060960864801650304020105000420;\n  /* --- END CONSTANTS --- */\n  receive() external payable { }\n}\n"}}}