{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "DatrixoEquityToken.sol": {
      "content": "pragma solidity >=0.4.21 <0.6.0;\r\n\r\ncontract SafeMath {\r\n\r\n    function safeMul(uint a, uint b) internal pure returns(uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal pure returns(uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal pure returns(uint) {\r\n        uint c = a + b;\r\n        assert(c >=a && c >= b);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract DatrixoEquityToken is SafeMath {\r\n\r\n    string constant public standard = \"ERC20\";\r\n    string constant public name = \"DatrixoEquityToken\";\r\n    string constant public symbol = \"DRX\";\r\n    uint8 constant public decimals = 5;\r\n    uint public totalSupply = 800000000;\r\n    address public owner;\r\n    uint public startTime;\r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => uint) public firstPurchaseTime;\r\n    address[] public shareholders;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event ShareholderRemoved(address indexed addr, uint value);\r\n\r\n    constructor(address _ownerAddr, uint _startTime) public {\r\n        owner = _ownerAddr;\r\n        startTime = _startTime;\r\n        balanceOf[owner] = totalSupply;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"You are not contract owner.\");\r\n        _;\r\n    }\r\n\r\n    modifier afterStartTime() {\r\n        require(now > startTime, \"STO is not started.\");\r\n        _;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public onlyOwner afterStartTime returns(bool success){\r\n        require(msg.sender != _to, \"Target address can't be equal source.\");\r\n        require(_to != address(0), \"Target address is 0x0\");\r\n        require(balanceOf[_to] == 0, \"Target balance not equal 0\");\r\n        if (!checkShareholderExist(_to)) {\r\n            shareholders.push(_to);\r\n        }\r\n        return _firstTransfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public onlyOwner afterStartTime returns(bool success){\r\n        return _secondTransfer(_from, _to, _value);\r\n    }\r\n\r\n    function removeShareholder(address _addr) public onlyOwner returns(bool success) {\r\n        require(_addr != address(0), \"Target address is 0x0\");\r\n        require(checkShareholderExist(_addr), \"Shareholder is not exist.\");\r\n        for (uint i = 0; i < shareholders.length; i++) {\r\n            if (shareholders[i] == _addr) {\r\n                delete shareholders[i];\r\n            }\r\n        }\r\n        if (firstPurchaseTime[_addr] > 0) {\r\n            delete firstPurchaseTime[_addr];\r\n        }\r\n        bool result = true;\r\n        uint value = 0;\r\n        if (balanceOf[_addr] > 0) {\r\n            value = balanceOf[_addr];\r\n            result = _transferFrom(_addr, owner, value);\r\n        }\r\n        require(result);\r\n        emit ShareholderRemoved(_addr, value);\r\n        return result;\r\n    }\r\n\r\n    function _firstTransfer(address _to, uint _value) internal onlyOwner afterStartTime returns(bool success) {\r\n        require(_to != address(0), \"Target address is 0x0\");\r\n        require(balanceOf[_to] == 0, \"Target balance not equal 0\");\r\n        require(safeSub(balanceOf[msg.sender], _value) >= 0, \"Value more then available amount\");\r\n        if (!checkShareholderExist(_to)) {\r\n            shareholders.push(_to);\r\n        }\r\n        firstPurchaseTime[_to] = now;\r\n        return _transfer(_to, _value);\r\n    }\r\n\r\n    function _secondTransfer(address _from, address _to, uint _value) onlyOwner afterStartTime internal returns(bool success){\r\n        require(safeSub(balanceOf[_from], _value) >= 0, \"Value more then balance amount\");\r\n        if (_to != address(0)) {\r\n            require(firstPurchaseTime[_to] == 0, \"Target balance has first transfer amount.\");\r\n        }\r\n        if (firstPurchaseTime[_from] > 0) {\r\n            delete firstPurchaseTime[_from];\r\n        }\r\n        if (!checkShareholderExist(_to)) {\r\n            shareholders.push(_to);\r\n        }\r\n        firstPurchaseTime[_to] = now;\r\n        return _transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function checkShareholderExist(address _addr) internal view returns(bool) {\r\n        for (uint i = 0; i < shareholders.length; i++) {\r\n            if (shareholders[i] == _addr) return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _transfer(address _to, uint _value) internal returns(bool success){\r\n        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);\r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function _transferFrom(address _from, address _to, uint _value) internal returns(bool success){\r\n        balanceOf[_from] = safeSub(balanceOf[_from], _value);\r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function getShareholdersArray() public view returns(address[] memory) {\r\n        return shareholders;\r\n    }\r\n\r\n    function setStart(uint _newStart) public onlyOwner {\r\n        require(_newStart < startTime, \"New start time must be earlier current start time.\");\r\n        startTime = _newStart;\r\n    }\r\n}"
    }
  }
}