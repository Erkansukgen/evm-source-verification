{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/maid.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n//pragma solidity ^0.7.0;\n\n//pragma solidity 0.5.12;\n\n\npragma solidity ^0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface TokenInterface {\n    function balanceOf(address) external view returns (uint);\n}\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n}\n//[\"0x879c9c52f3234fc3255defabce9c3e627d4b7843\",\"0x368425a5b427184e8f79ec234922e98846702d9a\", \"0x4c72b72c2a04b5d1c7dc2d9ffff8c7e9305913e7\" ]\ninterface IDutchAuction {\n    function commitTokensFrom(address _from, uint256 _amount, bool read) external;\n    function commitEth(address payable _beneficiary, bool read) external payable;\n    function isOpen() external view returns (bool);\n    function withdrawTokens(address payable beneficiary) external;\n}\n    \ncontract Owned {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only owner can do this\");\n        _;\n    }\n\n    function kill()\n        public\n        onlyOwner\n    {\n        selfdestruct(msg.sender);\n    }\n}\n\n\ncontract Whitelist is Owned {\n    mapping(address => bool) public whitelist;\n\n    modifier onlyWhitelisted() {\n        require(whitelist[msg.sender], \"Not whitelisted\");\n        _;\n    }\n\n    function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            success = true; \n        }\n    }\n\n    function addAddressesToWhitelist(address[] memory addrs) onlyOwner public returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n}\n\ncontract Arbitrage is Whitelist {\n    \n    constructor() public {\n        addAddressToWhitelist(owner);\n    }\n    \n    function buyDutchWithTokens(address dutch, address token, uint256 amount) public onlyWhitelisted {\n        require(IDutchAuction(dutch).isOpen(), \"!open\");\n        require(TokenInterface(token).balanceOf(address(this)) > 0, \"!funds\");\n        TransferHelper.safeApprove(token, dutch, uint256(-1));\n        IDutchAuction(dutch).commitTokensFrom(owner, amount, true);\n    }\n    \n    function buyDutchWithETH(address dutch, uint256 amount) public onlyWhitelisted {\n        require(IDutchAuction(dutch).isOpen(), \"!open\");\n        require(address(this).balance > 0, \"!funds\");\n        IDutchAuction(dutch).commitEth{value: amount}(payable(owner), true);\n    }\n    \n    function withdraw(address dutch) public {\n        IDutchAuction(dutch).withdrawTokens(payable(owner));\n    }\n    \n    function withdrawEther() external onlyOwner {\n        payable(address(owner)).transfer(address(this).balance);\n    }\n    \n    function withdrawTokens(address token) public onlyOwner {\n        uint balance = TokenInterface(token).balanceOf(address(this));\n        TransferHelper.safeTransfer(token, owner, balance);\n    }\n    \n    receive() external payable {}\n\n    fallback () external {}\n}"}}}