{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"myswap_safe_chi.sol":{"content":"pragma solidity =0.6.6;\r\n\r\ninterface IFreeUpTo {\r\n    function freeUpTo(uint256 value) external returns (uint256 freed);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\n\r\ncontract MyRouter {\r\n    mapping(uint16 => uint) public mapaddr;\r\n    IFreeUpTo public constant chi = IFreeUpTo(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\r\n    address constant public weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    \r\n    using SafeMath for uint;\r\n    \r\n    modifier onlyTrader {\r\n        require((msg.sender == 0x58bE8DF2DDDDdBE9aEBeA4d4fd501739D69eB925) || (msg.sender == 0x520Db7C2161aA43fB7eB1BD87C40A084de2c5008) || (msg.sender == 0xf529Aeb37f7Ddf8f2d32fC12F984936Bf0c0afF7) || (msg.sender == 0x4Cb9b406D430eE2065556C0f73668bc435116822) || (msg.sender == 0xd38BF71470e636CE554D65453075e1A8A31A2ce7), \"not trader\");\r\n        _;\r\n    }\r\n    \r\n    constructor() public{\r\n    }\r\n    \r\n    function withdrawETH() public onlyTrader{\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n    \r\n    function withdrawToken(address tokenAddress, uint amount) public onlyTrader{\r\n        TransferHelper.safeTransfer(tokenAddress, msg.sender, amount);\r\n    }\r\n    \r\n    function withdrawTokens(address[] memory path) public onlyTrader{\r\n        for (uint i; i < path.length; i++) {\r\n            IERC20 token = IERC20(path[i]);\r\n            uint256 currentTokenBalance = token.balanceOf(address(this));\r\n            TransferHelper.safeTransfer(path[i], msg.sender, currentTokenBalance);\r\n        }\r\n    }\r\n    \r\n    function swap(\r\n        uint amount,\r\n        uint tokenMax,\r\n        uint amountMin,\r\n        address tokenA,\r\n        address tokenB,\r\n        bool isUniswap\r\n    ) public onlyTrader{\r\n        address pairOwner;\r\n        if (isUniswap) {\r\n            pairOwner = pairFor_sushi(tokenA, tokenB);\r\n        } else {\r\n            pairOwner = pairFor_uni(tokenA, tokenB);\r\n        }\r\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, pairOwner);\r\n        if (tokenMax > amountMin + reserveA) {\r\n            if (tokenMax - reserveA>amount) {\r\n                swapExactTokensForTokens(\r\n                    amount,\r\n                    tokenA,\r\n                    tokenB,\r\n                    reserveA,\r\n                    reserveB,\r\n                    pairOwner\r\n                );\r\n            } else {\r\n                swapExactTokensForTokens(\r\n                    tokenMax - reserveA,\r\n                    tokenA,\r\n                    tokenB,\r\n                    reserveA,\r\n                    reserveB,\r\n                    pairOwner\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    \r\n    function swapChi(\r\n        uint amount,\r\n        uint tokenMax,\r\n        uint amountMin,\r\n        address tokenA,\r\n        address tokenB,\r\n        bool isUniswap,\r\n        uint16 addr\r\n    ) public onlyTrader {\r\n        uint256 gasStart = gasleft();\r\n        address pairOwner;\r\n        if (isUniswap) {\r\n            pairOwner = pairFor_sushi(tokenA, tokenB);\r\n        } else {\r\n            pairOwner = pairFor_uni(tokenA, tokenB);\r\n        }\r\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, pairOwner);\r\n        if (tokenMax > amountMin + reserveA) {\r\n            if (tokenMax - reserveA>amount) {\r\n                swapExactTokensForTokens(\r\n                    amount,\r\n                    tokenA,\r\n                    tokenB,\r\n                    reserveA,\r\n                    reserveB,\r\n                    pairOwner\r\n                );\r\n            } else {\r\n                swapExactTokensForTokens(\r\n                    tokenMax - reserveA,\r\n                    tokenA,\r\n                    tokenB,\r\n                    reserveA,\r\n                    reserveB,\r\n                    pairOwner\r\n                );\r\n            }\r\n        }\r\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\r\n        if (gasSpent<30000) {\r\n            mapaddr[addr] = 0;\r\n        } else {\r\n            chi.freeUpTo( (gasSpent + 14154) / 41130);\r\n        }\r\n    }\r\n    \r\n    function swapBackAll(\r\n        uint reserveAMax,\r\n        address tokenA,\r\n        address tokenB,\r\n        bool isUniswap\r\n    ) public onlyTrader {\r\n        IERC20 tokenERC20 = IERC20(tokenA);\r\n        uint amountIn = tokenERC20.balanceOf(address(this));\r\n        address pairOwner;\r\n        if (isUniswap) {\r\n            pairOwner = pairFor_sushi(tokenA, tokenB);\r\n        } else {\r\n            pairOwner = pairFor_uni(tokenA, tokenB);\r\n        }\r\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, pairOwner);\r\n        if (reserveAMax>reserveA) {\r\n            swapExactTokensForTokens(\r\n                amountIn,\r\n                tokenA,\r\n                tokenB,\r\n                reserveA,\r\n                reserveB,\r\n                pairOwner\r\n            );\r\n        }\r\n        \r\n    }\r\n    \r\n    function swapBackToExactAmount(\r\n        uint reserveAMax,\r\n        uint amount,\r\n        address tokenA,\r\n        address tokenB,\r\n        bool isUniswap\r\n    ) public onlyTrader{\r\n        IERC20 tokenOutERC20 = IERC20(tokenB);\r\n        uint myTokenOut = tokenOutERC20.balanceOf(address(this));\r\n        require(amount  > myTokenOut, 'no need');\r\n        IERC20 tokenInERC20 = IERC20(tokenA);\r\n        uint myTokenIn = tokenInERC20.balanceOf(address(this));\r\n        address pairOwner;\r\n        if (isUniswap) {\r\n            pairOwner = pairFor_sushi(tokenA, tokenB);\r\n        } else {\r\n            pairOwner = pairFor_uni(tokenA, tokenB);\r\n        }\r\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, pairOwner);\r\n        if (reserveAMax>reserveA) {\r\n            uint amountOut = amount-myTokenOut;\r\n            uint amountIn = getAmountIn(amountOut, reserveA, reserveB);\r\n            if (amountIn<=myTokenIn) {\r\n                TransferHelper.safeTransfer(\r\n                tokenA, pairOwner, amountIn\r\n                );\r\n            _swap(amountOut, tokenA, tokenB, pairOwner);\r\n            } else {\r\n                swapExactTokensForTokens(\r\n                    myTokenIn,\r\n                    tokenA,\r\n                    tokenB,\r\n                    reserveA,\r\n                    reserveB,\r\n                    pairOwner\r\n                );\r\n            }\r\n        }\r\n    }\r\n    \r\n    function swapEth(\r\n        uint amount,\r\n        uint tokenMax,\r\n        uint amountMin,\r\n        address tokenA,\r\n        bool isUniswap\r\n    ) public {\r\n        swap(\r\n            amount,\r\n            tokenMax,\r\n            amountMin,\r\n            tokenA,\r\n            weth,\r\n            isUniswap\r\n        );\r\n    }\r\n\r\n    \r\n    function buyAndFree22457070633(\r\n        uint amount,\r\n        uint tokenMax,\r\n        uint amountMin,\r\n        address tokenA,\r\n        bool isUniswap,\r\n        uint16 addr\r\n    ) public {\r\n        swapChi(\r\n            amount,\r\n            tokenMax,\r\n            amountMin,\r\n            tokenA,\r\n            weth,\r\n            isUniswap,\r\n            addr\r\n        );\r\n    }\r\n    \r\n    function swapBackAllEth(\r\n        uint reserveAMax,\r\n        address tokenB,\r\n        bool isUniswap\r\n    ) public {\r\n        swapBackAll(\r\n            reserveAMax,\r\n            weth,\r\n            tokenB,\r\n            isUniswap\r\n        );\r\n    }\r\n    \r\n    function swapBackToExactAmountEth(\r\n        uint reserveAMax,\r\n        uint amount,\r\n        address tokenB,\r\n        bool isUniswap\r\n    ) public {\r\n        swapBackToExactAmount(\r\n            reserveAMax,\r\n            amount,\r\n            weth,\r\n            tokenB,\r\n            isUniswap\r\n        );\r\n    }\r\n    \r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n    \r\n    // **** SWAP ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(uint amountOut, address tokenA, address tokenB, address pairOwner) internal virtual {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint amount0Out, uint amount1Out) = tokenA == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n        IUniswapV2Pair(pairOwner).swap(\r\n            amount0Out, amount1Out, address(this), new bytes(0)\r\n        );\r\n        \r\n    }\r\n    \r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint reserveA,\r\n        uint reserveB,\r\n        address pairOwner\r\n    ) internal virtual returns (uint amountOut) {\r\n        amountOut = getAmountOut(amountIn, reserveA, reserveB);\r\n        TransferHelper.safeTransfer(\r\n            tokenA, pairOwner, amountIn\r\n            );\r\n        _swap(amountOut, tokenA, tokenB, pairOwner);\r\n    }\r\n    \r\n\r\n    function getReserves(address tokenA, address tokenB, address pairOwner) internal view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairOwner).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n    \r\n    function pairFor_uni(address tokenA, address tokenB) public view returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\r\n            ))));\r\n    }\r\n    \r\n    function pairFor_sushi(address tokenA, address tokenB) public view returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\r\n            ))));\r\n    }\r\n    \r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\r\n    }\r\n    \r\n    function massaddAddress(uint16 start, uint16 count) public {\r\n        for (uint16 i; i <count; i++) {\r\n            mapaddr[start+i] = 1;\r\n        }\r\n    }\r\n    \r\n    function removeAddress(uint16 addr) public onlyTrader{\r\n        mapaddr[addr] = 0;\r\n    }\r\n    \r\n\r\n}"}}}