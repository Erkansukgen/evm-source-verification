{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/SirotToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; \n        return msg.data;\n    }\n    \n}\npragma solidity ^0.6.0;\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\npragma solidity ^0.6.0;\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"add of\");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"sub of\");\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"mult of\");\n\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"div by 0\");\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"mod by 0\");\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\npragma solidity ^0.6.2;\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Unable to send value, recipient may have reverted\");\n    }\n}\npragma solidity ^0.6.0;\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name = \"SirotToken\";\n    string private _symbol = \"SIROT\";\n    uint8 private _decimals = 18;\n    constructor () public {\n    }\n    function name() public view returns (string memory) {\n        return _name;\n    }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"transfer from zero address\");\n        require(recipient != address(0), \"transfer to zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"transfer amount exceeds bal\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"mint to  zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"burn from  zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"burn exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"approve from  zero address\");\n        require(spender != address(0), \"approve to  zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\npragma solidity ^0.6.0;\nabstract contract ERC20Capped is ERC20 {\n    uint256 private _cap;\n    constructor () public {\n        uint256 cap = 1500000000000000000000000000;\n        _cap = cap;\n    }\n    function cap() public view returns (uint256) {\n        return _cap;\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from == address(0)) { // When minting tokens\n            require(totalSupply().add(amount) <= _cap, \"cap exceeded\");\n        }\n    }\n}\npragma solidity ^0.6.0;\nabstract contract ERC20Burnable is Context, ERC20 {\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n}\npragma solidity ^0.6.0;\ncontract Ownable is Context {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n    function owner() public view returns (address) {\n        return _owner;\n    }\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"caller not owner\");\n        _;\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"new owner is zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\npragma solidity ^0.6.0;\ncontract TokenRecover is Ownable {\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) public onlyOwner {\n        IERC20(tokenAddress).transfer(owner(), tokenAmount);\n    }\n}\npragma solidity ^0.6.0;\nlibrary EnumerableSet {\n    struct Set {\n        bytes32[] _values;\n        mapping (bytes32 => uint256) _indexes;\n    }\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        uint256 valueIndex = set._indexes[value];\n        if (valueIndex != 0) { \n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n            bytes32 lastvalue = set._values[lastIndex];\n            set._values[toDeleteIndex] = lastvalue;\n            set._indexes[lastvalue] = toDeleteIndex + 1;\n            set._values.pop();\n            delete set._indexes[value];\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"index out of bounds\");\n        return set._values[index];\n    }\n    struct AddressSet {\n        Set _inner;\n    }\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n    struct UintSet {\n        Set _inner;\n    }\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\npragma solidity ^0.6.0;\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n    mapping (bytes32 => RoleData) private _roles;\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"sender must be admin to grant\");\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"sender must be admin to revoke\");\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"can only renounce roles for self\");\n        _revokeRole(role, account);\n    }\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\npragma solidity ^0.6.0;\ncontract Roles is AccessControl {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER\");\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR\");\n    constructor () public {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(OPERATOR_ROLE, _msgSender());\n    }\n    modifier onlyMinter() {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"caller not MINTER role\");\n        _;\n    }\n    modifier onlyOperator() {\n        require(hasRole(OPERATOR_ROLE, _msgSender()), \"caller not OPERATOR role\");\n        _;\n    }\n}\npragma solidity ^0.6.0;\ncontract SirotToken is ERC20Capped, ERC20Burnable, Roles, TokenRecover {\n    bool private _mintingFinished = false;\n    bool private _transferEnabled = false;\n    event MintFinished();\n    event TransferEnabled();\n    modifier canMint() {\n        require(!_mintingFinished, \"Minting is finished\");\n        _;\n    }\n    modifier canTransfer(address from) {\n        require(\n            _transferEnabled || hasRole(OPERATOR_ROLE, from),\n            \"Disallowed\"\n        );\n        _;\n    }\n    constructor()\n        public\n        ERC20Capped()\n        ERC20()\n    {\n        uint8 decimals = 18;\n        uint256 initialSupply = 1000000000000000000000000000;\n        bool transferEnabled = true;\n        bool mintingFinished = false;\n        _setupDecimals(decimals);\n        if (initialSupply > 0) {\n            _mint(owner(), initialSupply);\n        }\n        if (mintingFinished) {\n            finishMinting();\n        }\n        if (transferEnabled) {\n            enableTransfer();\n        }\n    }\n    function mintingFinished() public view returns (bool) {\n        return _mintingFinished;\n    }\n    function transferEnabled() public view returns (bool) {\n        return _transferEnabled;\n    }\n    function mint(address to, uint256 value) public canMint onlyMinter {\n        _mint(to, value);\n    }\n    function transfer(address to, uint256 value) public virtual override(ERC20) canTransfer(_msgSender()) returns (bool) {\n        return super.transfer(to, value);\n    }\n    function finishMinting() public canMint onlyOwner {\n        _mintingFinished = true;\n        emit MintFinished();\n    }\n    function enableTransfer() public onlyOwner {\n        _transferEnabled = true;\n        emit TransferEnabled();\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20, ERC20Capped) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}"
    }
  }
}