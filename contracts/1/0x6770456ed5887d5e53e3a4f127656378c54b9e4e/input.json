{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/BundleExecutor.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Router {\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n\r\n}\r\n\r\ninterface IUniswapV3Router {\r\n    struct ExactInputSingleParams {address tokenIn;address tokenOut;uint24 fee;address recipient;uint256 deadline;uint256 amountIn;uint256 amountOutMinimum;uint160 sqrtPriceLimitX96;}\r\n\r\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactInputParams {bytes path;address recipient;uint256 deadline;uint256 amountIn;uint256 amountOutMinimum;}\r\n\r\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\r\n}\r\n\r\ninterface IQuoter {\r\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\r\n\r\n    function quoteExactInputSingle(address tokenIn, address tokenOut, uint24 fee, uint256 amountIn, uint160 sqrtPriceLimitX96) external returns (uint256 amountOut);\r\n\r\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\r\n\r\n    function quoteExactOutputSingle(address tokenIn, address tokenOut, uint24 fee, uint256 amountOut, uint160 sqrtPriceLimitX96) external returns (uint256 amountIn);\r\n}\r\n\r\n\r\n// This contract simply calls multiple targets sequentially, ensuring WETH balance before and after\r\ncontract BundleExecutor {\r\n    address private owner;\r\n    IUniswapV2Router public immutable UniswapV2Router;\r\n    IUniswapV3Router public immutable UniswapV3Router;\r\n    IQuoter public immutable Quoter;\r\n    mapping(address => bool) private executors;\r\n\r\n    modifier onlyExecutor() {\r\n        require(executors[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    constructor() public payable {\r\n        owner = msg.sender;\r\n        executors[msg.sender] = true;\r\n\r\n        UniswapV2Router = IUniswapV2Router(address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D));\r\n        UniswapV3Router = IUniswapV3Router(address(0xE592427A0AEce92De3Edee1F18E0157C05861564));\r\n        Quoter = IQuoter(address(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6));\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    // V2 买入\r\n    function V2Buy(uint256 amountIn, uint amountOutMin, address[] memory path) external onlyExecutor returns (uint[] memory){\r\n        // 获取当前价格\r\n        uint256[] memory amounts = UniswapV2Router.getAmountsOut(amountIn, path);\r\n        // 判断最少买到的数量是否符合预期\r\n        require(amounts[amounts.length - 1] >= amountOutMin, \"Failed to buy\");\r\n        // 符合预期则买入\r\n        uint[] memory resultAmounts = UniswapV2Router.swapExactTokensForTokens(amountIn, amountOutMin, path, address(this), block.timestamp + 60);\r\n        return resultAmounts;\r\n    }\r\n\r\n    // V2 卖出\r\n    function V2Sell(uint256 amountOutMin, address[] memory path) external onlyExecutor returns (uint[] memory){\r\n        // 当前合约Token余额\r\n        uint256 _balanceOfToken = IERC20(path[0]).balanceOf(address(this));\r\n        require(_balanceOfToken > 0, \"Token insufficient balance\");\r\n        // 获取当前价格\r\n        uint256[] memory amounts = UniswapV2Router.getAmountsOut(_balanceOfToken, path);\r\n        // 判断卖出是否能达到预期\r\n        require(amounts[amounts.length - 1] >= amountOutMin, \"Failed to sell\");\r\n        // 价格没变化，直接交换\r\n        // UniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(_balanceOfToken, amountOutMin, path, address(this), block.timestamp + 60);\r\n        uint[] memory resultAmounts = UniswapV2Router.swapExactTokensForTokens(_balanceOfToken, amountOutMin, path, address(this), block.timestamp + 60);\r\n        return resultAmounts;\r\n    }\r\n\r\n    // 根据精确输入的Amount数量，计算输出的Token数量\r\n    function V3GetTokenOut(bytes memory path, uint256 amountIn) external returns (uint256)\r\n    {\r\n        return Quoter.quoteExactInput(path, amountIn);\r\n    }\r\n\r\n    // 单路径交易\r\n    function V3Single(address _tokenIn, address _tokenOut, uint24 poolFee, uint256 amountIn, uint256 amountOutMin) external onlyExecutor returns (uint256 amountOut) {\r\n        // 获取价格，判断价格是否发生变化\r\n        uint256 _amountOut = this.V3GetTokenOut(abi.encodePacked(_tokenIn, poolFee, _tokenOut), amountIn);\r\n        // 如果实际可返回的Token数量小于预估的数量，则回滚\r\n        require(_amountOut >= amountOutMin, \"The price has changed\");\r\n\r\n        IUniswapV3Router.ExactInputSingleParams memory params = IUniswapV3Router.ExactInputSingleParams({\r\n        tokenIn : _tokenIn,\r\n        tokenOut : _tokenOut,\r\n        fee : poolFee,\r\n        recipient : address(this),\r\n        deadline : block.timestamp + 60,\r\n        amountIn : amountIn,\r\n        amountOutMinimum : amountOutMin,\r\n        sqrtPriceLimitX96 : 0\r\n        });\r\n\r\n        // The call to `exactInputSingle` executes the swap.\r\n        uint256 resultAmountOut = UniswapV3Router.exactInputSingle(params);\r\n\r\n        return resultAmountOut;\r\n    }\r\n\r\n\r\n    // V3多路径交易\r\n    function V3Multiple(bytes memory path, uint256 amountIn, uint256 amountOutMin) external onlyExecutor returns (uint256){\r\n\r\n        uint256 _amountOut = this.V3GetTokenOut(path, amountIn);\r\n        // 如果实际可返回的Token数量小于预估的数量，则回滚\r\n        require(_amountOut >= amountOutMin, \"The price has changed\");\r\n\r\n        IUniswapV3Router.ExactInputParams memory params = IUniswapV3Router.ExactInputParams({\r\n        path : path,\r\n        recipient : address(this),\r\n        deadline : block.timestamp,\r\n        amountIn : amountIn,\r\n        amountOutMinimum : amountOutMin\r\n        });\r\n\r\n        // Executes the swap.\r\n        uint256 resultAmountOut = UniswapV3Router.exactInput(params);\r\n        return resultAmountOut;\r\n    }\r\n\r\n    // 允许Uniswap调用该合约里面的token\r\n    function approve(IERC20 token, address _address, uint256 _amount) external onlyOwner {\r\n        token.approve(_address, _amount);\r\n    }\r\n\r\n    // 添加执行人地址\r\n    function addExecutor(address _address) external onlyOwner {\r\n        executors[_address] = true;\r\n    }\r\n\r\n    // 移除可执行地址\r\n    function removeExecutor(address _address) external onlyOwner {\r\n        delete executors[_address];\r\n    }\r\n\r\n    // 提取合约内部的Token\r\n    function WithdrawToken(IERC20 token, uint256 amount) external onlyOwner {\r\n        require(token.balanceOf(address(this)) >= amount, \"Insufficient balance\");\r\n        token.transfer(msg.sender, amount);\r\n    }\r\n\r\n    // 转移所有者\r\n    function transferOwnership(address newOwner) onlyOwner external {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n\r\n    // 提取ETH\r\n    function withdraw(uint256 amount) onlyOwner external {\r\n        require(address(this).balance >= amount, \"Insufficient balance\");\r\n        msg.sender.transfer(amount);\r\n        amount = 0;\r\n    }\r\n}\r\n"
    }
  }
}