{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Bullet_Loan.sol": {
      "content": "pragma solidity 0.6.0;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ncontract MapleBullet {\n    \n    using SafeMath for uint256;\n    \n    address Admin = 0xFB2D3fE1C68734f78A8715cCD2BBd473D305BCcA;\n    address MapleWhitelist = 0x99eaB23F59296f02190E860560e6630e06CBa418; // TODO: Replace value with official segregated MapleWhitelist contract.\n    uint Fee;\n\n    // Re-entrancy guard variables (v0.6.0+)\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n    \n    // Permitted assets and precisions, controlled by Admin.\n    mapping(address => bool) Asset_Permitted;\n    mapping(address => uint) Asset_Precision;\n    \n    // Draw allowance for claiming payments, Draw_Allowance[ASSET][USER] correlates to Draw_Allowance[0xDAI][0xJOE].\n    mapping(address => mapping (address => uint)) Draw_Allowance; \n    \n    // Data indexing for Loans.\n    mapping(uint => Loan) Loans;\n    mapping(uint => uint) Loans_Created; // Loans_Created[CommunityID] = # of Loans Created for CommunityID\n    uint Total_Loans_Created;\n    \n    // Payment interval relation to allowed missable payments before Lender's claim collateral.\n    mapping(uint => uint) Payments_Missed_Max; // Payment_Missed_Maximum[_paymentInterval] = <Payment_Missed_Max>\n    \n    // Data structure for Loans.\n    struct Loan {\n        uint Community_ID;\n        address Borrower;\n        address Asset_Request;\n        address Asset_Collateral;\n        bool ETH_Collateral;\n        uint Collateral_Supplied;\n        uint Notional_Requested;\n        uint Notional_Supplied;\n        uint Payments;\n        uint Payment_Interval;\n        uint APR_Offered; // 10,000 precision ... i.e. 853 indicates 8.53% APR ... 853/10000\n        uint Fee;\n        uint Lenders_Count;\n        \n        Status Loan_Status;\n        Information Loan_Info;\n            \n        mapping(uint => address) Active_Lender_Search;\n        mapping(address => bool) Active_Lender;\n        mapping(address => uint) Active_Lender_Spot;\n        mapping(address => uint) Amount_Lent;\n        mapping(address => bool) Collateral_Claimed;\n    }\n    \n    struct Information {\n        uint Principal_Owed;\n        uint Next_Payment_Unix;\n        uint Amount_Owed_Next_Payment;\n        bool Payments_Started;\n        uint Payments_Missed;\n    }\n    \n    uint private _guardCounter;\n    \n    enum Status { Inactive, Active, Active_Halted, Active_Filled, Paid, Cancelled }\n    \n    // --\n    // Constructor\n    // --\n    \n    constructor() public {\n        Asset_Permitted[0x6B175474E89094C44Da98b954EedeAC495271d0F] = true;     // DAI\n        Asset_Precision[0x6B175474E89094C44Da98b954EedeAC495271d0F] = 1000000000000000000;\n        Asset_Permitted[0x0000000000000000000000000000000000000000] = true;     // ETH Placeholder\n        Asset_Precision[0x0000000000000000000000000000000000000000] = 1000000000000000000;\n        Asset_Permitted[0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48] = true;     // USDC\n        Asset_Precision[0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48] = 1000000;\n        Payments_Missed_Max[31104000] = 1;\n        Payments_Missed_Max[15552000] = 1;\n        Payments_Missed_Max[7776000] = 2;\n        Payments_Missed_Max[2592000] = 3;\n        Payments_Missed_Max[1296000] = 6;\n        Payments_Missed_Max[648000] = 6;\n    }\n    \n    // --\n    // Modifiers\n    // --\n    \n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    \n    modifier isAdmin() {\n        require(msg.sender == Admin);\n        _;\n    }\n    \n    // --\n    // Events\n    // --\n    \n    // loanRequested\n    event loanRequested(\n        uint indexed _communityID,\n        uint indexed _loanID,\n        address indexed _borrower,\n        address _assetRequest,\n        address _assetCollateral,\n        uint _requestAmount,\n        uint _collateralAmount,\n        uint  _apr,\n        uint _payments,\n        uint _paymentInterval,\n        uint _firstPaymentUnix,\n        uint _fee\n    );\n    \n    // loanFunded\n    event loanFunded(\n        uint indexed _communityID,\n        uint indexed _loanID,\n        uint _amount,\n        address _asset,\n        address indexed _lender,\n        address _borrower\n    );\n    \n    // paymentMade\n    event paymentMade(\n        uint indexed _communityID,\n        uint indexed _loanID,\n        uint _amount,\n        address _asset,\n        address indexed _borrower\n    );\n    \n    // communityCreated\n    event communityCreated(\n        address indexed _leader,\n        uint _communityID,\n        string _name\n    );\n    \n    // communityAdded\n    event addedToCommunity(\n        address indexed _addedPerson,\n        uint indexed _communityID,\n        string _name,\n        bool _lenderTrueBorrowerFalse,\n        bool _status\n    );\n    \n    // --\n    // Functions\n    // --\n    \n    // Admin-only. Update the fee for all loans.\n    function setFee(uint _fee) isAdmin public {\n        require(_fee >= 0 && _fee <= 100);\n        Fee = _fee;\n    }\n    \n    // Admin-only. Update the permission and precision of an asset, simultaneously.\n    function changeAsset(address _asset, bool _permitted, uint _precision) isAdmin public {\n        Asset_Permitted[_asset] = _permitted;\n        Asset_Precision[_asset] = _precision;\n    }\n    \n    // Create a Traditional Loan request using the specified parameters.\n    function createLoanRequest(uint _communityID, address _assetRequest, address _assetCollateral, uint _assetAmount, uint _collateralAmount, uint _payments, uint _paymentInterval, uint _apr) public nonReentrant {\n        // Require checks.\n        require(Whitelist(MapleWhitelist).getStatus(_communityID, msg.sender), \"You are not a member of this community.\"); // References external MapleWhitelist smart contract.\n        require(Asset_Permitted[_assetRequest] == true, \"Asset requested is not permitted.\");\n        require(Asset_Permitted[_assetCollateral] == true, \"Asset to be used as collateral is not permitted.\");\n        require(_payments <= 260 && _payments >= 1, \"Payments value exceeds 260 or is less than 1.\");\n        require(_collateralAmount.div(Asset_Precision[_assetCollateral]) % 1 == 0, \"ERC-20 Collateral supplied must be a whole number.\");\n        require(\n            _paymentInterval == 31104000 || \n            _paymentInterval == 15552000 || \n            _paymentInterval == 7776000 || \n            _paymentInterval == 2592000 || \n            _paymentInterval == 1296000 || \n            _paymentInterval == 648000, \n            \"Payment interval must be annual, semi-annual, quarterly, monthly, fortnightly, or weekly.\"\n        );\n        \n        // Internal data structure intialization and assignment.\n        Information memory _tempInfo = Information(0, now + 648000 + _paymentInterval, 0, false, 0);\n        Loans[Total_Loans_Created] = Loan(_communityID, msg.sender, _assetRequest, _assetCollateral, false, _collateralAmount, _assetAmount, 0, _payments, _paymentInterval, _apr, Fee, 0, Status.Active, _tempInfo);\n        \n        // Emit event, increment counters.\n        emit loanRequested(_communityID, Total_Loans_Created, msg.sender, _assetRequest, _assetCollateral, _assetAmount, _collateralAmount, _apr, _payments, _paymentInterval, now + 648000 + _paymentInterval, Fee);\n        Loans_Created[_communityID]++;\n        Total_Loans_Created++;\n        \n        // Borrower deposits collateral for his loan request.\n        if (_collateralAmount > 0) {\n            require(ERC20(_assetCollateral).transferFrom(msg.sender, address(this), _collateralAmount));\n        }\n    }\n    \n    // Create a Bullet Loan request using the specified parameters, payable modifier to support ETH deposit.\n    function createLoanRequestETH(uint _communityID, address _assetRequest, uint _assetAmount, uint _payments, uint _paymentInterval, uint _apr) public payable nonReentrant {\n        // Require checks.\n        require(Whitelist(MapleWhitelist).getStatus(_communityID, msg.sender), \"You are not a member of this community.\"); // References external MapleWhitelist smart contract.\n        require(_payments <= 260 && _payments >= 1, \"Payments value exceeds 260 or is less than 1.\");\n        require(Asset_Permitted[_assetRequest] == true, \"Asset requested is not permitted.\");\n        require(_assetAmount >= Asset_Precision[_assetRequest], \"Notional requested must be greater than 1 unit.\");\n        require(\n            _paymentInterval == 31104000 || \n            _paymentInterval == 15552000 || \n            _paymentInterval == 7776000 || \n            _paymentInterval == 2592000 || \n            _paymentInterval == 1296000 || \n            _paymentInterval == 648000, \n            \"Payment interval must be annual, semi-annual, quarterly, monthly, fortnightly, or weekly.\"\n        );\n        \n        // Internal data structure intialization and assignment.\n        Information memory _tempInfo = Information(0, now + 648000 + _paymentInterval, 0, false, 0);\n        Loans[Total_Loans_Created] = Loan(_communityID, msg.sender, _assetRequest, 0x0000000000000000000000000000000000000000, true, msg.value, _assetAmount, 0, _payments, _paymentInterval, _apr, Fee, 0, Status.Active, _tempInfo);\n        \n        // Emit event, increment counters.\n        emit loanRequested(_communityID, Total_Loans_Created, msg.sender, _assetRequest, 0x0000000000000000000000000000000000000000, _assetAmount, msg.value, _apr, _payments, _paymentInterval, now + 648000 + _paymentInterval, Fee);\n        Loans_Created[_communityID]++;\n        Total_Loans_Created++;\n    }\n    \n    // Stop a loan request while in progress.\n    function haltLoanRequest(uint _loanID) public nonReentrant {\n        // Require checks.\n        require(msg.sender == Loans[_loanID].Borrower, \"You are not the Borrower for this loan.\");\n        require(Loans[_loanID].Loan_Status == Status.Active, \"This bullet loan is not Active.\");\n        \n        // Transfer back excess collateral.\n        if (Loans[_loanID].Notional_Supplied < Loans[_loanID].Notional_Requested) {\n            \n            uint _amountTransferredIn = Loans[_loanID].Collateral_Supplied;\n            uint _percentageToDeduct = Loans[_loanID].Notional_Supplied.mul(100).div(Loans[_loanID].Notional_Requested);\n            uint _amountToDeduct = _amountTransferredIn.mul(_percentageToDeduct).div(100);\n            uint _amountToReturn = _amountTransferredIn.sub(_amountToDeduct);\n            if (Loans[_loanID].Notional_Supplied == 0) {\n                Loans[_loanID].Loan_Status = Status.Cancelled;\n                Loans[_loanID].Payments = 0;\n                Loans[_loanID].Loan_Info.Principal_Owed = 0;\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = 0;\n                Loans[_loanID].Loan_Info.Next_Payment_Unix = 0;\n            }\n            else {\n                Loans[_loanID].Loan_Status = Status.Active_Halted;\n                Loans[_loanID].Loan_Info.Payments_Started = true;\n            }\n            \n            // ERC-20 Collateral\n            if (Loans[_loanID].Asset_Collateral != 0x0000000000000000000000000000000000000000) {\n                require(ERC20(Loans[_loanID].Asset_Collateral).transfer(msg.sender, _amountToReturn));\n            }\n            \n            // Return ETH Collateral\n            else {\n                msg.sender.transfer(_amountToReturn);\n            }\n            \n        }\n    }\n    \n    // Fund a loan request.\n    function fundLoanRequest(uint _loanID, uint _amount) public nonReentrant {\n        // Require checks.\n        require(Whitelist(MapleWhitelist).getStatus(Loans[_loanID].Community_ID, msg.sender), \"You are not a member of this community.\"); // References external MapleWhitelist smart contract.\n        require(Loans[_loanID].Borrower != msg.sender, \"You can't lend to yourself.\");\n        address _asset = Loans[_loanID].Asset_Request;\n        require(_amount <= Loans[_loanID].Notional_Requested.sub(Loans[_loanID].Notional_Supplied), \"Amount must be equal or less than amount left.\");\n        require(Loans[_loanID].Loan_Info.Payments_Started == false, \"Payments have already started.\");\n        require(Loans[_loanID].Loan_Info.Next_Payment_Unix >= now + Loans[_loanID].Payment_Interval, \"It's too late to fund more.\");\n        require(Loans[_loanID].Loan_Status == Status.Active, \"The funding period for this loan has ended.\");\n        \n        // Update payment information and transfer funding.\n        Loans[_loanID].Loan_Info.Principal_Owed += _amount;\n        Loans[_loanID].Notional_Supplied += _amount;\n        uint _baseInterest = Loans[_loanID].APR_Offered.mul(Loans[_loanID].Loan_Info.Principal_Owed);\n        uint _daysInterest = Loans[_loanID].Loan_Info.Next_Payment_Unix.sub(now).div(86400);\n        uint _owedInterest = _baseInterest.div(10000).mul(_daysInterest).div(365);\n        Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _owedInterest;\n        uint _fee = Loans[_loanID].Fee;\n        require(ERC20(_asset).transferFrom(msg.sender, Loans[_loanID].Borrower, _amount.mul(1000 - _fee).div(1000)), \"Caller lacks funds, or contract lacks approval to transfer funding.\");\n        require(ERC20(_asset).transferFrom(msg.sender, Admin, _amount.mul(_fee).div(1000)), \"Caller lacks funds, or contract lacks approval to transfer funding.\");\n        \n        // Update lender information within loan for receiving future payments.\n        if (Loans[_loanID].Active_Lender[msg.sender] == true) {\n            Loans[_loanID].Amount_Lent[msg.sender] += _amount;\n        }\n        else {\n            Loans[_loanID].Active_Lender[msg.sender] = true;\n            Loans[_loanID].Active_Lender_Search[Loans[_loanID].Lenders_Count] = msg.sender;\n            Loans[_loanID].Active_Lender_Spot[msg.sender] = Loans[_loanID].Lenders_Count;\n            Loans[_loanID].Amount_Lent[msg.sender] = _amount;\n            Loans[_loanID].Lenders_Count++;\n        }\n        \n        if (Loans[_loanID].Notional_Supplied == Loans[_loanID].Notional_Requested) {\n            Loans[_loanID].Loan_Status = Status.Active_Filled;\n            Loans[_loanID].Loan_Info.Payments_Started = true;\n        }\n        \n        emit loanFunded(Loans[_loanID].Community_ID, _loanID, _amount, _asset, msg.sender, Loans[_loanID].Borrower);\n    }\n    \n    // Make a payment. Enables both authorized payment (24 hours before payment is due), or payment on behalf of the borrower at any time.\n    function makePayment(uint _loanID, address payable _borrower, bool _onBehalf) public nonReentrant {\n        \n        // Require checks.\n        require(Loans[_loanID].Loan_Info.Next_Payment_Unix >= now, \"You are past payments for this loan - recalculate.\");\n        require(Loans[_loanID].Borrower == _borrower, \"The provided address doesn't match the borrower.\");\n        require(Loans[_loanID].Payments > 0, \"This loan has already been repaid.\");\n        \n        // Store commonly used variable locally.\n        uint _fee = Loans[_loanID].Fee;\n        address _asset = Loans[_loanID].Asset_Request;\n        \n        // Transfer payment into contract\n        uint _amountOwed = Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment;\n        if (_onBehalf) {\n            require(ERC20(_asset).transferFrom(msg.sender, address(this), _amountOwed), \"Caller lacks funds or approval to make payment.\");\n        }\n        else {\n            if (msg.sender != _borrower) {\n                require(Loans[_loanID].Loan_Info.Next_Payment_Unix - 86400 < now, \"Authorized payment isn't allowed until payment is due in less than 24 hours.\");\n                // REMOVED (FEE): require(ERC20(_asset).transferFrom(_borrower, Admin, Asset_Precision[_asset].div(2)));\n            }\n            require(ERC20(_asset).transferFrom(Loans[_loanID].Borrower, address(this), _amountOwed), \"Borrower lacks funds or approval to make payment.\");\n        }\n        \n        // Distribute payment to Lenders by increasing draw allowance.\n        for (uint i=0; i < Loans[_loanID].Lenders_Count; i++) {\n            address _lender = Loans[_loanID].Active_Lender_Search[i];\n            uint _individualAmountLent = Loans[_loanID].Amount_Lent[_lender];\n            uint _totalAmountLent = Loans[_loanID].Notional_Supplied;\n            uint _individualPercentageExposure = _individualAmountLent.mul(100).div(_totalAmountLent);\n            uint _individualAmountOwed = _individualPercentageExposure.mul(_amountOwed).div(100);\n            \n            Draw_Allowance[_asset][_lender] += _individualAmountOwed.mul(1000 - _fee).div(1000);\n            Draw_Allowance[_asset][Admin] += _individualAmountOwed.mul(_fee).div(1000);\n        }\n        \n        if (Loans[_loanID].Loan_Info.Payments_Started == false) {\n            Loans[_loanID].Loan_Info.Payments_Started = true;\n            Loans[_loanID].Loan_Status = Status.Active_Halted;\n            // Transfer back any additional liquidity deposited for loan not required.\n            if (Loans[_loanID].Notional_Supplied < Loans[_loanID].Notional_Requested) {\n                // Critical Error #1 - Fixed below with appropriate return calculations based on partial funding. Same code in haltLoanRequest(...) \n                uint _amountTransferredIn = Loans[_loanID].Collateral_Supplied;\n                uint _percentageToDeduct = Loans[_loanID].Notional_Supplied.mul(100).div(Loans[_loanID].Notional_Requested);\n                uint _amountToDeduct = _amountTransferredIn.mul(_percentageToDeduct).div(100);\n                uint _amountToReturn = _amountTransferredIn.sub(_amountToDeduct);\n                // ERC-20 Collateral\n                if (Loans[_loanID].Asset_Collateral != 0x0000000000000000000000000000000000000000) {\n                    require(ERC20(Loans[_loanID].Asset_Collateral).transfer(_borrower, _amountToReturn));\n                }\n                // ETH Collateral\n                else {\n                    _borrower.transfer(_amountToReturn);\n                }\n            }\n        }\n        \n        // Decrement payments.\n        Loans[_loanID].Payments--;\n        \n        // Calculate next payment, or close loan if payments remaining is 0.\n        if (Loans[_loanID].Payments > 1) {\n            // Interest only calculation for next payment ...\n            uint _aprOffered = Loans[_loanID].APR_Offered;\n            uint _principalOwed = Loans[_loanID].Loan_Info.Principal_Owed;\n            uint _interestOwed = 0;\n            if (Loans[_loanID].Payment_Interval == 31104000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(360).div(365);   // Annual\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _interestOwed;\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 31104000;\n            }\n            else if (Loans[_loanID].Payment_Interval == 15552000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(180).div(365);   // Semi-annual\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _interestOwed;\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 15552000;\n            }\n            else if (Loans[_loanID].Payment_Interval == 7776000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(90).div(365);   // Quarterly\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _interestOwed;\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 7776000;\n            }\n            else if (Loans[_loanID].Payment_Interval == 2592000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(30).div(365);   // Monthly\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _interestOwed;\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 2592000;\n            }\n            else if (Loans[_loanID].Payment_Interval == 1296000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(15).div(365);   // Fortnightly\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _interestOwed;\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 1296000;\n            }\n            else {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(15).div(730);   // Weekly\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _interestOwed;\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 648000;\n            }\n        }\n        else if (Loans[_loanID].Payments == 1) {\n            // Calculations for final payment ...\n            uint _aprOffered = Loans[_loanID].APR_Offered;\n            uint _principalOwed = Loans[_loanID].Loan_Info.Principal_Owed;\n            uint _interestOwed = 0;\n            if (Loans[_loanID].Payment_Interval == 31104000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(360).div(365);   // Annual\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _principalOwed.add(_interestOwed);\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 31104000;\n            }\n            else if (Loans[_loanID].Payment_Interval == 15552000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(180).div(365);   // Semi-annual\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _principalOwed.add(_interestOwed);\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 15552000;\n            }\n            else if (Loans[_loanID].Payment_Interval == 7776000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(90).div(365);   // Quarterly\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _principalOwed.add(_interestOwed);\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 7776000;\n            }\n            else if (Loans[_loanID].Payment_Interval == 2592000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(30).div(365);   // Monthly\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _principalOwed.add(_interestOwed);\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 2592000;\n            }\n            else if (Loans[_loanID].Payment_Interval == 1296000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(15).div(365);   // Fortnightly\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _principalOwed.add(_interestOwed);\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 1296000;\n            }\n            else {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(15).div(730);   // Weekly\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _principalOwed.add(_interestOwed);\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 648000;\n            }\n        }\n        else {\n            // Payments complete.\n            Loans[_loanID].Loan_Status = Status.Paid;\n            Loans[_loanID].Loan_Info.Principal_Owed = 0;\n            Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = 0;\n            Loans[_loanID].Loan_Info.Next_Payment_Unix = 0;\n            // Return the borrower's initial deposit back (if any).\n            if (Loans[_loanID].Loan_Info.Payments_Missed < Payments_Missed_Max[Loans[_loanID].Payment_Interval]) { \n                uint _amountTransferredIn = Loans[_loanID].Collateral_Supplied;\n                uint _percentageToReturn = Loans[_loanID].Notional_Supplied.mul(100).div(Loans[_loanID].Notional_Requested);\n                uint _amountToReturn = _amountTransferredIn.mul(_percentageToReturn).div(100);\n                if (_amountToReturn > 0) {\n                    // ERC-20 Collateral\n                    if (Loans[_loanID].Asset_Collateral != 0x0000000000000000000000000000000000000000) {\n                        require(ERC20(Loans[_loanID].Asset_Collateral).transfer(_borrower, _amountToReturn));\n                    }\n                    // ETH Collateral\n                    else {\n                        _borrower.transfer(_amountToReturn);\n                    }\n                }\n            }\n        }\n        \n        emit paymentMade(Loans[_loanID].Community_ID, _loanID, _amountOwed, _asset, _borrower);\n    }\n    \n    // Make a full payment. Enables payment on behalf of the borrower at any time. Does not enable authorized payments.\n    function makeFullPayment(uint _loanID, bool _onBehalf) public nonReentrant {\n        \n        // require(Loans[_loanID].Borrower == msg.sender, \"You don't owe payments for this loan.\");\n        \n        require(Loans[_loanID].Loan_Info.Next_Payment_Unix >= now, \"You are past payments for this loan - recalculate.\");\n        \n        // Transfer payment into contract\n        address _asset = Loans[_loanID].Asset_Request;\n        uint _fee = Loans[_loanID].Fee;\n        uint _principalOwed = Loans[_loanID].Loan_Info.Principal_Owed;\n        uint _aprOffered = Loans[_loanID].APR_Offered;\n        uint _currentlyOwedInterest = 0;\n        if (Loans[_loanID].Payment_Interval == 31104000) {\n            _currentlyOwedInterest = _aprOffered.mul(_principalOwed).div(10000).mul(360).div(365);   // Annual\n        }\n        else if (Loans[_loanID].Payment_Interval == 15552000) {\n            _currentlyOwedInterest = _aprOffered.mul(_principalOwed).div(10000).mul(180).div(365);   // Semi-annual\n        }\n        else if (Loans[_loanID].Payment_Interval == 7776000) {\n            _currentlyOwedInterest = _aprOffered.mul(_principalOwed).div(10000).mul(90).div(365);   // Quarterly\n        }\n        else if (Loans[_loanID].Payment_Interval == 2592000) {\n            _currentlyOwedInterest = _aprOffered.mul(_principalOwed).div(10000).mul(30).div(365);   // Monthly\n        }\n        else if (Loans[_loanID].Payment_Interval == 1296000) {\n            _currentlyOwedInterest = _aprOffered.mul(_principalOwed).div(10000).mul(15).div(365);   // Fortnightly\n        }\n        else {\n            _currentlyOwedInterest = _aprOffered.mul(_principalOwed).div(10000).mul(15).div(730);   // Weekly\n        }\n        \n        if (_onBehalf) {\n            require(ERC20(_asset).transferFrom(msg.sender, address(this), _principalOwed.add(_currentlyOwedInterest)), \"Caller lacks funds, or contract lacks approval to transfer funding.\");\n        }\n        else {\n            require(Loans[_loanID].Borrower == msg.sender, \"To initiate a full payment, the caller must be the borrower.\");\n            require(ERC20(_asset).transferFrom(msg.sender, address(this), _principalOwed.add(_currentlyOwedInterest)), \"Borrower lacks funds, or contract lacks approval to transfer funding.\");\n        }\n        \n        // Distribute payment to Lenders by increasing draw allowance.\n        for (uint i=0; i < Loans[_loanID].Lenders_Count; i++) {\n            address _lender = Loans[_loanID].Active_Lender_Search[i];\n            uint _individualAmountLent = Loans[_loanID].Amount_Lent[_lender];\n            uint _individualPercentageExposure = _individualAmountLent.mul(100).div(Loans[_loanID].Notional_Supplied);\n            uint _individualAmountOwed = _individualPercentageExposure.mul(_principalOwed.add(_currentlyOwedInterest)).div(100);\n            Draw_Allowance[_asset][_lender] += _individualAmountOwed.mul(1000 - _fee).div(1000);\n            Draw_Allowance[_asset][Admin] += _individualAmountOwed.mul(_fee).div(1000);\n        }\n        \n        // Update Loan struct variables.\n        Loans[_loanID].Loan_Status = Status.Paid;\n        Loans[_loanID].Payments = 0;\n        Loans[_loanID].Loan_Info.Principal_Owed = 0;\n        Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = 0;\n        Loans[_loanID].Loan_Info.Next_Payment_Unix = 0;\n        \n        // Transfer back deposit.\n        if (Loans[_loanID].Loan_Info.Payments_Missed < Payments_Missed_Max[Loans[_loanID].Payment_Interval]) {\n            uint _amountTransferredIn = Loans[_loanID].Collateral_Supplied;\n            uint _percentageToReturn = Loans[_loanID].Notional_Supplied.mul(100).div(Loans[_loanID].Notional_Requested);\n            uint _amountToReturn = _amountTransferredIn.mul(_percentageToReturn).div(100);\n            if (_amountToReturn > 0) {\n                // ERC-20 Collateral\n                if (Loans[_loanID].Asset_Collateral != 0x0000000000000000000000000000000000000000) {\n                    require(ERC20(Loans[_loanID].Asset_Collateral).transfer(msg.sender, _amountToReturn));\n                }\n                // ETH Collateral\n                else {\n                    msg.sender.transfer(_amountToReturn);\n                }\n            }\n        }\n    \n        emit paymentMade(Loans[_loanID].Community_ID, _loanID, _principalOwed.add(_currentlyOwedInterest), _asset, msg.sender);\n    }\n    \n    // TODO: Check precision.\n    function claimLoanDeposit(uint _loanID) public nonReentrant {\n        require(Loans[_loanID].Loan_Info.Payments_Missed >= Payments_Missed_Max[Loans[_loanID].Payment_Interval], \"Can't claim this deposit, too many missed payments.\");\n        require(Loans[_loanID].Active_Lender[msg.sender] == true, \"You're not an active lender.\");\n        require(Loans[_loanID].Collateral_Claimed[msg.sender] == false, \"You have already claimed the deposit.\");\n        Loans[_loanID].Collateral_Claimed[msg.sender] = true;\n        uint _notionalSupplied = Loans[_loanID].Notional_Supplied;\n        uint _amountSupplied = Loans[_loanID].Amount_Lent[msg.sender];\n        uint _percentageToClaim = _amountSupplied.mul(100).div(_notionalSupplied);\n        uint _amountTransferredIn = Loans[_loanID].Collateral_Supplied;\n        // ERC-20 Collateral\n        if (Loans[_loanID].Asset_Collateral != 0x0000000000000000000000000000000000000000) {\n            require(ERC20(Loans[_loanID].Asset_Collateral).transfer(msg.sender, _amountTransferredIn.mul(_percentageToClaim).div(100)));\n        }\n        // ETH Collateral\n        else {\n            msg.sender.transfer(_amountTransferredIn.mul(_percentageToClaim).div(100));\n        }\n    }\n    \n    // Roll a loan with a missed payment, after a 5-day grace period. Next payment due: now + _paymentInterval, missed interest added onto next payment due.\n    function rollPayment(uint _loanID) public nonReentrant {\n        // 5-day grace period from when payment is missed before rollMonthlyPayment() can be called.\n        require(Loans[_loanID].Loan_Info.Next_Payment_Unix + 432000 < now, \"This payment date has not passed yet.\");\n        \n        // Add on additional interest to the next payment.\n        uint _daysInterest = now.sub(Loans[_loanID].Loan_Info.Next_Payment_Unix).div(86400);\n        uint _extraInterestPrincipal = Loans[_loanID].APR_Offered.add(1000).mul(Loans[_loanID].Loan_Info.Principal_Owed).div(10000).mul(_daysInterest).div(365);\n        Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment.add(_extraInterestPrincipal);\n        \n        // Increase next payment unix accordingly.\n        if (Loans[_loanID].Payment_Interval == 31104000) {\n            Loans[_loanID].Loan_Info.Next_Payment_Unix = now + 31104000;   // Annual\n        }\n        else if (Loans[_loanID].Payment_Interval == 15552000) {\n            Loans[_loanID].Loan_Info.Next_Payment_Unix = now + 15552000;   // Semi-annual\n        }\n        else if (Loans[_loanID].Payment_Interval == 7776000) {\n            Loans[_loanID].Loan_Info.Next_Payment_Unix = now + 7776000;   // Quarterly\n        }\n        else if (Loans[_loanID].Payment_Interval == 2592000) {\n            Loans[_loanID].Loan_Info.Next_Payment_Unix = now + 2592000;   // Monthly\n        }\n        else if (Loans[_loanID].Payment_Interval == 1296000) {\n            Loans[_loanID].Loan_Info.Next_Payment_Unix = now + 1296000;   // Fortnightly\n        }\n        else {\n            Loans[_loanID].Loan_Info.Next_Payment_Unix = now + 648000;   // Weekly\n        }\n        \n        // Increment payments missed.\n        Loans[_loanID].Loan_Info.Payments_Missed++;\n    }\n    \n    // Roll a payment, make payment simultaneously. This enables authorized payments, and also payments on behalf of the Borrower by an alternative wallet.\n    function rollPaymentMakePayment(uint _loanID, bool _onBehalf) public nonReentrant {\n        \n        // Require checks.\n        require(Loans[_loanID].Loan_Info.Next_Payment_Unix < now, \"This payment date has not passed yet.\");\n        require(Loans[_loanID].Payments > 0, \"This loan has already been repaid.\");\n        \n        // Pre-calculate additional interest to avoid stack-depth fix.\n        uint _daysInterest = now.sub(Loans[_loanID].Loan_Info.Next_Payment_Unix).div(86400);\n        uint _extraInterest = Loans[_loanID].APR_Offered.add(1000).mul(Loans[_loanID].Loan_Info.Principal_Owed).div(10000).mul(_daysInterest).div(365);\n        \n        // Store commonly used variables locally.\n        address _asset = Loans[_loanID].Asset_Request;\n        uint _fee = Loans[_loanID].Fee;\n        \n        // Transfer payment into contract.\n        uint _currentlyOwed = Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment;\n        uint _amountOwed = _currentlyOwed.add(_extraInterest);\n        \n        if (_onBehalf) {\n            require(ERC20(_asset).transferFrom(msg.sender, address(this), _amountOwed), \"Caller lacks funds or approval to make payment.\");\n        }\n        else {\n            require(ERC20(_asset).transferFrom(Loans[_loanID].Borrower, address(this), _amountOwed), \"Borrower lacks funds or approval to make payment.\");\n        }\n        \n        // Distribute payment to Lenders by increasing draw allowance.\n        for (uint i=0; i < Loans[_loanID].Lenders_Count; i++) {\n            address _lender = Loans[_loanID].Active_Lender_Search[i];\n            uint _individualAmountLent = Loans[_loanID].Amount_Lent[_lender];\n            uint _totalAmountLent = Loans[_loanID].Notional_Supplied;\n            uint _individualPercentageExposure = _individualAmountLent.mul(100).div(_totalAmountLent);\n            uint _individualAmountOwed = _individualPercentageExposure.mul(_amountOwed).div(100);\n            \n            Draw_Allowance[_asset][_lender] += _individualAmountOwed.mul(1000 - _fee).div(1000);\n            Draw_Allowance[_asset][Admin] += _individualAmountOwed.mul(_fee).div(1000);\n        }\n        \n        if (Loans[_loanID].Loan_Info.Payments_Started == false) {\n            Loans[_loanID].Loan_Info.Payments_Started = true;\n            Loans[_loanID].Loan_Status = Status.Active_Halted;\n            // Transfer back any additional liquidity deposited for loan not required.\n            if (Loans[_loanID].Notional_Supplied < Loans[_loanID].Notional_Requested) {\n                // Critical Error #1 - Fixed below with appropriate return calculations based on partial funding. Same code in haltLoanRequest(...) \n                uint _amountTransferredIn = Loans[_loanID].Collateral_Supplied;\n                uint _percentageToDeduct = Loans[_loanID].Notional_Supplied.mul(100).div(Loans[_loanID].Notional_Requested);\n                uint _amountToDeduct = _amountTransferredIn.mul(_percentageToDeduct).div(100);\n                uint _amountToReturn = _amountTransferredIn.sub(_amountToDeduct);\n                if (_amountToReturn > 0) {\n                    // ERC-20 Collateral\n                    if (Loans[_loanID].Asset_Collateral != 0x0000000000000000000000000000000000000000) {\n                        require(ERC20(Loans[_loanID].Asset_Collateral).transfer(Loans[_loanID].Borrower, _amountToReturn));\n                    }\n                    // ETH Collateral\n                    else {\n                        address payable _borrowerPayable = payable(Loans[_loanID].Borrower);\n                        _borrowerPayable.transfer(_amountToReturn);\n                    }\n                }\n            }\n        }\n        \n        // Decrement monthly payments.\n        Loans[_loanID].Payments--;\n        \n        // Calculate next payment, or close loan if payments remaining is 0.\n        if (Loans[_loanID].Payments > 1) {\n            // Interest only calculation for next payment ...\n            uint _aprOffered = Loans[_loanID].APR_Offered;\n            uint _principalOwed = Loans[_loanID].Loan_Info.Principal_Owed;\n            uint _interestOwed = 0;\n            if (Loans[_loanID].Payment_Interval == 31104000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(360).div(365);   // Annual\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _interestOwed;\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 31104000;\n            }\n            else if (Loans[_loanID].Payment_Interval == 15552000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(180).div(365);   // Semi-annual\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _interestOwed;\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 15552000;\n            }\n            else if (Loans[_loanID].Payment_Interval == 7776000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(90).div(365);   // Quarterly\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _interestOwed;\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 7776000;\n            }\n            else if (Loans[_loanID].Payment_Interval == 2592000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(30).div(365);   // Monthly\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _interestOwed;\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 2592000;\n            }\n            else if (Loans[_loanID].Payment_Interval == 1296000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(15).div(365);   // Fortnightly\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _interestOwed;\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 1296000;\n            }\n            else {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(15).div(730);   // Weekly\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _interestOwed;\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 648000;\n            }\n        }\n        else if (Loans[_loanID].Payments == 1) {\n            // Calculations for final payment ...\n            uint _aprOffered = Loans[_loanID].APR_Offered;\n            uint _principalOwed = Loans[_loanID].Loan_Info.Principal_Owed;\n            uint _interestOwed = 0;\n            if (Loans[_loanID].Payment_Interval == 31104000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(360).div(365);   // Annual\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _principalOwed.add(_interestOwed);\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 31104000;\n            }\n            else if (Loans[_loanID].Payment_Interval == 15552000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(180).div(365);   // Semi-annual\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _principalOwed.add(_interestOwed);\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 15552000;\n            }\n            else if (Loans[_loanID].Payment_Interval == 7776000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(90).div(365);   // Quarterly\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _principalOwed.add(_interestOwed);\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 7776000;\n            }\n            else if (Loans[_loanID].Payment_Interval == 2592000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(30).div(365);   // Monthly\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _principalOwed.add(_interestOwed);\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 2592000;\n            }\n            else if (Loans[_loanID].Payment_Interval == 1296000) {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(15).div(365);   // Fortnightly\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _principalOwed.add(_interestOwed);\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 1296000;\n            }\n            else {\n                _interestOwed = _aprOffered.mul(_principalOwed).div(10000).mul(15).div(730);   // Weekly\n                Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = _principalOwed.add(_interestOwed);\n                Loans[_loanID].Loan_Info.Next_Payment_Unix += 648000;\n            }\n        }\n        else {\n            // Payments complete.\n            Loans[_loanID].Loan_Status = Status.Paid;\n            Loans[_loanID].Loan_Info.Principal_Owed = 0;\n            Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment = 0;\n            Loans[_loanID].Loan_Info.Next_Payment_Unix = 0;\n            \n            // Return the borrower's initial deposit back (if any).\n            if (Loans[_loanID].Loan_Info.Payments_Missed < Payments_Missed_Max[Loans[_loanID].Payment_Interval]) { \n                uint _amountTransferredIn = Loans[_loanID].Collateral_Supplied;\n                uint _percentageToReturn = Loans[_loanID].Notional_Supplied.mul(100).div(Loans[_loanID].Notional_Requested);\n                uint _amountToReturn = _amountTransferredIn.mul(_percentageToReturn).div(100);\n                if (_amountToReturn > 0) {\n                    // ERC-20 Collateral\n                    if (Loans[_loanID].Asset_Collateral != 0x0000000000000000000000000000000000000000) {\n                        require(ERC20(Loans[_loanID].Asset_Collateral).transfer(Loans[_loanID].Borrower, _amountToReturn));\n                    }\n                    // ETH Collateral\n                    else {\n                        address payable _borrowerPayable = payable(Loans[_loanID].Borrower);\n                        _borrowerPayable.transfer(_amountToReturn);\n                    }\n                }\n            }\n        }\n        \n        emit paymentMade(Loans[_loanID].Community_ID, _loanID, _amountOwed, _asset, Loans[_loanID].Borrower);\n    }\n    \n    function withdrawAllowance(address _asset) public nonReentrant {\n        require(ERC20(_asset).transfer(msg.sender, Draw_Allowance[_asset][msg.sender]), \"Transfer unsuccessful, critical error.\");\n        Draw_Allowance[_asset][msg.sender] = 0;\n    }\n    \n    function loanStatus(uint _loanID) public view returns(Status, bool, bool) {\n        return (\n            Loans[_loanID].Loan_Status, \n            Loans[_loanID].Collateral_Claimed[msg.sender],\n            Loans[_loanID].Active_Lender[msg.sender]\n        );\n    }\n    \n    function loanInformation(uint _loanID) public view returns(uint, uint,uint, uint, uint, uint) {\n        uint _paymentsRemaining = Loans[_loanID].Payments;\n        uint _supplied = Loans[_loanID].Notional_Supplied;\n        uint _principalOwed = Loans[_loanID].Loan_Info.Principal_Owed;\n        uint _nextPaymentUnix = Loans[_loanID].Loan_Info.Next_Payment_Unix;\n        uint _amountOwedNext = Loans[_loanID].Loan_Info.Amount_Owed_Next_Payment;\n        uint _paymentsMissed = Loans[_loanID].Loan_Info.Payments_Missed;\n        return (_paymentsRemaining, _supplied, _principalOwed, _nextPaymentUnix, _amountOwedNext, _paymentsMissed);\n    }\n    \n    function allowanceView(address _lender) public view returns(uint, uint) {\n        uint _daiAllowance = Draw_Allowance[0x6B175474E89094C44Da98b954EedeAC495271d0F][_lender];\n        uint _usdcAllowance = Draw_Allowance[0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48][_lender];\n        return (_daiAllowance, _usdcAllowance);\n    }\n    \n    function allowanceView(address _lender, address _asset) public view returns(uint) {\n        uint _allowance = Draw_Allowance[_asset][_lender];\n        return _allowance;\n    }\n}\n\nabstract contract ERC20 {\n    function totalSupply() public virtual view returns (uint);\n    function balanceOf(address tokenOwner) public virtual view returns (uint balance);\n    function allowance(address tokenOwner, address spender) public virtual view returns (uint remaining);\n    function transfer(address to, uint tokens) public virtual returns (bool success);\n    function approve(address spender, uint tokens) public virtual returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public virtual returns (bool success);\n}\n\nabstract contract Whitelist {\n    function getStatus(uint _communityID, address _member) public virtual view returns(bool success);\n}"
    }
  }
}