{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "mydanew.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\nstruct StakeConfig {\n    uint256 collateral;\n    uint256 reward;\n    uint256 lockTime;\n    uint256 activeCollateral;  \n    uint256 rewPaid; \n}\n\nstruct GeneralDetails {\n    StakeConfig t1;\n    StakeConfig t2;\n    StakeConfig t3;\n    \n    string _name;\n    string _symbol;\n    uint8 _decimals;\n    uint256 _totalSupply;\n    bool _isPaused;\n    uint256 _totalStake;   \n    uint256 _activeStakers;\n    uint256 _refPaid;\n    uint256 _totalRewardPaid;\n    \n    address _validatorAdd;\n    string _validatorApi;\n    uint256 _maxSupply;\n    uint256 _maxTxLimit;\n    uint256 _rewardDuration;\n    uint256 _refCom;\n    uint256 _voteApproveRate;    \n    uint256 _propDuration;\n    uint256 _changeDate;\n    uint256 _swapOut;\n    uint256 _swapIn;\n    uint256 _supplyTime;\n    uint256 _otherSupply;\n    address _stakeAddress;\n}\n\nstruct StakeDetails {\n    uint256 date;  \n    uint256 rewDate;\n    uint256 collateral;\n    uint256 pendingRew;\n    uint256 activeRew;\n    uint256 refRew;\n    uint256 rewPaid;\n}\n\nstruct UserDetails {\n    StakeDetails t1;\n    StakeDetails t2;\n    StakeDetails t3;\n    \n    uint256 _balances;\n    uint256 voteStatus;\n    uint256 propStatus;\n    uint256 stakeNonce;\n    address refAdd;\n    uint256 refPaid;\n    uint256 refCount;\n    address[] refList;\n} \n\nstruct VoteData {\n    address account;\n    uint256 cycle;\n    uint256 startDate;\n    uint256 endDate;\n    uint256 value;\n    uint256 voteCount;\n    string info;\n    uint256 status;\n}\n\nabstract contract Context {\n    \n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    \n}\n\ninterface AFTS {\n    \n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);      \n\n    function isPaused() external view returns (bool);\n    \n    function generalDetails() external view returns(GeneralDetails memory);\n\n    function userDetails(address account) external view returns(UserDetails memory);  \n    \n    function voteCycleDetails(uint256 cycle, string memory config) external view returns (VoteData memory);\n    \n    function swapInfo(uint256 nonceOut, bytes32 txid, uint256 method, address account) external view returns (uint256);\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    \n    function burn(uint256 amount, uint256 swapNonce, uint256 chainId) external returns (bool);\n    \n    function transferMulti(address[] memory to, uint256[] memory amount) external returns (bool);  \n    \n    function transferMultiFrom(address sender, address[] memory to, uint256[] memory amount) external returns (bool);    \n    \n    function stake(uint256[] memory info, address refAdd, bytes memory sig) external returns (bool);\n    \n    function propose(string memory config, string memory info, uint256 value, address account) external returns (bool);\n    \n    function vote(string memory config) external returns (bool);\n    \n    function mint(bytes32 txid, uint256 swapNonce, uint256 amount, uint256 fees, uint256 fromId, bytes memory sig) external returns (bool);   \n    \n    function protocolUpdate(uint256[] memory newConfig, address account, address stakeAddress, string memory info, uint256 status) external returns (bool);\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);    \n    \n    event Proposer(address indexed from, string config, uint256 value, address account);\n    \n    event Voter(address indexed from, string config);    \n    \n}\n\ncontract MYDA is Context, AFTS {\n    \n    GeneralDetails _general;\n    \n    mapping(string =>  uint256) private _genConfig;\n    \n    mapping(address =>  UserDetails) private _user;\n    \n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    mapping(uint256 =>  StakeConfig) _stakeConfig;\n    \n    mapping(address =>  mapping(uint256 =>  StakeDetails)) private _stake;\n    \n    mapping(address =>  mapping(bytes32 => uint256)) private _swapIn;\n    \n    mapping(address =>  mapping(uint256 => uint256)) private _swapOut;\n    \n    mapping(address =>  mapping(uint256 =>  mapping(string =>  uint256))) private _userVote;\n    \n    mapping(uint256 =>  mapping(string =>  VoteData)) private _vote;\n    \n    mapping(string =>  uint256) private _voteCycle;\n    \n    constructor () {\n        _general._name = \"MYDA\";\n        _general._symbol = \"MYDA\";\n        _general._decimals = 18;\n        _general._validatorAdd = _msgSender();\n        _general._validatorApi = \"https://validator.mydacoin.com/\";\n        //_general._totalSupply = 100000000*1e18;\n        _genConfig[\"maxSupply\"] = 100000000*1e18;\n        _genConfig[\"maxTxLimit\"] = 200;\n        _genConfig[\"rewardDuration\"] = 86400;\n        _genConfig[\"refCom\"] = 10;  \n        _genConfig[\"voteApproveRate\"] = 70; \n        _genConfig[\"propDuration\"] = 2592000;\n        _stakeConfig[1].collateral = 5000*1e18;\n        _stakeConfig[2].collateral = 10000*1e18;\n        _stakeConfig[3].collateral = 20000*1e18;\n        _stakeConfig[1].lockTime = 2592000;\n        _stakeConfig[2].lockTime = 7776000;\n        _stakeConfig[3].lockTime = 15552000;\n        _stakeConfig[1].reward = 8.25*1e18;\n        _stakeConfig[2].reward = 33*1e18;\n        _stakeConfig[3].reward = 99*1e18;\n        _general._isPaused = false;\n        _general._stakeAddress = 0x7F7512BDcC61861DfEC5ad7C124899c72fC86FD6;\n        //_transfer(address(0), _general._stakeAddress, 100000000*1e18, 0);\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _general._name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _general._symbol;\n    }\n\n    function decimals() public view virtual override returns (uint256) {\n        return _general._decimals;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _general._totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _user[account]._balances;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    \n    function isPaused() public view virtual override returns (bool) {\n        return _general._isPaused;\n    }   \n\n    function generalDetails() public view virtual override returns(GeneralDetails memory){\n        GeneralDetails memory gendet = _general;\n        gendet.t1 = _stakeConfig[1];\n        gendet.t2 = _stakeConfig[2];\n        gendet.t3 = _stakeConfig[3];\n        gendet._maxSupply = _genConfig[\"maxSupply\"];\n        gendet._maxTxLimit = _genConfig[\"maxTxLimit\"];\n        gendet._rewardDuration = _genConfig[\"rewardDuration\"];\n        gendet._refCom = _genConfig[\"refCom\"];  \n        gendet._voteApproveRate = _genConfig[\"voteApproveRate\"]; \n        gendet._propDuration = _genConfig[\"propDuration\"];\n        return gendet;\n    }\n    \n    function userDetails(address account) public view virtual override returns(UserDetails memory){\n        UserDetails memory userdet = _user[account];\n        userdet.t1 = _stake[account][1];\n        userdet.t2 = _stake[account][2];\n        userdet.t3 = _stake[account][3];\n        return userdet;\n    }  \n  \n    function voteCycleDetails(uint256 cycle, string memory config) public view virtual override returns (VoteData memory) {\n        \n        if(cycle == 0){\n            cycle = _voteCycle[config];\n        }\n        \n        return _vote[cycle][config];\n    }  \n    \n    function swapInfo(uint256 nonceOut, bytes32 txid, uint256 method, address account) public view virtual override returns (uint256) {\n        \n        if(method == 0){\n            return _swapOut[account][nonceOut];\n        } else {\n            return _swapIn[account][txid];\n        }\n    }    \n\n    function _transfer(address sender, address recipient, uint256 amount, uint8 method) internal virtual {\n        require(!_general._isPaused, \"Contract is Paused\");\n        \n        if(method == 1){\n            require(sender != address(0), \"from zero address\");\n            require(recipient != address(0), \"to zero address\");\n        }\n        \n        if(sender != address(0)){\n            require(_user[sender]._balances >= amount, \"amount exceeds balance\");\n            _user[sender]._balances -= amount;\n        }\n        \n        if(recipient != address(0)){\n            _user[recipient]._balances += amount;\n        }\n        \n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(!_general._isPaused, \"Contract is Paused\");\n        require(owner != address(0), \"from zero address\");\n        require(spender != address(0), \"to zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {     \n        _transfer(_msgSender(), recipient, amount, 1);\n        return true;\n    }\n    \n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        require(_allowances[sender][_msgSender()] >= amount, \"amount exceeds allowance\");\n        _transfer(sender, recipient, amount, 1);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\n        return true;\n    }\n    \n    function _transferMulti(address sender, address[] memory to, uint256[] memory amount, uint8 method, address spender) internal virtual {\n        require(sender != address(0), \"from zero address\");\n\t\trequire(_genConfig[\"maxTxLimit\"] >= to.length, \"greater than _maxTxLimit\");        \n\t\trequire(to.length == amount.length, \"array length not equal\");\n\t\tuint256 sum_;\n\t\t\n        for (uint8 g; g < to.length; g++) {\n            require(to[g] != address(0), \"to zero address\");\n            sum_ += amount[g];            \n        }\n        \n        require(_user[sender]._balances >= sum_, \"amount exceeds balance\");\n        \n        if(method == 1){\n            require(_allowances[sender][spender] >= sum_, \"amount exceeds allowance\");\n            _approve(sender, spender, _allowances[sender][_msgSender()] - sum_);            \n        }\n        \n\t\tfor (uint8 i; i < to.length; i++) {\n\t\t    _transfer(sender, to[i], amount[i], 0);\n\t\t}        \n    }   \n   \n\tfunction transferMulti(address[] memory to, uint256[] memory amount) public virtual override returns (bool) {\n\t\t_transferMulti(_msgSender(), to, amount, 0, address(0));\n        return true;\n\t}\n\t\n\tfunction transferMultiFrom(address sender, address[] memory to, uint256[] memory amount) public virtual override returns (bool) {\n\t\t_transferMulti(sender, to, amount, 1, _msgSender());\n        return true;\n\t}  \n\t\n    function stake(uint256[] memory info, address refAdd, bytes memory sig) public virtual override returns (bool) {//0-tier,1-qty,2-method,3-otherSupply\n        _sigValidate(sig, keccak256(abi.encodePacked(_msgSender(), info[0], info[1], info[2], info[3], block.chainid, _user[_msgSender()].stakeNonce + 1, true)), _general._validatorAdd);\n        _user[_msgSender()].stakeNonce += 1;\n        if(_general._supplyTime < block.timestamp){\n            _general._supplyTime = block.timestamp;\n            _general._otherSupply = info[3];\n        }\n        _stakeProcess(_msgSender(), info[0], info[1], refAdd, info[2]);\n        return true;\n    }  \n    \n    function _stakeProcess(address recipient, uint256 tier, uint256 qty, address refAdd, uint256 method) internal virtual {\n        require(!_general._isPaused, \"Contract is Paused\");\n        require(recipient != address(0), \"from zero address\");\n        require(tier > 0 && tier < 4, \"Invalid Tier\");\n        require(method >= 0 && method < 4, \"Invalid Method\");\n        \n        if(method >=0 && method < 2){\n            require(qty > 0, \"Invalid Qty\");\n        }\n        \n        uint256 stakeReward;\n        uint256 collateral;\n        uint256 tempReward;\n        uint256 diff;\n        uint256 refRew;\n        collateral = _stake[recipient][tier].collateral;\n        refRew = _stake[recipient][tier].refRew;\n        \n        if(_user[recipient].refAdd == address(0) && refAdd != address(0) && refAdd != recipient){\n            _user[recipient].refAdd = refAdd;\n            _user[refAdd].refList.push(recipient);\n            _user[refAdd].refCount += 1;\n        }\n        \n        diff = (block.timestamp - _stake[recipient][tier].rewDate) / _genConfig[\"rewardDuration\"];\n        stakeReward = (((diff * _stakeConfig[tier].reward) * collateral) / _stakeConfig[tier].collateral) + _stake[recipient][tier].pendingRew;  \n        \n        if(method < 2){\n            \n            if(method == 0){\n                require(!(_stake[_msgSender()][tier].collateral > 0), \"Already Staking\");\n            } else {\n                require(_stake[_msgSender()][tier].collateral > 0, \"Staking Inactive\");\n            }\n            \n            _transfer(recipient, address(0), (_stakeConfig[tier].collateral * qty), 0);\n            tempReward = ((_stakeConfig[tier].lockTime / _genConfig[\"rewardDuration\"]) * _stakeConfig[tier].reward) * qty;\n            refRew = ((tempReward * _genConfig[\"refCom\"]) / 100);\n            \n            if(_user[_general._stakeAddress]._balances < (tempReward)){\n                require(((_general._totalSupply + _general._otherSupply) + tempReward) <= _genConfig[\"maxSupply\"], \"Exceeds maxSupply\");\n            }\n            \n            if(_user[recipient].refAdd != address(0)){\n                if(_user[_general._stakeAddress]._balances < (tempReward + refRew)){\n                    require(((_general._totalSupply + _general._otherSupply) + tempReward + refRew) <= _genConfig[\"maxSupply\"], \"Exceeds maxSupply\");\n                }\n                _stake[_user[recipient].refAdd][tier].refRew += refRew;\n                _user[_user[recipient].refAdd].refPaid += refRew;\n                _general._refPaid += refRew;\n            }  \n            \n            if(method == 1){\n                _stake[recipient][tier].pendingRew += stakeReward;\n            }\n            \n            _stake[recipient][tier].date = block.timestamp;\n            _stake[recipient][tier].rewDate = block.timestamp;\n            _stake[recipient][tier].collateral += (_stakeConfig[tier].collateral * qty);\n            _stakeConfig[tier].activeCollateral += (_stakeConfig[tier].collateral * qty);\n            _user[recipient].propStatus = (tier == 3)?1:_user[recipient].propStatus;\n            _general._totalStake += (_stakeConfig[tier].collateral * qty);\n            \n            if(_user[recipient].voteStatus == 0){\n                _user[recipient].voteStatus = 1;\n                _general._activeStakers += 1;\n            }   \n            \n        } else {\n            require(block.timestamp >= (_stake[_msgSender()][tier].date + _stakeConfig[tier].lockTime), \"Stake not matured\");\n            require(_stake[_msgSender()][tier].collateral > 0, \"Staking Inactive\");\n                \n            if(_user[_general._stakeAddress]._balances < (stakeReward + refRew)){\n                if(_user[_general._stakeAddress]._balances > 0){\n                    stakeReward = _user[_general._stakeAddress]._balances;\n                } else { \n                    stakeReward = 0;\n                }                                \n            } else {\n                stakeReward = stakeReward + refRew;\n            }\n            \n            if(stakeReward > 0){\n                _transfer(_general._stakeAddress, recipient, stakeReward, 1);\n            } else {\n                stakeReward = (((diff * _stakeConfig[tier].reward) * collateral) / _stakeConfig[tier].collateral) + _stake[recipient][tier].pendingRew;\n                \n                if(((_general._totalSupply + _general._otherSupply)) < _general._maxSupply){\n                    if(((_general._totalSupply + _general._otherSupply) + stakeReward + refRew) > _genConfig[\"maxSupply\"]){\n                        if((_genConfig[\"maxSupply\"] - (_general._totalSupply + _general._otherSupply)) > 0){\n                            stakeReward = _genConfig[\"maxSupply\"] - (_general._totalSupply + _general._otherSupply);\n                        } else { \n                            stakeReward = 0;\n                        }\n                    } else {\n                        stakeReward = stakeReward + refRew;\n                    }     \n                    \n                    if(stakeReward > 0){\n                        _general._totalSupply += stakeReward;\n                        _transfer(address(0), recipient, stakeReward, 0);\n                    }\n                }\n\n            }\n\n            if(method == 2){\n                _transfer(address(0), recipient, collateral, 0);\n                _stake[recipient][tier].collateral = 0;\n                _stake[recipient][tier].date = 0;\n                _stake[recipient][tier].rewDate = 0;\n                _general._totalStake -= collateral;\n                _stakeConfig[tier].activeCollateral -= collateral;\n                _user[recipient].propStatus = (tier == 3)?0:_user[recipient].propStatus;  \n                if(_stake[recipient][1].collateral == 0 && _stake[recipient][2].collateral == 0 && _stake[recipient][3].collateral == 0){\n                    _user[recipient].voteStatus = 0;\n                    _general._activeStakers -= 1;\n                }\n            } else {\n                _stake[recipient][tier].rewDate = block.timestamp;\n            }\n            \n            _stake[recipient][tier].rewPaid += stakeReward;\n            _stakeConfig[tier].rewPaid += stakeReward;\n            _stake[recipient][tier].refRew = 0;\n            _stake[recipient][tier].pendingRew = 0;\n            _general._totalRewardPaid += stakeReward;             \n        }\n    }        \n\n    function propose(string memory config, string memory info, uint256 value, address account) public virtual override returns (bool) {\n        _propose(_msgSender(), config, info, value, account);\n        return true;\n    }\n    \n    function _propose(address sender, string memory config, string memory info, uint256 value, address account) internal {\n        require(_user[sender].propStatus == 1 && _general._activeStakers >= 100, \"Can't Propose\");\n        uint256 date = block.timestamp;\n        uint256 cycle = _voteCycle[config];\n        require((date - _vote[cycle][config].startDate) > _genConfig[\"propDuration\"], \"Old Active\");\n        _vote[cycle][config].status = 3;\n        _voteCycle[config] += 1;\n        cycle = _voteCycle[config];\n        _vote[cycle][config].cycle = _voteCycle[config];\n        _vote[cycle][config].startDate = date; \n        \n        if(keccak256(bytes(config)) == keccak256(bytes(\"validatorAdd\"))){\n            _vote[cycle][config].account = account;\n        } else {\n            _vote[cycle][config].value = value; \n        }  \n        \n        _vote[cycle][config].status = 1;\n        _vote[cycle][config].info = info;\n        emit Proposer(sender, config, value, account);        \n    }\n\n    function vote(string memory config) public virtual override returns (bool) {\n        _voteProcess(_msgSender(), config);\n        return true;\n    } \n    \n    function _voteProcess(address sender, string memory config) internal {\n        require(_user[sender].voteStatus == 1, \"Can't Vote\");\n        uint256 date = block.timestamp;\n        uint256 cycle = _voteCycle[config];\n        require(_vote[cycle][config].status == 1, \"Voting Finished\");\n        require(_userVote[sender][cycle][config] == 0, \"Already Voted\");\n        _userVote[sender][cycle][config] = 1;\n        _vote[cycle][config].voteCount += 1;\n        \n        if(_vote[cycle][config].voteCount >= ((_general._activeStakers * _genConfig[\"voteApproveRate\"]) / 100)){\n            \n            if(keccak256(bytes(config)) == keccak256(bytes(\"maxSupply\"))){\n                require(keccak256(bytes(config)) == keccak256(bytes(\"maxSupply\")) && _general._totalSupply < _vote[cycle][config].value, \"less than totalSupply\");\n            }   \n            \n            _vote[cycle][config].status = 2;\n            _vote[cycle][config].endDate = date;\n            _general._changeDate = date;\n            \n            if(keccak256(bytes(config)) == keccak256(bytes(\"t1Collateral\"))){\n                _stakeConfig[1].collateral = _vote[cycle][config].value;\n            } else if(keccak256(bytes(config)) == keccak256(bytes(\"t2Collateral\"))){\n                _stakeConfig[2].collateral = _vote[cycle][config].value;\n            } else if(keccak256(bytes(config)) == keccak256(bytes(\"t3Collateral\"))){\n                _stakeConfig[3].collateral = _vote[cycle][config].value;\n            } else if(keccak256(bytes(config)) == keccak256(bytes(\"t1Reward\"))){\n                _stakeConfig[1].reward = _vote[cycle][config].value;\n            } else if(keccak256(bytes(config)) == keccak256(bytes(\"t2Reward\"))){\n                _stakeConfig[2].reward = _vote[cycle][config].value;\n            } else if(keccak256(bytes(config)) == keccak256(bytes(\"t3Reward\"))){\n                _stakeConfig[3].reward = _vote[cycle][config].value;\n            } else if(keccak256(bytes(config)) == keccak256(bytes(\"t1LockTime\"))){\n                _stakeConfig[1].lockTime = _vote[cycle][config].value;\n            } else if(keccak256(bytes(config)) == keccak256(bytes(\"t2LockTime\"))){\n                _stakeConfig[2].lockTime = _vote[cycle][config].value;\n            } else if(keccak256(bytes(config)) == keccak256(bytes(\"t3LockTime\"))){\n                _stakeConfig[3].lockTime = _vote[cycle][config].value;\n            } else if(keccak256(bytes(config)) == keccak256(bytes(\"validatorAdd\"))){\n                _general._validatorAdd = _vote[cycle][config].account;\n                _general._validatorApi = _vote[cycle][config].info;\n            } else {\n                _genConfig[config] = _vote[_voteCycle[config]][config].value;\n            }           \n        }        \n        emit Voter(sender, config);        \n    }\n\n    function _splitSignature(bytes memory sig) internal pure returns (uint8, bytes32, bytes32) {\n        require(sig.length == 65);\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n       return (v, r, s);\n    }       \n   \n    function _sigValidate(bytes memory sig, bytes32 hash, address account) internal pure {\n        (uint8 v, bytes32 r, bytes32 s) = _splitSignature(sig);\n        require(ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)), v, r, s) == account, \"Not Authorized\");\n    }\n\n    function burn(uint256 amount, uint256 swapNonce, uint256 chainId) public virtual override returns (bool) {\n        _burn(_msgSender(), amount, swapNonce, chainId);\n        return true;\n    }\n\n    function _burn(address sender, uint256 amount, uint256 swapNonce, uint256 chainId) internal {\n        _transfer(sender, address(0), amount, 0);\n        \n        if(swapNonce > 0){\n            _swapOut[sender][swapNonce] = chainId;\n            _general._swapOut += amount;\n        }\n        \n        _general._totalSupply -= amount;\n    }    \n    \n    function mint(bytes32 txid, uint256 swapNonce, uint256 amount, uint256 fees, uint256 fromId, bytes memory sig) public virtual override returns (bool) {\n        _mint(_msgSender(), txid, swapNonce, amount, fees, fromId, sig);\n        return true;\n    }  \n    \n    function _mint(address sender, bytes32 txid, uint256 swapNonce, uint256 amount, uint256 fees, uint256 fromId, bytes memory sig) internal {\n        require(!_general._isPaused, \"Contract is Paused\");\n        require(_swapIn[sender][txid] == 0, \"Already Swapped\");\n        _sigValidate(sig, keccak256(abi.encodePacked(sender, txid, swapNonce, amount, fees, fromId, block.chainid, true)), _general._validatorAdd);\n        _transfer(address(0), sender, amount - fees, 0);\n        _transfer(address(0), _general._validatorAdd, fees, 0);\n        _general._totalSupply += amount;\n        _swapIn[sender][txid] = swapNonce;\n        _general._swapIn += amount;\n    }    \n    \n    function protocolUpdate(uint256[] memory newConfig, address account, address stakeAddress, string memory info, uint256 status) public virtual override returns (bool) {\n        require(_msgSender() == _general._validatorAdd, \"Only Validator Allowed\");\n        \n        if(newConfig.length == 16){\n            _genConfig[\"maxSupply\"] = newConfig[0];\n            _genConfig[\"maxTxLimit\"] = newConfig[1];\n            _genConfig[\"rewardDuration\"] = newConfig[2];\n            _genConfig[\"refCom\"] = newConfig[3];  \n            _genConfig[\"voteApproveRate\"] = newConfig[4]; \n            _genConfig[\"propDuration\"] = newConfig[5];\n            _stakeConfig[1].collateral = newConfig[6];\n            _stakeConfig[1].lockTime = newConfig[7];\n            _stakeConfig[1].reward = newConfig[8];\n            _stakeConfig[2].collateral = newConfig[9];\n            _stakeConfig[2].lockTime = newConfig[10];\n            _stakeConfig[2].reward = newConfig[11];\n            _stakeConfig[3].collateral = newConfig[12];\n            _stakeConfig[3].lockTime = newConfig[13];\n            _stakeConfig[3].reward = newConfig[14];\n            _general._changeDate = newConfig[15];\n        }\n        \n        if(account != address(0)){\n           _general._validatorAdd = account;\n           _general._validatorApi = info;\n        }\n        \n        if(stakeAddress != address(0)){\n           _general._stakeAddress = stakeAddress;\n        }\n        \n        if(status > 0){\n            _general._isPaused = (status == 1)?true:false;\n        }\n        \n        return true;\n    } \n\n}"
    }
  }
}