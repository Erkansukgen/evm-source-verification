{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/schelling.sol":{"content":"pragma solidity >=0.4.22 <0.7.0;\n// Author: Pavol Travnik\ncontract Arbitrust {\n    address[] public arbitrators;\n    uint arbitratorsLength;\n    address arbitrustAccount;\n    uint fees;\n    bytes32[] public actionsList;\n    uint public actionsCount;\n    struct Action {\n        bool exists;\n        bytes32 hash;\n        uint blockNumber;\n        address payable plaintiff;\n        address defendant;\n        address arbitrator;\n        bool voted;\n        bool vote;\n        string[] ipfs;\n        uint ipfsLength;\n    }\n    struct ActionBook {\n        bool exists;\n        bytes32[] bookHashesPlaintiff;\n        bytes32[] bookHashesDefendant;\n        bytes32[] bookHashesArbitrator;\n        uint bookHashesPlaintiffLength;\n        uint bookHashesDefendantLength;\n        uint bookHashesArbitratorLength;\n    }\n    mapping(bytes32 => Action) public actions;\n    mapping(address => ActionBook) public actionsBook;\n\n    constructor() public {\n        arbitrators = [\n            0x8bc74ff2860270BC3305eFC38F88dce4C15E53A1,\n            0x00e64163B622490a023AdB804D6c1AdF16F65D86,\n            0x2d6ECCf5A635064135579b128E75D68eEC204b16\n        ];\n        arbitrustAccount = 0x8bc74ff2860270BC3305eFC38F88dce4C15E53A1;\n        arbitratorsLength = arbitrators.length;\n    }\n\n    event Deposit(\n        address indexed _from,\n        uint _value\n    );\n    event Voted(\n        bytes32 _hashAction,\n        bool _vote\n    );\n\n    function createAction(bytes32 _hashAction, address _defendant) public payable {\n        require(actions[_hashAction].exists == false, \"Action exists.\");\n        require(msg.value >= 5000000000000000, \"Fee is too low.\");\n        actionsCount++;\n        actionsList.push(_hashAction);\n        actions[_hashAction].exists = true;\n        actions[_hashAction].blockNumber = block.number;\n        actions[_hashAction].plaintiff = msg.sender;\n        actions[_hashAction].defendant = _defendant;\n        actions[_hashAction].hash = _hashAction;\n        actionsBook[msg.sender].exists = true;\n        actionsBook[msg.sender].bookHashesPlaintiff.push(_hashAction);\n        actionsBook[msg.sender].bookHashesPlaintiffLength++;\n        actionsBook[_defendant].exists = true;\n        actionsBook[_defendant].bookHashesDefendant.push(_hashAction);\n        actionsBook[_defendant].bookHashesDefendantLength++;\n        fees += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function bookHashesPlaintiff(address _address) public view returns(bytes32[] memory){\n        return actionsBook[_address].bookHashesPlaintiff;\n    }\n\n    function bookHashesDefendant(address _address) public view returns(bytes32[] memory){\n        return actionsBook[_address].bookHashesDefendant;\n    }\n\n    function bookHashesArbitrator(address _address) public view returns(bytes32[] memory){\n        return actionsBook[_address].bookHashesArbitrator;\n    }\n\n    function vote(bytes32 _hashAction, bool _vote) public {\n        require(actions[_hashAction].exists == true, \"Action should exist.\");\n        require(actions[_hashAction].voted == false, \"Vote hase been done.\");\n        require(msg.sender == actions[_hashAction].arbitrator, \"You are not selected arbiter.\");\n        actions[_hashAction].vote = _vote;\n        actions[_hashAction].voted = true;\n        emit Voted(_hashAction,_vote);\n    }\n\n    function selectedArbiter(bytes32 _hashAction) public view returns (address) {\n        uint blockNum = actions[_hashAction].blockNumber + 1;\n        require((blockNum) < block.number, \"Wait for other blocks.\");\n        return arbitrators[(uint(blockhash(blockNum)) % arbitratorsLength)];\n    }\n\n    function submitAction(bytes32 _hashAction, string memory _ipfsHash) public {\n        require(actions[_hashAction].exists == true, \"Contract doesn't exist.\");\n        require((actions[_hashAction].plaintiff == msg.sender), \"Only plaintiff can submit the action.\");\n        require(getDocumentLength(_hashAction) == 0, \"Action has to be submitted.\");\n        address selected = selectedArbiter(_hashAction);\n        actionsBook[selected].exists = true;\n        actionsBook[selected].bookHashesArbitrator.push(_hashAction);\n        actionsBook[selected].bookHashesArbitratorLength++;\n        actions[_hashAction].arbitrator = selected;\n        actions[_hashAction].ipfs.push(_ipfsHash);\n        actions[_hashAction].ipfsLength++;\n    }\n\n    function sendDocument(bytes32 _hashAction, string memory _ipfsHash) public {\n        require(actions[_hashAction].exists == true, \"Contract doesn't exist.\");\n        require((actions[_hashAction].plaintiff == msg.sender || actions[_hashAction].defendant == msg.sender), \"Only party can submit a document.\");\n        require(getDocumentLength(_hashAction) > 0, \"Action has to be submitted.\");\n        actions[_hashAction].ipfs.push(_ipfsHash);\n        actions[_hashAction].ipfsLength++;\n    }\n\n    function getDocument(bytes32 _hashAction, uint _order) public view returns(string memory) {\n        require(actions[_hashAction].exists == true, \"Contract doesn't exist.\");\n        return actions[_hashAction].ipfs[_order];\n    }\n\n    function getDocumentLength(bytes32 _hashAction) public view returns(uint) {\n        require(actions[_hashAction].exists == true, \"Contract doesn't exist.\");\n        return actions[_hashAction].ipfsLength;\n    }\n\n    function transfer(address payable _address, uint _fee) public {\n        require(arbitrustAccount == msg.sender, \"Only owner can send coins from contract.\");\n        _address.transfer(_fee);\n        fees -= _fee;\n    }\n\n    function getBalance() public view returns(uint) {\n        require(arbitrustAccount == msg.sender, \"Only owner can see fees.\");\n        return fees;\n    }\n}"}}}