{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ETHStaking.sol":{"content":"pragma solidity ^0.6.0;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n}\n\ninterface IEth2 {\n    function mint(address account, uint256 amount) external;\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract EthStaking {\n    using SafeMath for uint256;\n\n    address payable private _admin;\n    address private _contr;\n    address private _developer;\n\n    bool private _isPaused;\n    mapping(address => bool) private _isPausedAddress;\n\n    uint256 private constant _minimumEther = 0.01 ether;\n    uint256 _tierAmount = 32 * 1000000000000000000;\n\n    address[] private _stakers;\n\n    mapping(address => uint256) private _stakingTimes;\n    mapping(address => uint256) private _withdrawalTimes;\n    mapping(address => uint256) private _stakingTierChange;\n    mapping(address => uint256) private _totalStakingAmount;\n    mapping(address => uint256) private _totalWithdrawalAmount;\n    mapping(address => uint256) private _totalAwardedEth2Amount;\n\n    mapping(address => mapping(uint256 => uint256)) private _stakingAmount;\n    mapping(address => mapping(uint256 => uint256)) private _stakingTimestamp;\n    mapping(address => mapping(uint256 => uint256))\n        private _stakingWithdrawalTimestamp;\n    mapping(address => mapping(uint256 => uint256)) private _withdrawalAmount;\n    mapping(address => mapping(uint256 => uint256))\n        private _withdrawalTimestamp;\n\n    constructor(address payable contr, address developer) public {\n        _admin = msg.sender;\n        _contr = contr;\n        _developer = developer;\n    }\n\n    modifier onlyAdmin() {\n        require(_admin == msg.sender);\n        _;\n    }\n\n    modifier adminOrDeveloper() {\n        require(_admin == msg.sender || _developer == msg.sender);\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(!_isPaused, \"Pausable: paused Eth\");\n        _;\n    }\n\n    modifier whenPaused() {\n        require(_isPaused, \"Pausable: not paused Eth\");\n        _;\n    }\n\n    event Staking(\n        address indexed staker,\n        uint256 stakingTimes,\n        uint256 stakeEtherAmount,\n        uint256 stakeTotalEtherAmount,\n        uint256 stakingTierChange,\n        uint256 stakeTimestamp\n    );\n\n    event DividendItem(uint256 category, uint256 dividendAmount);\n\n    event Withdrawal(\n        address indexed staker,\n        uint256 withdrawTimes,\n        uint256 withdrawnEtherDividendAmount,\n        uint256 withdrawnTotalEtherDividendAmount,\n        uint256 eth2AmountToBeMint,\n        uint256 awardedTotalEth2Amount,\n        uint256 withdrawalTimestamp\n    );\n\n    event WithdrawalSummary(\n        uint256 withdrawnTotalEtherDividendAmount,\n        uint256 awardedTotalEth2Amount\n    );\n\n    function changeAdmin(address payable admin) public onlyAdmin {\n        require(admin != address(0));\n        _admin = admin;\n    }\n\n    function changeContract(address contr) public onlyAdmin {\n        require(contr != address(0));\n        _contr = contr;\n    }\n\n    function changeDeveloper(address developer) public onlyAdmin {\n        require(developer != address(0));\n        _developer = developer;\n    }\n\n    function getAdmin() external view returns (address) {\n        return _admin;\n    }\n\n    function getContract() external view returns (address) {\n        return _contr;\n    }\n\n    function getDeveloper() external view returns (address) {\n        return _developer;\n    }\n\n    function isPaused() external view returns (bool) {\n        return _isPaused;\n    }\n\n    function pausedAddress(address sender) public onlyAdmin {\n        _isPausedAddress[sender] = true;\n    }\n\nfunction unPausedAddress(address sender) public onlyAdmin {\n        _isPausedAddress[sender] = false;\n    }\n\n    function getStakers() external view returns (address[] memory) {\n        return _stakers;\n    }\n\n    function getStakingTimes(address sender) \n        external \n        view \n        returns (uint256) {\n        return _stakingTimes[sender];\n    }\n\n    function getWithdrawalTimes(address sender)\n        external\n        view\n        returns (uint256)\n    {\n        return _withdrawalTimes[sender];\n    }\n\n    function getStakingTierChange(address sender)\n        external\n        view\n        returns (uint256)\n    {\n        return _stakingTierChange[sender];\n    }\n\n    function getTotalStakingAmount(address sender)\n        external\n        view\n        returns (uint256)\n    {\n        return _totalStakingAmount[sender];\n    }\n\n    function getTotalWithdrawalAmount(address sender)\n        external\n        view\n        returns (uint256)\n    {\n        return _totalWithdrawalAmount[sender];\n    }\n\n    function getTotalAwardedEth2Amount(address sender)\n        external\n        view\n        returns (uint256)\n    {\n        return _totalAwardedEth2Amount[sender];\n    }\n\n    function getStakingAmount(address sender, uint256 times)\n        external\n        view\n        returns (uint256)\n    {\n        return _stakingAmount[sender][times];\n    }\n\n    function getStakingTimestamp(address sender, uint256 times)\n        external\n        view\n        returns (uint256)\n    {\n        return _stakingTimestamp[sender][times];\n    }\n\n    function getStakingWithdrawalTimestamp(address sender, uint256 times)\n        external\n        view\n        returns (uint256)\n    {\n        return _stakingWithdrawalTimestamp[sender][times];\n    }\n\n    function getWithdrawalAmount(address sender, uint256 times)\n        external\n        view\n        returns (uint256)\n    {\n        return _withdrawalAmount[sender][times];\n    }\n\n    function getWithdrawalTimestamp(address sender, uint256 times)\n        external\n        view\n        returns (uint256)\n    {\n        return _withdrawalTimestamp[sender][times];\n    }\n\n    function getEtherBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function getBlockTimestamp() external view returns (uint256) {\n        return block.timestamp;\n    }\n\n    function paused() public onlyAdmin whenNotPaused {\n        _isPaused = true;\n    }\n\n    function unpaused() public onlyAdmin whenPaused {\n        _isPaused = false;\n    }\n\n    function stake() external payable {\n        require(\n            msg.value >= _minimumEther,\n            \"It is unable to stake if the received ether is less than the minimum required value.\"\n        );\n\n        uint256 stakingTimes = _stakingTimes[msg.sender];\n\n        if (stakingTimes == 0) {\n            _stakers.push(msg.sender);\n        }\n\n        _stakingAmount[msg.sender][stakingTimes] = msg.value;\n        _stakingTimestamp[msg.sender][stakingTimes] = block.timestamp;\n        _stakingWithdrawalTimestamp[msg.sender][stakingTimes] = block.timestamp;\n        _totalStakingAmount[msg.sender] =\n            _totalStakingAmount[msg.sender] +\n            msg.value;\n\n        if (\n            _stakingTierChange[msg.sender] == 0 &&\n            _stakingAmount[msg.sender][0] < _tierAmount &&\n            _totalStakingAmount[msg.sender] >= _tierAmount\n        ) {\n            _stakingTierChange[msg.sender] = stakingTimes;\n        }\n\n        emit Staking(\n            msg.sender,\n            stakingTimes,\n            msg.value,\n            _totalStakingAmount[msg.sender],\n            _stakingTierChange[msg.sender],\n            block.timestamp\n        );\n\n        _stakingTimes[msg.sender]++;\n    }\n\n    function withdrawDividend() external {\n        require(\n            !_isPaused,\n            \"It is unable to withdraw any dividend while paused.\"\n        );\n\n        require(\n            !_isPausedAddress[msg.sender],\n            \"It is unable to withdraw any dividend while paused on address.\"\n        );\n\nuint256 stakingTimes = _stakingTimes[msg.sender];\n        uint256 totalEthDividend = 0;\n        uint256 stakingTierChange = _stakingTierChange[msg.sender];\n\n        if (stakingTierChange == 0) {\n            uint256 stakingAmount = _stakingAmount[msg.sender][0];\n\n            if (stakingAmount < _tierAmount) {\n                for (uint256 i = 0; i < stakingTimes; i++) {\n                    uint256 timestampDifference = block.timestamp -\n                        _stakingWithdrawalTimestamp[msg.sender][i];\n                    uint256 ethDividend = withdrawDividendItem(\n                        true,\n                        timestampDifference,\n                        i\n                    );\n\n                    emit DividendItem(1, ethDividend);\n                    totalEthDividend = totalEthDividend.add(ethDividend);\n\n                    _stakingWithdrawalTimestamp[msg.sender][i] = block\n                        .timestamp;\n                }\n            } else {\n                for (uint256 i = 0; i < stakingTimes; i++) {\n                    uint256 timestampDifference = block.timestamp -\n                        _stakingWithdrawalTimestamp[msg.sender][i];\n                    uint256 ethDividend = withdrawDividendItem(\n                        false,\n                        timestampDifference,\n                        i\n                    );\n\n                    emit DividendItem(2, ethDividend);\n                    totalEthDividend = totalEthDividend.add(ethDividend);\n\n                    _stakingWithdrawalTimestamp[msg.sender][i] = block\n                        .timestamp;\n                }\n            }\n        } else {\n            for (uint256 i = 0; i < stakingTimes; i++) {\n                uint256 timestampDifference = 0;\n\n                if (i < stakingTimes - 1) {\n                    timestampDifference =\n                        _stakingWithdrawalTimestamp[msg.sender][i + 1] -\n                        _stakingWithdrawalTimestamp[msg.sender][i];\n\n                    _stakingWithdrawalTimestamp[msg\n                        .sender][i] = _stakingWithdrawalTimestamp[msg\n                        .sender][i + 1];\n                } else {\n                    timestampDifference =\n                        block.timestamp -\n                        _stakingWithdrawalTimestamp[msg.sender][i];\n\n                    _stakingWithdrawalTimestamp[msg.sender][i] = block\n                        .timestamp;\n                }\n\n                for (uint256 y = 0; y <= i; y++) {\n                    if (i < stakingTierChange) {\n                        uint256 ethDividend = withdrawDividendItem(\n                            true,\n                            timestampDifference,\n                            y\n                        );\n\n                        totalEthDividend = totalEthDividend.add(ethDividend);\n\n                        emit DividendItem(3, ethDividend);\n                    } else {\n                        uint256 ethDividend = withdrawDividendItem(\n                            false,\n                            timestampDifference,\n                            y\n                        );\n\n                        totalEthDividend = totalEthDividend.add(ethDividend);\n\n                        emit DividendItem(4, ethDividend);\n                    }\n                }\n            }\n        }\n\n        uint256 totalStakingAmount = 0;\n\n        for (uint256 i = 0; i <= stakingTimes; i++) {\n            totalStakingAmount = totalStakingAmount.add(\n                _stakingAmount[msg.sender][i]\n            );\n\n            _stakingWithdrawalTimestamp[msg.sender][i] = block.timestamp;\n        }\n\n        _totalStakingAmount[msg.sender] = totalStakingAmount;\n\n        uint256 withdrawalTimes = _withdrawalTimes[msg.sender];\n        _withdrawalAmount[msg.sender][withdrawalTimes] = totalEthDividend;\n        _withdrawalTimestamp[msg.sender][withdrawalTimes] = block.timestamp;\n        _withdrawalTimes[msg.sender]++;\n\n        _totalWithdrawalAmount[msg.sender] = _totalWithdrawalAmount[msg.sender]\n            .add(totalEthDividend);\n\nuint256 totalAwardedEth2Amount = 0;\n\n        for (uint256 i = 0; i <= stakingTimes; i++) {\n            uint256 timestampDifference = block.timestamp -\n                _stakingTimestamp[msg.sender][i];\n\n            uint256 stakingAmount = _stakingAmount[msg.sender][i];\n\n            uint256 awardedEth2Amount = (stakingAmount *\n                1500000 *\n                timestampDifference) /\n                524288 /\n                2592000;\n\n            totalAwardedEth2Amount = totalAwardedEth2Amount.add(\n                awardedEth2Amount\n            );\n        }\n\n        uint256 previousAwardedTotalEth2Amount = _totalAwardedEth2Amount[msg\n            .sender];\n        _totalAwardedEth2Amount[msg.sender] = totalAwardedEth2Amount;\n\n        uint256 awardedEth2Amount = totalAwardedEth2Amount.sub(\n            previousAwardedTotalEth2Amount\n        );\n\n        if (awardedEth2Amount > 0) {\n            IEth2 contr = IEth2(_contr);\n            //Eth2 contr = new Eth2(msg.sender, msg.sender);\n            contr.mint(msg.sender, awardedEth2Amount);\n        }\n\n        emit Withdrawal(\n            msg.sender,\n            withdrawalTimes,\n            totalEthDividend,\n            _totalWithdrawalAmount[msg.sender],\n            awardedEth2Amount,\n            totalAwardedEth2Amount,\n            block.timestamp\n        );\n\n        emit WithdrawalSummary(\n            _totalWithdrawalAmount[msg.sender],\n            totalAwardedEth2Amount\n        );\n\n        msg.sender.transfer(totalEthDividend);\n    }\n\n    function withdrawDividendItem(\n        bool isTier1,\n        uint256 timestampDifference,\n        uint256 times\n    ) internal view returns (uint256 dividend) {\n        uint256 percentage = 0;\n\n        if (isTier1) {\n            percentage = 150;\n        } else {\n            percentage = 216;\n        }\n\n        uint256 stakingAmount = _stakingAmount[msg.sender][times];\n        uint256 ethDividend = (stakingAmount *\n            percentage *\n            timestampDifference) /\n            1000 /\n            2592000;\n\n        return ethDividend;\n    }\n\n    function deposit() external payable onlyAdmin {}\n\n    function withdraw(uint256 amount) external onlyAdmin {\n        _admin.transfer(amount);\n    }\n\n    function withdrawAll() external onlyAdmin {\n        _admin.transfer(address(this).balance);\n    }\n\n    function kill() external onlyAdmin {\n        selfdestruct(_admin);\n    }\n\n    receive() external payable {\n        revert();\n    }\n}"}}}