{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"SashimiLendingLiquidation.sol":{"content":"// File: contracts/interfaces/IUniswapV2Router02.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\ninterface IUniswapV2Router02 {\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n// File: contracts/SLToken.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\ninterface SLErc20  {\r\n    function liquidateBorrow(address borrower, uint repayAmount, address slTokenCollateral) external returns (uint);\r\n}\r\n\r\ninterface SLEther {\r\n    function liquidateBorrow(address borrower, address slTokenCollateral) external payable;\r\n}\r\n\r\ncontract SLToken{\r\n    address public underlying;\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n}\r\n\r\n// File: contracts/TransferHelper.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.5.16;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n}\r\n\r\n// File: contracts/SashimiLendingLiquidation.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\n\r\n\r\ncontract SashimiLendingLiquidation {\r\n    IUniswapV2Router02 public uniswapRouter;\r\n    IUniswapV2Router02 public sashimiswapRouter;\r\n    mapping(address => bool) public sashimiswapToken;\r\n    address public slETH;\r\n    address public WETH;\r\n    address public owner;\r\n\r\n    constructor(IUniswapV2Router02 uniswapRouter_, IUniswapV2Router02 sashimiswapRouter_, address slETH_, address WETH_) public {\r\n        uniswapRouter = uniswapRouter_;\r\n        sashimiswapRouter = sashimiswapRouter_;\r\n        slETH = slETH_;\r\n        WETH = WETH_;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        owner = newOwner;\r\n    }\r\n\r\n    function liquidateBorrow(address slTokenBorrowed, address borrower, uint repayAmount, address slTokenCollateral) public payable onlyOwner returns (uint) {\r\n        if(slTokenBorrowed != slETH){\r\n            address tokenBorrowed = SLToken(slTokenBorrowed).underlying();\r\n            swapETHForTokenBorrowed(tokenBorrowed, repayAmount); //swap ETH to borrowed token\r\n            TransferHelper.safeApprove(tokenBorrowed, slTokenBorrowed, repayAmount);\r\n            uint err = SLErc20(slTokenBorrowed).liquidateBorrow(borrower, repayAmount, slTokenCollateral);\r\n            require(err == 0,\"liquidateBorrow failed\");            \r\n        }else{ //no need to swap, if slTokenBorrowed is slETH\r\n            SLEther(slTokenBorrowed).liquidateBorrow.value(repayAmount)(borrower, slTokenCollateral);\r\n        }\r\n        uint redeemTokens = SLToken(slTokenCollateral).balanceOf(address(this));\r\n        SLToken(slTokenCollateral).redeem(redeemTokens);\r\n\r\n        if(slTokenCollateral != slETH){ //need to swap for eth, if slTokenCollateral is not slETH\r\n            address tokenCollateral = SLToken(slTokenCollateral).underlying();\r\n            swapTokenForETH(tokenCollateral, SLToken(tokenCollateral).balanceOf(address(this))); //swap token to ETH\r\n        }\r\n        uint balance = address(this).balance;\r\n        require(balance > msg.value, \"earn failed\"); //eth should be increased\r\n        doTransferOut(msg.sender, balance); //transfer eth back to sender\r\n    }\r\n\r\n    function setSashimiswapToken(address token, bool flag) external onlyOwner{\r\n        sashimiswapToken[token] = flag;\r\n    }\r\n\r\n    function swapETHForTokenBorrowed(address token,uint amountOut) internal{\r\n        address[] memory path = new address[](2);\r\n        path[0] = WETH;\r\n        path[1] = token;\r\n        IUniswapV2Router02 router = getRouter(token);\r\n        router.swapETHForExactTokens.value(msg.value)(amountOut, path, address(this), block.timestamp + 3);\r\n    }\r\n\r\n    function swapTokenForETH(address token,uint amountIn) internal{\r\n        address[] memory path = new address[](2);\r\n        path[0] = token;\r\n        path[1] = WETH;\r\n        IUniswapV2Router02 router = getRouter(token);\r\n        TransferHelper.safeApprove(token, address(router), amountIn);        \r\n        router.swapExactTokensForETH(amountIn, 0, path, address(this), block.timestamp + 3); \r\n    }\r\n\r\n    function getRouter(address token) internal view returns (IUniswapV2Router02){\r\n        if(sashimiswapToken[token]){\r\n            return sashimiswapRouter;\r\n        }else{\r\n            return uniswapRouter;\r\n        }\r\n    }\r\n\r\n    function doTransferOut(address payable to, uint amount) internal {\r\n        /* Send the Ether, with minimal gas and revert on failure */\r\n        to.transfer(amount);\r\n    }\r\n}"}}}