{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ii.sol":{"content":"/// SPDX-License-Identifier: MIT\r\n/*\r\n▄▄█    ▄   ██   █▄▄▄▄ ▄█ \r\n██     █  █ █  █  ▄▀ ██ \r\n██ ██   █ █▄▄█ █▀▀▌  ██ \r\n▐█ █ █  █ █  █ █  █  ▐█ \r\n ▐ █  █ █    █   █    ▐ \r\n   █   ██   █   ▀   \r\n           ▀          */\r\n/// Special thanks to Keno, Boring and Gonpachi for review and inspiration.\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.0\r\n/// License-Identifier: MIT\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /// @notice EIP 2612\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\n/// @notice Inari registers and batches contract calls for crafty strategies.\r\ncontract Inari {\r\n    address public dao = msg.sender; // initialize governance with Inari summoner\r\n    uint public offerings; // strategies offered into Kitsune and `inari()` calls\r\n    mapping(uint => Kitsune) kitsune; // internal Kitsune mapping to `offerings`\r\n    \r\n    event MakeOffering(address indexed server, address[] to, bytes4[] sig, bytes32 descr, uint indexed offering);\r\n    event Bridge(IERC20[] token, address[] approveTo);\r\n    event Govern(address indexed dao, uint indexed kit, bool zenko);\r\n    \r\n    /// @notice Stores Inari strategies - `zenko` flagged by `dao`.\r\n    struct Kitsune {\r\n        address[] to;\r\n        bytes4[] sig;\r\n        bytes32 descr;\r\n        bool zenko;\r\n    }\r\n    \r\n    /*********\r\n    CALL INARI \r\n    *********/\r\n    /// @notice Batch Inari strategies and perform calls.\r\n    /// @param kit Kitsune strategy 'offerings' ID.\r\n    /// @param value ETH value (if any) for call.\r\n    /// @param param Parameters for call data after Kitsune `sig`.\r\n    function inari(uint[] calldata kit, uint[] calldata value, bytes[] calldata param) \r\n        external payable returns (bool success, bytes memory returnData) {\r\n        for (uint i = 0; i < kit.length; i++) {\r\n            Kitsune storage ki = kitsune[kit[i]];\r\n            (success, returnData) = ki.to[i].call{value: value[i]}\r\n            (abi.encodePacked(ki.sig[i], param[i]));\r\n            require(success, '!served');\r\n        }\r\n    }\r\n    \r\n    /// @notice Batch Inari strategies into single call with `zenko` check.\r\n    /// @param kit Kitsune strategy 'offerings' ID.\r\n    /// @param value ETH value (if any) for call.\r\n    /// @param param Parameters for call data after Kitsune `sig`.\r\n    function inariZushi(uint[] calldata kit, uint[] calldata value, bytes[] calldata param) \r\n        external payable returns (bool success, bytes memory returnData) {\r\n        for (uint i = 0; i < kit.length; i++) {\r\n            Kitsune storage ki = kitsune[kit[i]];\r\n            require(ki.zenko, \"!zenko\");\r\n            (success, returnData) = ki.to[i].call{value: value[i]}\r\n            (abi.encodePacked(ki.sig[i], param[i]));\r\n            require(success, '!served');\r\n        }\r\n    }\r\n    \r\n    /********\r\n    OFFERINGS \r\n    ********/\r\n    /// @notice Inspect a Kitsune offering (`kit`).\r\n    function checkOffering(uint kit) external view returns (address[] memory to, bytes4[] memory sig, string memory descr, bool zenko) {\r\n        Kitsune storage ki = kitsune[kit];\r\n        to = ki.to;\r\n        sig = ki.sig;\r\n        descr = string(abi.encodePacked(ki.descr));\r\n        zenko = ki.zenko;\r\n    }\r\n    \r\n    /// @notice Offer Kitsune strategy that can be called by `inari()`.\r\n    /// @param to The contract(s) to be called in strategy. \r\n    /// @param sig The function signature(s) involved (completed by `inari()` `param`).\r\n    function makeOffering(address[] calldata to, bytes4[] calldata sig, bytes32 descr) external { \r\n        uint kit = offerings;\r\n        kitsune[kit] = Kitsune(to, sig, descr, false);\r\n        offerings++;\r\n        emit MakeOffering(msg.sender, to, sig, descr, kit);\r\n    }\r\n    \r\n    /*********\r\n    GOVERNANCE \r\n    *********/\r\n    /// @notice Approve token for Inari to spend among contracts.\r\n    /// @param token ERC20 contract(s) to register approval for.\r\n    /// @param approveTo Spender contract(s) to pull `token` in `inari()` calls.\r\n    function bridge(IERC20[] calldata token, address[] calldata approveTo) external {\r\n        for (uint i = 0; i < token.length; i++) {\r\n            token[i].approve(approveTo[i], type(uint).max);\r\n            emit Bridge(token, approveTo);\r\n        }\r\n    }\r\n    \r\n    /// @notice Update Inari `dao` and Kitsune `zenko` status.\r\n    /// @param dao_ Address to grant Kitsune governance.\r\n    /// @param kit Kitsune strategy 'offerings' ID.\r\n    /// @param zen `kit` approval. \r\n    function govern(address dao_, uint kit, bool zen) external {\r\n        require(msg.sender == dao, \"!dao\");\r\n        dao = dao_;\r\n        kitsune[kit].zenko = zen;\r\n        emit Govern(dao_, kit, zen);\r\n    }\r\n}"}}}