{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/NFTClaimer.sol":{"content":"pragma solidity >=0.4.22 <0.7.0;\r\n\r\n\r\nabstract contract NFTInterface {\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external virtual;\r\n}\r\n\r\n/**\r\n * @title NFTClaimer\r\n * @dev transfer tokens & store claimer\r\n */\r\ncontract NFTClaimer {\r\n\r\n    address owner;\r\n    mapping (address => mapping(address => bool)) claimers;\r\n    mapping (address => uint256) supply;\r\n    mapping (address => uint256) claimCount;\r\n    mapping (address => uint256) totalClaimCount;\r\n    mapping (address => uint256) tokenIndex;\r\n\r\n    event Claimed(address _claimer, address _tokenAddress);\r\n\r\n    /**\r\n     * @dev     sets the initial owner of the contract to whoever deployed it\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev     modifier for administational purposes\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev     change ownership of this contract\r\n     * @param   _newOwner - new owner of the contract\r\n     */\r\n    function changeOwner(address _newOwner) public onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev     claim an nft\r\n     * @notice  requires msg.sender has not been registered as a claimer of the requested nft in claimers\r\n     * @notice  requires there is a supply of the requested nft left in this contract\r\n     * @param   _nftAddress - the type of token the sender wants to claim\r\n     */\r\n    function claim(address _nftAddress) public {\r\n        // require !claimedBy\r\n        require(claimedBy(msg.sender, _nftAddress) == false, \"This wallet has already claimed this item.\");\r\n        \r\n        // require currentSupply > 0\r\n        require(getCurrentSupply(_nftAddress) > 0, \"No NFT of this type available at this time! Check back later!\");\r\n        \r\n        // transfer token to msg.sender\r\n        NFTInterface nftContract = NFTInterface(_nftAddress);\r\n        nftContract.safeTransferFrom(address(this), msg.sender, tokenIndex[_nftAddress]);\r\n        \r\n        // increment values\r\n        tokenIndex[_nftAddress] += 1;\r\n        claimCount[_nftAddress] += 1;\r\n        totalClaimCount[_nftAddress] += 1;\r\n        \r\n        // register msg.sender as claimer\r\n        register(_nftAddress);\r\n    }\r\n    \r\n    /**\r\n     * @dev     get the current supply of a type of nft in this contract\r\n     * @param   _nftAddress - the type of nft you want to get the supply for\r\n     * @return  available supply of nft\r\n     */\r\n    function getCurrentSupply(address _nftAddress) public view returns (uint) {\r\n        return supply[_nftAddress] - claimCount[_nftAddress];\r\n    }\r\n    \r\n    /**\r\n     * @dev     get total claim count of a type of nft in this contract\r\n     * @param   _nftAddress - the type of nft you want to get the total claim count for\r\n     * @return  total claim count of type of nft\r\n     */\r\n    function getTotalClaimCount(address _nftAddress) public view returns (uint) {\r\n        return totalClaimCount[_nftAddress];\r\n    }\r\n    \r\n    /**\r\n     * @dev     get current token index for specific nft\r\n     * @param   _nftAddress - the type of nft you want to get the token index for\r\n     * @return  token index for type of nft\r\n     */\r\n    function getCurrentTokenIndex(address _nftAddress) public view returns (uint) {\r\n        return tokenIndex[_nftAddress];\r\n    }\r\n\r\n    /**\r\n     * @dev     register a wallet as claimer\r\n     */\r\n    function register(address _nftAddress) private {\r\n        setClaimer(msg.sender, _nftAddress);\r\n    }\r\n    \r\n    /**\r\n     * @dev     adds a claimer to the claimers mapping\r\n     * @param   _claimer - claimer's wallet address\r\n     * @param   _nftAddress - address of nft claimed\r\n     */\r\n    function setClaimer(address _claimer, address _nftAddress) private {\r\n        claimers[_claimer][_nftAddress] = true;\r\n        emit Claimed(_claimer, _nftAddress);\r\n    }\r\n    \r\n    /**\r\n     * @dev     check if the claimers mapping contains a mapping for the supplied address\r\n     * @param    _address - wallet address to check for\r\n     * @param   _nftAddress - nft address to check for\r\n     */\r\n    function claimedBy(address _address, address _nftAddress) public view returns (bool) {\r\n        return claimers[_address][_nftAddress];\r\n    }\r\n    \r\n    /*================================== Owner Functions ==================================*/\r\n    \r\n    /**\r\n     * @dev     administational function used to set the tokenIndex for a new batch of nfts\r\n     * @param   _nftAddress - nft address to set the id for\r\n     * @param   _index - tokenId of the first nft in the batch\r\n     */\r\n    function setTokenIndex(address _nftAddress, uint256 _index) public onlyOwner {\r\n        tokenIndex[_nftAddress] = _index;\r\n    }\r\n    \r\n    /**\r\n     * @dev     administational function used to set the amount of nfts in a new batch\r\n     * @param   _nftAddress - nft address to set the supply for\r\n     * @param   _supply - amount of nfts in the batch\r\n     */\r\n    function setSupply(address _nftAddress, uint256 _supply) public onlyOwner {\r\n        supply[_nftAddress] = _supply;\r\n    }\r\n    \r\n    /**\r\n     * @dev     administational function used to reset the claim count for a new batch of nfts\r\n     * @param   _nftAddress - nft address to set the claim count for\r\n     * @param    _claimCount - claim count of the current batch, usually 0\r\n     */\r\n    function setCurrentClaimCount(address _nftAddress, uint _claimCount) public onlyOwner {\r\n        claimCount[_nftAddress] = _claimCount;\r\n    }\r\n    \r\n    /**\r\n     * @dev     administational function used to all above values (tokenIndex, supply and claim count) for a new batch of nfts\r\n     * @param   _nftAddress - nft address to set the id for\r\n     * @param   _tokenIndex - tokenId of the first nft in the batch\r\n     * @param   _supply - amount of nfts in the batch\r\n     * @param   _claimCount - claim count of the current batch, usually 0\r\n     */\r\n    function setValues(address _nftAddress, uint256 _tokenIndex, uint256 _supply, uint256 _claimCount) public onlyOwner\r\n    {\r\n        tokenIndex[_nftAddress] = _tokenIndex;\r\n        supply[_nftAddress] = _supply;\r\n        claimCount[_nftAddress] = _claimCount;\r\n    }\r\n\r\n    /**\r\n     * @dev     manual transfer of token. this will be removed before deployment on mainnet\r\n     */\r\n    function _transferFrom(address _nftAddress, address _to, uint256 _tokenId) public onlyOwner {\r\n        NFTInterface nftContract = NFTInterface(_nftAddress);\r\n        nftContract.safeTransferFrom(address(this), _to, _tokenId);\r\n    }\r\n}"}}}