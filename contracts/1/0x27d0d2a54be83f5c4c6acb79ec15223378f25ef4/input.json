{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/safeMath.sol": {
      "content": "pragma solidity >=0.4.22 <0.7.0;\r\n\r\nlibrary SafeMath {\r\n    //加\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    //减\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    //乘\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    //除\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    //取余\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"
    },
    "browser/token.sol": {
      "content": "pragma solidity >=0.4.22 <0.7.0;\r\n\r\nimport \"./safeMath.sol\";\r\n\r\ncontract owned {\r\n    address payable public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    //拥有者权限修饰\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    //转让拥有者\r\n    function transferOwnership(address payable newOwner) onlyOwner public {\r\n        owner = newOwner;\r\n    }\r\n\r\n    //销毁合约\r\n    function kill() public {\r\n        if (msg.sender == owner) {\r\n            selfdestruct(owner);\r\n        }\r\n    }\r\n}\r\n\r\ninterface tokenRecipient {\r\n    //对外接口\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external;\r\n}\r\n\r\ncontract TokenERC20 {\r\n    using SafeMath for uint;\r\n    string public name;  // 全称\r\n    string public symbol;  //符号\r\n    uint8 public decimals = 18;  //小数位\r\n    uint256 public totalSupply;  //总量\r\n\r\n    mapping(address => uint256) public balanceOf;  // 用户余额映射\r\n    mapping(address => mapping(address => uint256)) public allowance;  //TODO 待确定\r\n\r\n    // 转账事件\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    // 通知客户端转移走 / 销毁 的数量\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    //构造函数，初始化\r\n    constructor(\r\n        uint256 initialSupply,\r\n        string memory tokenName,\r\n        string memory tokenSymbol\r\n    ) public {\r\n        totalSupply = initialSupply * 10 ** uint256(decimals);\r\n        balanceOf[address(this)] = totalSupply;\r\n        name = tokenName;\r\n        symbol = tokenSymbol;\r\n    }\r\n\r\n    //转账具体实现\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require(_to != address(0x0));\r\n        //检测余额是否充足\r\n        require(balanceOf[_from] >= _value);\r\n        // 防止接收者代币数量溢出\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n        // 保留一下以前的余额\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        // 扣掉发送者的钱\r\n        balanceOf[_from] -= _value;\r\n        // 增加接收者的钱\r\n        balanceOf[_to] += _value;\r\n        //发送转账事件\r\n        emit Transfer(_from, _to, _value);\r\n        // 用来分析代码中的错误，保证之前之后两次相加是不变的。好聪明的手法\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n    //转账方法\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    //批准一个账户从另外一个账户中可支取的钱\r\n    function approve(address _spender, uint256 _value) public\r\n    returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    //允许某个账户从我的地址花费一部分金额\r\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\r\n    public\r\n    returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\r\n            return true;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //从发送者账户销毁一部分代币\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        //检测发送者账户中的代币数量是否充足\r\n        require(balanceOf[msg.sender] >= _value);\r\n        //扣除用户本身的代币\r\n        balanceOf[msg.sender] -= _value;\r\n        //扣除系统中代币的总量\r\n        totalSupply -= _value;\r\n        //通知客户端\r\n        emit Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    //从某个账户销毁一部分代币\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        //检测待销毁账户中是否有足够的数量\r\n        require(balanceOf[_from] >= _value);\r\n        //检测人家允许你花费的额度\r\n        require(_value <= allowance[_from][msg.sender]);\r\n        //扣掉账户中的钱\r\n        balanceOf[_from] -= _value;\r\n        //扣掉给你的额度\r\n        allowance[_from][msg.sender] -= _value;\r\n        //减掉系统总量\r\n        totalSupply -= _value;\r\n        //通知客户端\r\n        emit Burn(_from, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract MyToken is owned, TokenERC20 {\r\n    uint256 public sellBalance;  //卖出的数量\r\n    uint256 public burnBalance;  //销毁的数量\r\n\r\n    constructor(\r\n        uint256 initialSupply,\r\n        string memory tokenName,\r\n        string memory tokenSymbol\r\n    ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}\r\n\r\n\r\n    function price() public view returns (uint){\r\n        //获取销售金额\r\n        if(sellBalance < 5e25){  //初期\r\n            uint _init = 12999;\r\n            //初始价格\r\n            uint _initPrice = uint(1).mul(1e18).div(_init);  //初始价格\r\n            \r\n            //每上涨一次，减去的数量\r\n            uint  _singlePrice = uint(1).mul(1e18).div(_init).div(100);\r\n            \r\n            //应该翻的倍数\r\n            uint _ratio = sellBalance.div(1e23);\r\n            \r\n            //实际应该减去的数量\r\n            uint _newPrice = _initPrice.add(_singlePrice.mul(_ratio));\r\n            uint _price = uint(1).mul(1e18).div(_newPrice);\r\n            \r\n            return _price;\r\n            \r\n            \r\n        }else if(sellBalance < 1e26){  //中期\r\n        \r\n            uint _init = 2166;\r\n        \r\n            //初始可以兑换的数量\r\n            uint _initPrice = uint(1).mul(1e18).div(_init);  //初始价格\r\n            \r\n            //每上涨一次，减去的数量\r\n            uint  _singlePrice = uint(1).mul(1e18).div(_init).div(100);\r\n            \r\n            //应该翻的倍数\r\n            uint _ratio = (sellBalance.sub(5e25)).div(2e23);\r\n            \r\n            //实际应该减去的数量\r\n            uint _newPrice = _initPrice.add(_singlePrice.mul(_ratio));\r\n            uint _price = uint(1).mul(1e18).div(_newPrice);\r\n            \r\n            return _price;\r\n        \r\n        }else if(sellBalance < 159e24){  //末期\r\n        \r\n            uint _init = 619;\r\n        \r\n            //初始可以兑换的数量\r\n            uint _initPrice = uint(1).mul(1e18).div(_init);  //初始价格\r\n            \r\n            //每上涨一次，减去的数量\r\n            uint  _singlePrice = uint(1).mul(1e18).div(_init).div(100);\r\n            \r\n            //应该翻的倍数\r\n            uint _ratio = (sellBalance.sub(1e26)).div(3e23);\r\n            \r\n            //实际应该减去的数量\r\n            uint _newPrice = _initPrice.add(_singlePrice.mul(_ratio));\r\n            uint _price = uint(1).mul(1e18).div(_newPrice);\r\n            \r\n            return _price;\r\n        }else{\r\n            return 0;\r\n        }\r\n            \r\n    }\r\n\r\n    //购买代币\r\n    function buy() payable public {\r\n        uint _price = price();\r\n        uint amount = msg.value.mul(_price);\r\n\r\n        sellBalance = sellBalance.add(amount);\r\n\r\n        _transfer(address(this), tx.origin, amount);\r\n    }\r\n\r\n    //绑定并购买代币\r\n    function buyAndBindParent(Core core, address _parentAddress) payable public{\r\n        address _own = tx.origin;\r\n\r\n        if(false == core.getIsParent(_own)){\r\n            core.bindParent(_parentAddress);\r\n        }\r\n\r\n        buy();\r\n    }\r\n\r\n\r\n    //获取代币余额\r\n    function getToken(address _own) public view returns (uint){\r\n        return balanceOf[_own];\r\n    }\r\n\r\n    //发送代币到合约\r\n    function sendTokenToGame(address _to, uint _value) public returns (bool){\r\n        address txAddress = tx.origin;\r\n        //先判断当前用户是否有足够的钱\r\n        require(balanceOf[txAddress] >= _value);\r\n\r\n        burnBalance = burnBalance.add(_value);\r\n\r\n        //执行转账\r\n        _transfer(txAddress, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    //获取代币的价格\r\n    function getTokenPrice() public view returns (uint){\r\n        return price();\r\n    }\r\n\r\n\r\n    function bindCoreParent(Core core,address _parentAddress) public {\r\n        core.bindParent(_parentAddress);\r\n    }\r\n\r\n\r\n    function t(address payable _addr) payable public{\r\n        uint _value  = msg.value;\r\n        _addr.transfer(_value);\r\n    }\r\n\r\n}\r\n\r\n\r\nabstract contract Core {\r\n    //绑定推荐关系\r\n    function bindParent(address _parent) public virtual;\r\n\r\n    //获取是否绑定推荐关系\r\n    function getIsParent(address _own) public view virtual returns (bool);\r\n}\r\n"
    }
  }
}