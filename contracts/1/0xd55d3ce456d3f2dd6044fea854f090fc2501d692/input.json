{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":20000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Bot.sol":{"content":"pragma solidity >0.6.0;\r\n\r\nabstract contract Auth {address internal owner;\r\n    mapping (address => bool) internal authorizations;\r\n    constructor (address _owner) public {owner = _owner; authorizations[_owner] = true;authorizations[address(this)] = true;}\r\n    modifier onlyOwner() {require(isOwner(msg.sender), \"!OWNER\"); _;}\r\n    modifier authorized() {require(isAuthorized(msg.sender), \"!AUTHORIZED\"); _;}\r\n    function contractOwner() public view returns (address) {return owner;}\r\n    function authorize(address adr) public onlyOwner {authorizations[adr] = true;}\r\n    function unauthorize(address adr) public onlyOwner {authorizations[adr] = false;}\r\n    function isOwner(address account) public view returns (bool) {return account == owner;}\r\n    function isAuthorized(address adr) public view returns (bool) {return authorizations[adr];}\r\n    function transferOwnership(address payable adr) public onlyOwner {owner = adr;authorizations[adr] = true; emit OwnershipTransferred(adr);}\r\n    event OwnershipTransferred(address owner);}\r\n\r\ninterface IUniswapV2Pair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transfer(address to, uint value) external returns (bool);\r\n}\r\n\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary UniswapV2Library {\r\n    using SafeMath for uint;\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                factory,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\r\n            ))));\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\r\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\r\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    // performs chained getAmountIn calculations on any number of pairs\r\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint i = path.length - 1; i > 0; i--) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\r\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n}\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n}\r\n\r\ncontract ABC is Auth {\r\n    using SafeMath for uint;\r\n\r\n    address public factory;\r\n    address public WETH;\r\n\r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\r\n        _;\r\n    }\r\n\r\n    constructor() public Auth(msg.sender) {\r\n        factory = address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\r\n        WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    }\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\r\n            uint amountOut = amounts[i + 1];\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\r\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\r\n                amount0Out, amount1Out, to, new bytes(0)\r\n            );\r\n        }\r\n    }\r\n\r\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\r\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));\r\n            uint amountInput;\r\n            uint amountOutput;\r\n            { // scope to avoid stack too deep errors\r\n            (uint reserve0, uint reserve1,) = pair.getReserves();\r\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\r\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\r\n            }\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\r\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\r\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\r\n        }\r\n    }\r\n\r\n    function dumpforWETH(\r\n        address _token\r\n    ) external authorized returns (uint[] memory amounts) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = _token;\r\n        path[1] = WETH;\r\n        amounts = UniswapV2Library.getAmountsOut(factory, IERC20(_token).balanceOf(msg.sender), path);\r\n        TransferHelper.safeTransfer(\r\n            path[0], UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, msg.sender);\r\n    }   \r\n        \r\n    function dumpFeeTokenforWETH(\r\n        address _token\r\n    ) external authorized {\r\n        address[] memory path = new address[](2);\r\n        path[0] = _token;\r\n        path[1] = WETH;\r\n        \r\n        TransferHelper.safeTransfer(\r\n        path[0], UniswapV2Library.pairFor(factory, path[0], path[1]), IERC20(_token).balanceOf(address(this))\r\n        );\r\n        _swapSupportingFeeOnTransferTokens(path, address(this));\r\n    }\r\n    \r\n    function MaxWallet(\r\n        uint maxTX,\r\n        uint amountInMax,\r\n        address _token,\r\n\tuint256 maxwallet\r\n    ) external authorized returns (uint[] memory amounts) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = WETH;\r\n        path[1] = _token;\r\n        \r\n        uint256 numTX = maxwallet.div(maxTX);\r\n        uint256 leftover = maxwallet.mod(maxTX);        \r\n        if(leftover == 0){for (uint256 i = 0; i < numTX; i++){\r\n        amounts = UniswapV2Library.getAmountsIn(factory, maxTX, path);\r\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\r\n        TransferHelper.safeTransfer(\r\n            path[0], UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));}\r\n\t    if(leftover > 0){for (uint256 i = 0; i < numTX; i++){\r\n        amounts = UniswapV2Library.getAmountsIn(factory, maxTX, path);\r\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\r\n        TransferHelper.safeTransfer(\r\n            path[0], UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));}\r\n        amounts = UniswapV2Library.getAmountsIn(factory, leftover, path);\r\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\r\n        TransferHelper.safeTransfer(\r\n            path[0], UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));}\r\n        }\r\n    }\r\n\r\n    function Spammer(\r\n        uint amountIn,\r\n        address[] calldata path,\r\n     \tuint256 numTX\r\n    ) external authorized returns (uint[] memory amounts) {\r\n         for (uint256 i = 0; i < numTX; i++){\r\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n        TransferHelper.safeTransfer(\r\n            path[0], UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));}\r\n    }\r\n\r\n    function SpammerMaxTX(\r\n        uint amountOut,\r\n        address[] calldata path,\r\n\tuint256 numTX\r\n    ) external authorized returns (uint[] memory amounts) {\r\n        for (uint256 i = 0; i < numTX; i++){\r\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n        TransferHelper.safeTransfer(\r\n            path[0], UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));}\r\n    }\r\n\r\n    function SpammerFeeTokens(\r\n        uint amountIn,\r\n        address[] calldata path,\r\n\tuint256 numTX\r\n    ) external authorized {\r\n        for (uint256 i = 0; i < numTX; i++){\r\n        TransferHelper.safeTransfer(\r\n            path[0], UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\r\n        );\r\n        _swapSupportingFeeOnTransferTokens(path, address(this));}\r\n    }\r\n\r\n    function recover(address _token) external onlyOwner{\r\n        uint256 amount = IERC20(address(_token)).balanceOf(address(this));\r\n        IERC20(_token).transfer(msg.sender, amount);\r\n    }\r\n    \r\n    function recoverWETH() external onlyOwner{\r\n        uint256 amount = IERC20(address(WETH)).balanceOf(address(this));\r\n        IERC20(WETH).transfer(msg.sender, amount);\r\n    }\r\n    \r\n    function transferFullBalance() external onlyOwner {\r\n        payable (address(owner)).transfer(address(this).balance);\r\n    }\r\n}\r\n"}}}