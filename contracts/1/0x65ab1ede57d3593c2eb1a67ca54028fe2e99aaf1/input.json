{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"starseas.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary Math {\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes memory) {\n        this;\n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n    function owner() public view returns (address) {\n        return _owner;\n    }\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ninterface IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n\ninterface IERC721Receiver {\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\n    external returns (bytes4);\n}\n\ncontract ERC721Holder is IERC721Receiver {\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n\ncontract Pausable is Context {\n    event Paused(address account);\n    event Unpaused(address account);\n    bool private _paused;\n    constructor () internal {\n        _paused = false;\n    }\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\nlibrary EnumerableSet {\n    struct Set {\n        bytes32[] _values;\n        mapping (bytes32 => uint256) _indexes;\n    }\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        uint256 valueIndex = set._indexes[value];\n        if (valueIndex != 0) {\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n            bytes32 lastvalue = set._values[lastIndex];\n            set._values[toDeleteIndex] = lastvalue;\n            set._indexes[lastvalue] = toDeleteIndex + 1;\n            set._values.pop();\n            delete set._indexes[value];\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n    struct AddressSet {\n        Set _inner;\n    }\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n    struct UintSet {\n        Set _inner;\n    }\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n\nlibrary EnumerableMap {\n    struct MapEntry {\n        uint256 _key;\n        uint256 _value;\n    }\n    struct Map {\n        MapEntry[] _entries;\n        mapping(uint256 => uint256) _indexes;\n    }\n    function _set(\n        Map storage map,\n        uint256 key,\n        uint256 value\n    ) private returns (bool) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) {\n            map._entries.push(MapEntry({_key: key, _value: value}));\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n    function _remove(Map storage map, uint256 key) private returns (bool) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex != 0) {\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n            MapEntry storage lastEntry = map._entries[lastIndex];\n            map._entries[toDeleteIndex] = lastEntry;\n            map._indexes[lastEntry._key] = toDeleteIndex + 1;\n            map._entries.pop();\n            delete map._indexes[key];\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _contains(Map storage map, uint256 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n    function _at(Map storage map, uint256 index) private view returns (uint256, uint256) {\n        require(map._entries.length > index, 'EnumerableMap: index out of bounds');\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n    function _get(Map storage map, uint256 key) private view returns (uint256) {\n        return _get(map, key, 'EnumerableMap: nonexistent key');\n    }\n    function _get(\n        Map storage map,\n        uint256 key,\n        string memory errorMessage\n    ) private view returns (uint256) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage);\n        return map._entries[keyIndex - 1]._value;\n    }\n    struct UintToUintMap {\n        Map _inner;\n    }\n    function set(\n        UintToUintMap storage map,\n        uint256 key,\n        uint256 value\n    ) internal returns (bool) {\n        return _set(map._inner, key, value);\n    }\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, key);\n    }\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, key);\n    }\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        return _at(map._inner, index);\n    }\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return _get(map._inner, key);\n    }\n    function get(\n        UintToUintMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return _get(map._inner, key, errorMessage);\n    }\n}\n\ninterface IBidNFT {\n    function buyToken(uint256 _tokenId) external;\n    function buyTokenTo(uint256 _tokenId, address _to) external;\n    function setCurrentPrice(uint256 _tokenId, uint256 _price) external;\n    function readyToSellToken(uint256 _tokenId, uint256 _price) external;\n    function readyToSellTokenTo(uint256 _tokenId, uint256 _price, address _to) external;\n    function cancelSellToken(uint256 _tokenId) external;\n    function bidToken(uint256 _tokenId, uint256 _price) external;\n    function updateBidPrice(uint256 _tokenId, uint256 _price) external;\n    function sellTokenTo(uint256 _tokenId, address _to) external;\n    function cancelBidToken(uint256 _tokenId) external;\n}\n\ncontract STARSWAP is IBidNFT, ERC721Holder, Ownable, Pausable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using EnumerableMap for EnumerableMap.UintToUintMap;\n    using EnumerableSet for EnumerableSet.UintSet;\n    struct AskEntry {\n        uint256 tokenId;\n        uint256 price;\n    }\n    struct BidEntry {\n        address bidder;\n        uint256 price;\n    }\n    struct UserBidEntry {\n        uint256 tokenId;\n        uint256 price;\n    }\n    IERC721 public nft;\n    IERC20 public quoteErc20;\n    address public feeAddr;\n    uint256 public feePercent;\n    EnumerableMap.UintToUintMap private _asksMap;\n    mapping(uint256 => address) private _tokenSellers;\n    mapping(address => EnumerableSet.UintSet) private _userSellingTokens;\n    mapping(uint256 => BidEntry[]) private _tokenBids;\n    mapping(address => EnumerableMap.UintToUintMap) private _userBids;\n    event Trade(address indexed seller, address indexed buyer, uint256 indexed tokenId, uint256 price, uint256 fee);\n    event Ask(address indexed seller, uint256 indexed tokenId, uint256 price);\n    event CancelSellToken(address indexed seller, uint256 indexed tokenId);\n    event FeeAddressTransferred(address indexed previousOwner, address indexed newOwner);\n    event SetFeePercent(address indexed seller, uint256 oldFeePercent, uint256 newFeePercent);\n    event Bid(address indexed bidder, uint256 indexed tokenId, uint256 price);\n    event CancelBidToken(address indexed bidder, uint256 indexed tokenId);\n\n    constructor(\n        address _nftAddress,\n        address _quoteErc20Address,\n        address _feeAddr,\n        uint256 _feePercent\n    ) public {\n        require(_nftAddress != address(0) && _nftAddress != address(this));\n        require(_quoteErc20Address != address(0) && _quoteErc20Address != address(this));\n        nft = IERC721(_nftAddress);\n        quoteErc20 = IERC20(_quoteErc20Address);\n        feeAddr = _feeAddr;\n        feePercent = _feePercent;\n        emit FeeAddressTransferred(address(0), feeAddr);\n        emit SetFeePercent(_msgSender(), 0, feePercent);\n    }\n    function buyToken(uint256 _tokenId) public override whenNotPaused {\n        buyTokenTo(_tokenId, _msgSender());\n    }\n    function buyTokenTo(uint256 _tokenId, address _to) public override whenNotPaused {\n        require(_msgSender() != address(0) && _msgSender() != address(this), 'Wrong msg sender');\n        require(_asksMap.contains(_tokenId), 'Token not in sell book');\n        require(!_userBids[_msgSender()].contains(_tokenId), 'You must cancel your bid first');\n        nft.safeTransferFrom(address(this), _to, _tokenId);\n        uint256 price = _asksMap.get(_tokenId);\n        uint256 feeAmount = price.mul(feePercent).div(100);\n        if (feeAmount != 0) {\n            quoteErc20.safeTransferFrom(_msgSender(), feeAddr, feeAmount);\n        }\n        quoteErc20.safeTransferFrom(_msgSender(), _tokenSellers[_tokenId], price.sub(feeAmount));\n        _asksMap.remove(_tokenId);\n        _userSellingTokens[_tokenSellers[_tokenId]].remove(_tokenId);\n        emit Trade(_tokenSellers[_tokenId], _to, _tokenId, price, feeAmount);\n        delete _tokenSellers[_tokenId];\n    }\n    function setCurrentPrice(uint256 _tokenId, uint256 _price) public override whenNotPaused {\n        require(_userSellingTokens[_msgSender()].contains(_tokenId), 'Only Seller can update price');\n        require(_price != 0, 'Price must be granter than zero');\n        _asksMap.set(_tokenId, _price);\n        emit Ask(_msgSender(), _tokenId, _price);\n    }\n    function readyToSellToken(uint256 _tokenId, uint256 _price) public override whenNotPaused {\n        readyToSellTokenTo(_tokenId, _price, address(_msgSender()));\n    }\n    function readyToSellTokenTo(\n        uint256 _tokenId,\n        uint256 _price,\n        address _to\n    ) public override whenNotPaused {\n        require(_msgSender() == nft.ownerOf(_tokenId), 'Only Token Owner can sell token');\n        require(_price != 0, 'Price must be granter than zero');\n        nft.safeTransferFrom(address(_msgSender()), address(this), _tokenId);\n        _asksMap.set(_tokenId, _price);\n        _tokenSellers[_tokenId] = _to;\n        _userSellingTokens[_to].add(_tokenId);\n        emit Ask(_to, _tokenId, _price);\n    }\n    function cancelSellToken(uint256 _tokenId) public override whenNotPaused {\n        require(_userSellingTokens[_msgSender()].contains(_tokenId), 'Only Seller can cancel sell token');\n        nft.safeTransferFrom(address(this), _msgSender(), _tokenId);\n        _asksMap.remove(_tokenId);\n        _userSellingTokens[_tokenSellers[_tokenId]].remove(_tokenId);\n        delete _tokenSellers[_tokenId];\n        emit CancelSellToken(_msgSender(), _tokenId);\n    }\n    function getAskLength() public view returns (uint256) {\n        return _asksMap.length();\n    }\n    function getAsks() public view returns (AskEntry[] memory) {\n        AskEntry[] memory asks = new AskEntry[](_asksMap.length());\n        for (uint256 i = 0; i < _asksMap.length(); ++i) {\n            (uint256 tokenId, uint256 price) = _asksMap.at(i);\n            asks[i] = AskEntry({tokenId: tokenId, price: price});\n        }\n        return asks;\n    }\n    function getAsksDesc() public view returns (AskEntry[] memory) {\n        AskEntry[] memory asks = new AskEntry[](_asksMap.length());\n        if (_asksMap.length() > 0) {\n            for (uint256 i = _asksMap.length() - 1; i > 0; --i) {\n                (uint256 tokenId, uint256 price) = _asksMap.at(i);\n                asks[_asksMap.length() - 1 - i] = AskEntry({tokenId: tokenId, price: price});\n            }\n            (uint256 tokenId, uint256 price) = _asksMap.at(0);\n            asks[_asksMap.length() - 1] = AskEntry({tokenId: tokenId, price: price});\n        }\n        return asks;\n    }\n    function getAsksByPage(uint256 page, uint256 size) public view returns (AskEntry[] memory) {\n        if (_asksMap.length() > 0) {\n            uint256 from = page == 0 ? 0 : (page - 1) * size;\n            uint256 to = Math.min((page == 0 ? 1 : page) * size, _asksMap.length());\n            AskEntry[] memory asks = new AskEntry[]((to - from));\n            for (uint256 i = 0; from < to; ++i) {\n                (uint256 tokenId, uint256 price) = _asksMap.at(from);\n                asks[i] = AskEntry({tokenId: tokenId, price: price});\n                ++from;\n            }\n            return asks;\n        } else {\n            return new AskEntry[](0);\n        }\n    }\n    function getAsksByPageDesc(uint256 page, uint256 size) public view returns (AskEntry[] memory) {\n        if (_asksMap.length() > 0) {\n            uint256 from = _asksMap.length() - 1 - (page == 0 ? 0 : (page - 1) * size);\n            uint256 to = _asksMap.length() - 1 - Math.min((page == 0 ? 1 : page) * size - 1, _asksMap.length() - 1);\n            uint256 resultSize = from - to + 1;\n            AskEntry[] memory asks = new AskEntry[](resultSize);\n            if (to == 0) {\n                for (uint256 i = 0; from > to; ++i) {\n                    (uint256 tokenId, uint256 price) = _asksMap.at(from);\n                    asks[i] = AskEntry({tokenId: tokenId, price: price});\n                    --from;\n                }\n                (uint256 tokenId, uint256 price) = _asksMap.at(0);\n                asks[resultSize - 1] = AskEntry({tokenId: tokenId, price: price});\n            } else {\n                for (uint256 i = 0; from >= to; ++i) {\n                    (uint256 tokenId, uint256 price) = _asksMap.at(from);\n                    asks[i] = AskEntry({tokenId: tokenId, price: price});\n                    --from;\n                }\n            }\n            return asks;\n        }\n        return new AskEntry[](0);\n    }\n    function getAsksByUser(address user) public view returns (AskEntry[] memory) {\n        AskEntry[] memory asks = new AskEntry[](_userSellingTokens[user].length());\n        for (uint256 i = 0; i < _userSellingTokens[user].length(); ++i) {\n            uint256 tokenId = _userSellingTokens[user].at(i);\n            uint256 price = _asksMap.get(tokenId);\n            asks[i] = AskEntry({tokenId: tokenId, price: price});\n        }\n        return asks;\n    }\n    function getAsksByUserDesc(address user) public view returns (AskEntry[] memory) {\n        AskEntry[] memory asks = new AskEntry[](_userSellingTokens[user].length());\n        if (_userSellingTokens[user].length() > 0) {\n            for (uint256 i = _userSellingTokens[user].length() - 1; i > 0; --i) {\n                uint256 tokenId = _userSellingTokens[user].at(i);\n                uint256 price = _asksMap.get(tokenId);\n                asks[_userSellingTokens[user].length() - 1 - i] = AskEntry({tokenId: tokenId, price: price});\n            }\n            uint256 tokenId = _userSellingTokens[user].at(0);\n            uint256 price = _asksMap.get(tokenId);\n            asks[_userSellingTokens[user].length() - 1] = AskEntry({tokenId: tokenId, price: price});\n        }\n        return asks;\n    }\n    function pause() public onlyOwner whenNotPaused {\n        _pause();\n    }\n    function unpause() public onlyOwner whenPaused {\n        _unpause();\n    }\n    function transferFeeAddress(address _feeAddr) public {\n        require(_msgSender() == feeAddr, 'FORBIDDEN');\n        feeAddr = _feeAddr;\n        emit FeeAddressTransferred(_msgSender(), feeAddr);\n    }\n    function setFeePercent(uint256 _feePercent) public onlyOwner {\n        require(feePercent != _feePercent, 'Not need update');\n        emit SetFeePercent(_msgSender(), feePercent, _feePercent);\n        feePercent = _feePercent;\n    }\n    function bidToken(uint256 _tokenId, uint256 _price) public override whenNotPaused {\n        require(_msgSender() != address(0) && _msgSender() != address(this), 'Wrong msg sender');\n        require(_price != 0, 'Price must be granter than zero');\n        require(_asksMap.contains(_tokenId), 'Token not in sell book');\n        address _seller = _tokenSellers[_tokenId];\n        address _to = address(_msgSender());\n        require(_seller != _to, 'Owner cannot bid');\n        require(!_userBids[_to].contains(_tokenId), 'Bidder already exists');\n        quoteErc20.safeTransferFrom(address(_msgSender()), address(this), _price);\n        _userBids[_to].set(_tokenId, _price);\n        _tokenBids[_tokenId].push(BidEntry({bidder: _to, price: _price}));\n        emit Bid(_msgSender(), _tokenId, _price);\n    }\n    function updateBidPrice(uint256 _tokenId, uint256 _price) public override whenNotPaused {\n        require(_userBids[_msgSender()].contains(_tokenId), 'Only Bidder can update the bid price');\n        require(_price != 0, 'Price must be granter than zero');\n        address _to = address(_msgSender()); // find  bid and the index\n        (BidEntry memory bidEntry, uint256 _index) = getBidByTokenIdAndAddress(_tokenId, _to);\n        require(bidEntry.price != 0, 'Bidder does not exist');\n        require(bidEntry.price != _price, 'The bid price cannot be the same');\n        if (_price > bidEntry.price) {\n            quoteErc20.safeTransferFrom(address(_msgSender()), address(this), _price - bidEntry.price);\n        } else {\n            quoteErc20.transfer(_to, bidEntry.price - _price);\n        }\n        _userBids[_to].set(_tokenId, _price);\n        _tokenBids[_tokenId][_index] = BidEntry({bidder: _to, price: _price});\n        emit Bid(_msgSender(), _tokenId, _price);\n    }\n    function getBidByTokenIdAndAddress(uint256 _tokenId, address _address)\n        private\n        view\n        returns (BidEntry memory, uint256)\n    {\n        BidEntry[] memory bidEntries = _tokenBids[_tokenId];\n        uint256 len = bidEntries.length;\n        uint256 _index;\n        BidEntry memory bidEntry;\n        for (uint256 i = 0; i < len; i++) {\n            if (_address == bidEntries[i].bidder) {\n                _index = i;\n                bidEntry = BidEntry({bidder: bidEntries[i].bidder, price: bidEntries[i].price});\n                break;\n            }\n        }\n        return (bidEntry, _index);\n    }\n    function delBidByTokenIdAndIndex(uint256 _tokenId, uint256 _index) private {\n        _userBids[_tokenBids[_tokenId][_index].bidder].remove(_tokenId);\n        uint256 len = _tokenBids[_tokenId].length;\n        for (uint256 i = _index; i < len - 1; i++) {\n            _tokenBids[_tokenId][i] = _tokenBids[_tokenId][i + 1];\n        }\n        _tokenBids[_tokenId].pop();\n    }\n    function sellTokenTo(uint256 _tokenId, address _to) public override whenNotPaused {\n        require(_asksMap.contains(_tokenId), 'Token not in sell book');\n        address _seller = _tokenSellers[_tokenId];\n        address _owner = address(_msgSender());\n        require(_seller == _owner, 'Only owner can sell token');\n        (BidEntry memory bidEntry, uint256 _index) = getBidByTokenIdAndAddress(_tokenId, _to);\n        require(bidEntry.price != 0, 'Bidder does not exist');\n        nft.safeTransferFrom(address(this), _to, _tokenId);\n        uint256 price = bidEntry.price;\n        uint256 feeAmount = price.mul(feePercent).div(100);\n        if (feeAmount != 0) {\n            quoteErc20.transfer(feeAddr, feeAmount);\n        }\n        quoteErc20.transfer(_seller, price.sub(feeAmount));\n        _asksMap.remove(_tokenId);\n        _userSellingTokens[_tokenSellers[_tokenId]].remove(_tokenId);\n        delBidByTokenIdAndIndex(_tokenId, _index);\n        emit Trade(_tokenSellers[_tokenId], _to, _tokenId, price, feeAmount);\n        delete _tokenSellers[_tokenId];\n    }\n    function cancelBidToken(uint256 _tokenId) public override whenNotPaused {\n        require(_userBids[_msgSender()].contains(_tokenId), 'Only Bidder can cancel the bid');\n        address _address = address(_msgSender());\n        (BidEntry memory bidEntry, uint256 _index) = getBidByTokenIdAndAddress(_tokenId, _address);\n        require(bidEntry.price != 0, 'Bidder does not exist');\n        quoteErc20.transfer(_address, bidEntry.price);\n        delBidByTokenIdAndIndex(_tokenId, _index);\n        emit CancelBidToken(_msgSender(), _tokenId);\n    }\n    function getBidsLength(uint256 _tokenId) public view returns (uint256) {\n        return _tokenBids[_tokenId].length;\n    }\n    function getBids(uint256 _tokenId) public view returns (BidEntry[] memory) {\n        return _tokenBids[_tokenId];\n    }\n    function getUserBids(address user) public view returns (UserBidEntry[] memory) {\n        uint256 len = _userBids[user].length();\n        UserBidEntry[] memory bids = new UserBidEntry[](len);\n        for (uint256 i = 0; i < len; i++) {\n            (uint256 tokenId, uint256 price) = _userBids[user].at(i);\n            bids[i] = UserBidEntry({tokenId: tokenId, price: price});\n        }\n        return bids;\n    }\n}"}}}