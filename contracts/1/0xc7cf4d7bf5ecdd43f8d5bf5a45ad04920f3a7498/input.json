{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/interfaces/v3pool.sol":{"content":"pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface v3pool {\n  function swap(address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data) external payable returns (int256 amount0, int256 amount1);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n    \n    function fee() external view returns (uint24);\n\n}\n"},"contracts/keeparb.sol":{"content":"pragma solidity >=0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport './lib/SafeMath.sol';\r\nimport './interfaces/v3pool.sol';\r\n\r\n\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint value) external returns (bool);\r\n}\r\n\r\ninterface IWETH{\r\n    function deposit() external payable;\r\n    function withdraw(uint wad) external;\r\n}\r\n\r\n\r\ninterface v2pool{\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\n\r\ninterface vendingmachine{\r\n    function conversionToT(uint256 amount)\r\n        external\r\n        returns (uint256 tAmount, uint256 wrappedRemainder);\r\n\r\n    function conversionFromT(uint256 amount)\r\n        external\r\n        returns (uint256 wrappedAmount, uint256 tRemainder);\r\n\r\n    function wrap(uint256 amount) external;\r\n\r\n    function unwrap(uint256 amount) external;\r\n\r\n}\r\n\r\n\r\n\r\ninterface v3quoter{\r\n  function quoteExactInputSingle(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint24 fee,\r\n        uint256 amountIn,\r\n        uint160 sqrtPriceLimitX96\r\n    ) external returns (uint256 amountOut);\r\n}\r\n\r\n\r\ninterface curvepool{\r\n    function get_dy(uint256 i , uint256 j, uint256 dx) external view returns (uint256 dy);\r\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external payable returns (uint256 dy);\r\n}\r\n\r\n\r\n\r\ncontract keeptarb {\r\n    using SafeMath for uint;\r\n    \r\n    address payable public owner;\r\n    \r\n    address quoter_addr = address(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6);\r\n    \r\n    v3quoter quoter = v3quoter(quoter_addr);\r\n\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n\r\n        // approve keep and t for the vendingmachine\r\n        IERC20(address(0x85Eee30c52B0b379b046Fb0F85F4f3Dc3009aFEC)).approve(address(0xE47c80e8c23f6B4A1aE41c34837a0599D5D16bb0), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n        IERC20(address(0xCdF7028ceAB81fA0C6971208e83fa7872994beE5)).approve(address(0xE47c80e8c23f6B4A1aE41c34837a0599D5D16bb0), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n\r\n        // approve t for the curve \r\n\r\n        IERC20(address(0xCdF7028ceAB81fA0C6971208e83fa7872994beE5)).approve(address(0x752eBeb79963cf0732E9c0fec72a49FD1DEfAEAC), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n\r\n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).approve(address(0x752eBeb79963cf0732E9c0fec72a49FD1DEfAEAC), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n\r\n    }\r\n    \r\n    modifier onlyowner{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    receive() external payable {}\r\n\r\n\r\n    function deposit() payable external{\r\n    }\r\n\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\r\n    }\r\n    \r\n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\r\n        _safeTransfer(tokenaddr, owner, amount);\r\n    }\r\n    \r\n\r\n    function withdrawethamount(uint amount) external onlyowner {\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    function approvetoken(address token, address target) external onlyowner{\r\n        IERC20(token).approve(target, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    function uniswapV3SwapCallback(\r\n        int256 amount0Delta,\r\n        int256 amount1Delta,\r\n        bytes calldata _data\r\n    ) external {\r\n        (uint256 flag) = abi.decode(_data, (uint256));\r\n        \r\n        if(flag == 0){\r\n            // selling T\r\n            _safeTransfer(0xCdF7028ceAB81fA0C6971208e83fa7872994beE5, msg.sender, uint256(amount1Delta));\r\n\r\n        }else{\r\n            // unwrap T\r\n            vendingmachine(address(0xE47c80e8c23f6B4A1aE41c34837a0599D5D16bb0)).unwrap(uint256(-amount1Delta));\r\n\r\n            _safeTransfer(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), msg.sender, uint256(amount0Delta));\r\n\r\n       }\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata _data) external {\r\n    \r\n        (uint256 sellpath, bool direct, uint256 bestin, uint256 v2out, uint256 v3amount)  = abi.decode(_data, (uint256, bool, uint256, uint256, uint256));\r\n\r\n\r\n        if(sellpath == 0){\r\n            // sell on v3\r\n            if(direct){\r\n\r\n                // wrap keep to T\r\n                vendingmachine(address(0xE47c80e8c23f6B4A1aE41c34837a0599D5D16bb0)).wrap(v2out);\r\n\r\n                // sell T on v3, v3amount is the T in\r\n                v3pool(address(0x286EB8405231A2201FCb75b6e33098A546216C86)).swap(address(this), false, int256(v3amount), 1461446703485210103287273052203988822378723970342 - 1, abi.encode(0));\r\n\r\n                // send back weth\r\n                _safeTransfer(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), msg.sender, bestin);\r\n\r\n\r\n            }else{\r\n\r\n                // buy t on v3 and unwrap to keep\r\n                v3pool(address(0x286EB8405231A2201FCb75b6e33098A546216C86)).swap(address(this), true, int256(bestin), 4295128739 + 1, abi.encode(1));\r\n\r\n                _safeTransfer(address(0x85Eee30c52B0b379b046Fb0F85F4f3Dc3009aFEC), msg.sender, v3amount);\r\n\r\n\r\n            }\r\n\r\n        }\r\n\r\n        if(sellpath == 1){\r\n            if(direct){\r\n                // wrap keep to T\r\n                vendingmachine(address(0xE47c80e8c23f6B4A1aE41c34837a0599D5D16bb0)).wrap(v2out);\r\n\r\n                // sell T on curve\r\n                curvepool(address(0x752eBeb79963cf0732E9c0fec72a49FD1DEfAEAC)).exchange(1, 0 , v3amount, 0);\r\n\r\n                _safeTransfer(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), msg.sender, bestin);\r\n\r\n            }else{\r\n\r\n                // IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).withdraw(bestin);\r\n\r\n                uint256 tamount = curvepool(address(0x752eBeb79963cf0732E9c0fec72a49FD1DEfAEAC)).exchange(0, 1 , bestin, 0);\r\n\r\n                // unwrap t\r\n                vendingmachine(address(0xE47c80e8c23f6B4A1aE41c34837a0599D5D16bb0)).unwrap(tamount);\r\n\r\n                // pay back keep\r\n                _safeTransfer(address(0x85Eee30c52B0b379b046Fb0F85F4f3Dc3009aFEC), msg.sender, v3amount);\r\n\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    function keepv3arb(bool direct, uint256 bestin, uint256 v2out, uint256 amount) public payable{\r\n\r\n        require(block.number <= msg.value, \"fuck\");\r\n\r\n        uint256 gasstart = gasleft();\r\n\r\n        if(direct){\r\n            // weth -> keep -> t -> weth(v3), amount is the T into v3 pool\r\n            bytes memory data = abi.encode(0, direct, bestin, v2out, amount);\r\n            v2pool(address(0xE6f19dAb7d43317344282F803f8E8d240708174a)).swap(v2out, 0, address(this), data);\r\n\r\n        }else{\r\n            // weth -> t(v3) -> keep -> weth, the amount is used for the keep we repay\r\n            bytes memory data = abi.encode(0, direct, bestin, 0, amount);\r\n            v2pool(address(0xE6f19dAb7d43317344282F803f8E8d240708174a)).swap(0, v2out, address(this), data);\r\n\r\n        }\r\n\r\n\r\n        uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\r\n\r\n        require(weth_balance > tx.gasprice * (gasstart - gasleft()), \"i\");\r\n        \r\n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, weth_balance - 1);\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    function keepcurvearb(bool direct, uint256 bestin, uint256 v2out, uint256 amount) public payable{\r\n\r\n        require(block.number <= msg.value, \"fuck\");\r\n\r\n        uint256 gasstart = gasleft();\r\n\r\n        if(direct){\r\n            // weth -> keep -> t -> eth(curve), amount is the T into v3 pool\r\n            bytes memory data = abi.encode(1, direct, bestin, v2out, amount);\r\n            v2pool(address(0xE6f19dAb7d43317344282F803f8E8d240708174a)).swap(v2out, 0, address(this), data);\r\n\r\n        }else{\r\n            // weth -> t(v3) -> keep -> weth, the amount is used for the keep we repay\r\n            bytes memory data = abi.encode(1, direct, bestin, 0, amount);\r\n            v2pool(address(0xE6f19dAb7d43317344282F803f8E8d240708174a)).swap(0, v2out, address(this), data);\r\n\r\n        }\r\n\r\n\r\n        uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\r\n\r\n        require(weth_balance > tx.gasprice * (gasstart - gasleft()), \"i\");\r\n        \r\n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, weth_balance - 1);\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function v3out(address tokenIn, address tokenOut, uint24 fee, uint256 amountIn) private returns (uint256 amountOut) {\r\n        amountOut = quoter.quoteExactInputSingle(tokenIn, tokenOut, fee, amountIn, 0);\r\n    }\r\n\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    } \r\n  \r\n\r\n    function detectarbv3(uint256 lowerbound, uint256 higherbound , uint256 step) public returns(uint256 bestin, uint256 bestprofit, uint256 best_keep_out, uint256 tout, uint256 bestin2, uint256 bestprofit2, uint256 bestv2wethout, uint256 keeprepay){\r\n        bytes memory returnData;\r\n        (, returnData) = address(0xE6f19dAb7d43317344282F803f8E8d240708174a).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n        (uint r0, uint r1, ) = abi.decode(returnData, (uint,uint,uint)); // gohm fdt\r\n\r\n\r\n        uint256 weth_in = lowerbound;\r\n\r\n        while(weth_in < higherbound){\r\n\r\n            uint256 keep_out = getAmountOut(weth_in, r1, r0);\r\n\r\n            (uint256 t_out, ) = vendingmachine(address(0xE47c80e8c23f6B4A1aE41c34837a0599D5D16bb0)).conversionToT(keep_out);\r\n\r\n            uint256 v3_weth_out = v3out(address(0xCdF7028ceAB81fA0C6971208e83fa7872994beE5), address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), 10000, t_out);\r\n\r\n\r\n            if(v3_weth_out <  weth_in){\r\n                break;\r\n            }\r\n\r\n            if(v3_weth_out - weth_in < bestprofit){\r\n                break;\r\n            }else{\r\n                bestprofit = v3_weth_out - weth_in;\r\n                bestin = weth_in;\r\n                tout = t_out;\r\n                best_keep_out = keep_out;\r\n                weth_in = weth_in + step;\r\n            }\r\n        }\r\n\r\n\r\n        weth_in = lowerbound;\r\n\r\n\r\n        while(weth_in < higherbound){\r\n\r\n            uint256 t_out = v3out(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), address(0xCdF7028ceAB81fA0C6971208e83fa7872994beE5), 10000, weth_in);\r\n\r\n            (uint256 keep_out, ) = vendingmachine(address(0xE47c80e8c23f6B4A1aE41c34837a0599D5D16bb0)).conversionFromT(t_out);\r\n\r\n\r\n            uint256 v2_weth_out = getAmountOut(keep_out, r0, r1);\r\n\r\n\r\n            if(v2_weth_out < weth_in){\r\n                break;\r\n            }\r\n\r\n            if(v2_weth_out - weth_in < bestprofit2){\r\n                break;\r\n            }else{\r\n                bestprofit2 = v2_weth_out - weth_in;\r\n                bestin2 = weth_in;\r\n                bestv2wethout = v2_weth_out;\r\n                keeprepay = keep_out;\r\n                weth_in = weth_in + step;\r\n            }\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    function detectarbcurve(uint256 lowerbound, uint256 higherbound , uint256 step) public returns(uint256 bestin, uint256 bestprofit, uint256 best_keep_out, uint256 tout, uint256 bestin2, uint256 bestprofit2, uint256 bestv2wethout, uint256 keeprepay){\r\n        bytes memory returnData;\r\n        (, returnData) = address(0xE6f19dAb7d43317344282F803f8E8d240708174a).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n        (uint r0, uint r1, ) = abi.decode(returnData, (uint,uint,uint)); // gohm fdt\r\n\r\n\r\n        uint256 weth_in = lowerbound;\r\n\r\n        while(weth_in < higherbound){\r\n\r\n            uint256 keep_out = getAmountOut(weth_in, r1, r0);\r\n\r\n            (uint256 t_out, ) = vendingmachine(address(0xE47c80e8c23f6B4A1aE41c34837a0599D5D16bb0)).conversionToT(keep_out);\r\n\r\n\r\n            uint256 curve_eth_out = curvepool(address(0x752eBeb79963cf0732E9c0fec72a49FD1DEfAEAC)).get_dy(1, 0 , t_out);\r\n\r\n\r\n            if(curve_eth_out <  weth_in){\r\n                break;\r\n            }\r\n\r\n            if(curve_eth_out - weth_in < bestprofit){\r\n                break;\r\n            }else{\r\n                bestprofit = curve_eth_out - weth_in;\r\n                bestin = weth_in;\r\n                tout = t_out;\r\n                best_keep_out = keep_out;\r\n                weth_in = weth_in + step;\r\n            }\r\n        }\r\n\r\n\r\n        weth_in = lowerbound;\r\n\r\n\r\n        while(weth_in < higherbound){\r\n\r\n            uint256 t_out = curvepool(address(0x752eBeb79963cf0732E9c0fec72a49FD1DEfAEAC)).get_dy(0, 1 , weth_in);\r\n\r\n            (uint256 keep_out, ) = vendingmachine(address(0xE47c80e8c23f6B4A1aE41c34837a0599D5D16bb0)).conversionFromT(t_out);\r\n\r\n\r\n            uint256 v2_weth_out = getAmountOut(keep_out, r0, r1);\r\n\r\n\r\n            if(v2_weth_out < weth_in){\r\n                break;\r\n            }\r\n\r\n            if(v2_weth_out - weth_in < bestprofit2){\r\n                break;\r\n            }else{\r\n                bestprofit2 = v2_weth_out - weth_in;\r\n                bestin2 = weth_in;\r\n                bestv2wethout = v2_weth_out;\r\n                keeprepay = keep_out;\r\n                weth_in = weth_in + step;\r\n            }\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n}"},"contracts/lib/SafeMath.sol":{"content":"pragma solidity >=0.6.6;\n\n// SPDX-License-Identifier: MIT\n\nlibrary SafeMath {\n\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n        return c;\n    }\n\n    function mul(uint a, uint b) internal pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n        return c;\n    }\n\n}"}}}