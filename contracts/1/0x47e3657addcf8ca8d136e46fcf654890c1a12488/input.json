{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Bouts.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\npragma abicoder v2;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\n\ncontract Bouts {\n    using SafeMath for uint256;\n\n    struct CompensationPlan {\n        uint8 id;\n        uint256 differentialDirectIncome;\n        uint256 commissionable;\n        uint256 points;\n        uint256 stakingPeriod;\n        uint256 minimumAmount;\n        uint256 maximumAmount;\n        uint256 rateOfInterest;\n    }\n\n    struct BonusPlan {\n        uint8 level;\n        uint8 bonus;\n        uint8 points;\n    }\n\n    struct PackageLimit {\n        uint256 investmentLimit;\n        uint256 investmentMade;\n        uint256 timeLimit;\n        uint256 limit;\n        uint256 dailyLimit;\n        uint256 nextReset;\n        uint256[] lastSubscribers;\n    }\n\n    struct Subscription {\n        bool isActive;\n        uint8 compensationPlanID;\n        uint256 startTime;\n        uint256 lastWithdrawedTime;\n        uint256 amountInvested;\n        uint256 amountWithdrawed;\n    }\n\n    struct User {\n        uint256 id;\n        uint256 leadershipDevelopmentBonus;\n        uint256 earlyBirdIncentive;\n        uint256 reward;\n        address referrer;\n        uint256 points;\n        uint256 levelBonus;\n        uint256 withdrawedROI;\n        uint256 totalDirectIncome;\n        uint256 scholarshipFund;\n        uint256 differentialDirectIncome;\n        uint256[2] paymentTimestamp;\n        Subscription[] subscriptions;\n    }\n\n    event UserRegistered(\n        uint256 id,\n        address user,\n        address referrer,\n        uint256 timestamp\n    );\n    event UserSubscribed(\n        address userAddress,\n        uint8 compensationPlanID,\n        uint256 amount,\n        uint256 timestamp\n    );\n    event DifferentialDirectIncomeSent(\n        address referee,\n        address referrer,\n        uint256 amount,\n        uint256 level,\n        uint256 timestamp\n    );\n    event EarlyBirdIncentiveSent(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 timestamp\n    );\n    event LeadershipDevelopmentBonus(\n        address to,\n        uint256 amount,\n        uint256 timestamp\n    );\n    event LevelBonusSent(\n        address referee,\n        address referrer,\n        uint256 amount,\n        uint256 level,\n        uint256 timestamp\n    );\n    event UserWithdrawed(address user, uint256 amount, uint256 timestamp);\n    event Points(address user, uint256 points, uint256 timestamp);\n    event ScholarshipFund(\n        address owner,\n        address user,\n        uint256 amount,\n        uint256 timestamp\n    );\n    event RewardsAdded(\n        address userAddress,\n        uint256 planID,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    uint256 public userIdCounter;\n    address public OWNER;\n    address public TOKEN_CONTRACT;\n    address public SCHOLARSHIP_ADDRESS;\n    address public REFERRAL_BONUS_ADDRESS;\n    address public REWARDS_BONUS_ADDRESS;\n    address public STAKING_BONUS_ADDRESS;\n    address public LEVEL_BONUS_ADDRESS;\n    uint8 private ROI_MULTIPLIER;\n    uint256 private DAYS_IN_SECONDS;\n\n    mapping(uint8 => CompensationPlan) public compensationPlans;\n    mapping(uint8 => BonusPlan) public bonusPlan;\n    mapping(uint8 => PackageLimit) public packageLimit;\n    mapping(address => User) public users;\n    mapping(uint256 => address) public userIds;\n\n    constructor(address boutsTokenContract) {\n        ROI_MULTIPLIER = 100;\n        DAYS_IN_SECONDS = 1 days;\n        TOKEN_CONTRACT = boutsTokenContract;\n        OWNER = msg.sender;\n\n        SCHOLARSHIP_ADDRESS = 0xd12F6103902B4375fa91320Ee6f86bdA33Ed11Bb;\n        REFERRAL_BONUS_ADDRESS = 0x64B434265CF6DF7B4276CA1E063A187010c24470;\n        REWARDS_BONUS_ADDRESS = 0xe94e9B674b5833B4C6cBfA96bDB9FF4A76774f44;\n        STAKING_BONUS_ADDRESS = 0xDEd48389ebaaD8085bD9B1f5e438f14A021348fB;\n        LEVEL_BONUS_ADDRESS = 0x8d333A890DFABD4faC5604136F819CaE79dCe488;\n\n        _addCompensationPlans();\n        _addLevelBonus();\n        _addPackageLimits();\n\n        users[msg.sender].id = ++userIdCounter;\n        userIds[userIdCounter] = msg.sender;\n        users[msg.sender].subscriptions.push(\n            Subscription(true, 4, block.timestamp, 0, 0, 0)\n        );\n        users[msg.sender].paymentTimestamp[0] = block.timestamp;\n        users[msg.sender].paymentTimestamp[1] =\n            block.timestamp +\n            10000 *\n            DAYS_IN_SECONDS;\n    }\n\n    function subscribe(uint8 compensationPlanID, address referrer) public {\n        User storage user = users[msg.sender];\n        require(\n            compensationPlans[compensationPlanID].minimumAmount != 0,\n            \"Invalid plan id\"\n        );\n\n        if (user.id == 0) {\n            if (referrer == address(0)) referrer = OWNER;\n            require(users[referrer].id != 0, \"Invaild Referrer\");\n            userIdCounter = userIdCounter.add(1);\n            user.id = userIdCounter;\n            user.referrer = referrer;\n            userIds[userIdCounter] = msg.sender;\n            user.paymentTimestamp[0] = block.timestamp;\n            user.paymentTimestamp[1] = user.paymentTimestamp[0].add(\n                DAYS_IN_SECONDS.mul(30)\n            );\n            emit UserRegistered(\n                userIdCounter,\n                msg.sender,\n                referrer,\n                block.timestamp\n            );\n        }\n        if (user.subscriptions.length != 0)\n            require(\n                user.subscriptions[user.subscriptions.length - 1]\n                    .compensationPlanID < compensationPlanID,\n                \"Cannot subscribe plan\"\n            );\n\n        IERC20 boutsToken = IERC20(TOKEN_CONTRACT);\n        uint256 amount = boutsToken.allowance(msg.sender, address(this));\n        // uint256 amount = compensationPlans[compensationPlanID].minimumAmount;\n        _checkPackageLimit(compensationPlanID, amount);\n        require(\n            amount >= compensationPlans[compensationPlanID].minimumAmount &&\n                amount <= compensationPlans[compensationPlanID].maximumAmount,\n            \"Invalid staking amount\"\n        );\n\n        Subscription memory subscription;\n\n        subscription.compensationPlanID = compensationPlanID;\n        subscription.startTime = block.timestamp;\n        subscription.amountInvested = amount;\n        subscription.isActive = true;\n        user.subscriptions.push(subscription);\n\n        boutsToken.transferFrom(msg.sender, address(this), amount);\n        users[user.referrer].points = users[user.referrer].points.add(\n            compensationPlans[compensationPlanID].points\n        );\n\n        _giveDifferentialDirectIncome(user, amount);\n        _giveEarlyBirdIncentive(users[user.referrer]);\n\n        emit UserSubscribed(\n            msg.sender,\n            compensationPlanID,\n            amount,\n            block.timestamp\n        );\n        emit Points(\n            user.referrer,\n            users[user.referrer].points,\n            block.timestamp\n        );\n    }\n\n    function withdraw(\n        bool rateOfInterest,\n        bool differentialDirectIncome,\n        bool earlyBirdIncentive,\n        bool leadershipDevelopmentBonus,\n        bool levelBonus,\n        bool rewards\n    ) public {\n        User storage user = users[msg.sender];\n        IERC20 boutsToken = IERC20(TOKEN_CONTRACT);\n        uint256 amount;\n        if (differentialDirectIncome) {\n            amount = amount.add(user.differentialDirectIncome);\n            boutsToken.transferFrom(\n                REFERRAL_BONUS_ADDRESS,\n                msg.sender,\n                user.differentialDirectIncome\n            );\n            user.differentialDirectIncome = 0;\n        }\n        if (earlyBirdIncentive) {\n            amount = amount.add(user.earlyBirdIncentive);\n            boutsToken.transferFrom(\n                REWARDS_BONUS_ADDRESS,\n                msg.sender,\n                user.earlyBirdIncentive\n            );\n            user.earlyBirdIncentive = 0;\n        }\n        if (leadershipDevelopmentBonus) {\n            amount = amount.add(user.leadershipDevelopmentBonus);\n            boutsToken.transferFrom(\n                REWARDS_BONUS_ADDRESS,\n                msg.sender,\n                user.leadershipDevelopmentBonus\n            );\n            user.leadershipDevelopmentBonus = 0;\n        }\n        if (rateOfInterest) {\n            (uint256 roi, uint256 principalAmount) =\n                calculateRateOfInterest(msg.sender);\n            amount = amount.add(roi);\n            user.withdrawedROI = user.withdrawedROI.add(roi);\n            _shareLevelIncome(roi);\n\n            boutsToken.transferFrom(STAKING_BONUS_ADDRESS, msg.sender, roi);\n\n            if (principalAmount != 0) {\n                user.withdrawedROI = user.withdrawedROI.add(principalAmount);\n                boutsToken.transfer(msg.sender, principalAmount);\n            }\n        }\n        if (levelBonus) {\n            amount = amount.add(user.levelBonus);\n            boutsToken.transferFrom(\n                LEVEL_BONUS_ADDRESS,\n                msg.sender,\n                user.reward\n            );\n            user.levelBonus = 0;\n        }\n        if (rewards) {\n            amount = amount.add(user.reward);\n            boutsToken.transferFrom(\n                REWARDS_BONUS_ADDRESS,\n                msg.sender,\n                user.reward\n            );\n            user.reward = 0;\n        }\n\n        require(amount != 0, \"Invalid withdrawal amount\");\n\n        // boutsToken.transfer(msg.sender, amount);\n\n        emit UserWithdrawed(msg.sender, amount, block.timestamp);\n    }\n\n    function giveLeadershipDevelopmentBonus(\n        address[] calldata userAddresses,\n        uint256[] calldata amount\n    ) public {\n        require(msg.sender == OWNER, \"Only owner can call this function\");\n        for (uint256 index = 0; index < userAddresses.length; index++) {\n            users[userAddresses[index]].leadershipDevelopmentBonus = amount[\n                index\n            ];\n\n            emit LeadershipDevelopmentBonus(\n                userAddresses[index],\n                amount[index],\n                block.timestamp\n            );\n        }\n    }\n\n    function getPaymentTimestamp(address userAddress)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        return (\n            users[userAddress].paymentTimestamp[0],\n            users[userAddress].paymentTimestamp[1]\n        );\n    }\n\n    function getSubscriptions(address userAddress)\n        public\n        view\n        returns (Subscription[] memory)\n    {\n        return users[userAddress].subscriptions;\n    }\n\n    function donateToScholarshipFund() public {\n        User storage user = users[msg.sender];\n        user.paymentTimestamp[0] = block.timestamp;\n        user.paymentTimestamp[1] = user.paymentTimestamp[0].add(\n            DAYS_IN_SECONDS.mul(30)\n        );\n\n        IERC20 boutsToken = IERC20(TOKEN_CONTRACT);\n        uint256 amount = boutsToken.allowance(msg.sender, address(this));\n        require(amount >= user.scholarshipFund, \"Invalid scholarship amount\");\n        boutsToken.transferFrom(msg.sender, SCHOLARSHIP_ADDRESS, amount);\n\n        emit ScholarshipFund(\n            SCHOLARSHIP_ADDRESS,\n            msg.sender,\n            user.scholarshipFund,\n            block.timestamp\n        );\n\n        user.scholarshipFund = 0;\n    }\n\n    function _addCompensationPlans() private {\n        compensationPlans[1] = CompensationPlan(\n            1,\n            5,\n            5,\n            1,\n            200 * DAYS_IN_SECONDS,\n            1000e18,\n            10000e18 - 1,\n            uint256(ROI_MULTIPLIER).div(2)\n        );\n\n        compensationPlans[2] = CompensationPlan(\n            2,\n            10,\n            10,\n            2,\n            300 * DAYS_IN_SECONDS,\n            10000e18,\n            50000e18 - 1,\n            uint256(ROI_MULTIPLIER).mul(3).div(4)\n        );\n\n        compensationPlans[3] = CompensationPlan(\n            3,\n            15,\n            15,\n            4,\n            400 * DAYS_IN_SECONDS,\n            50000e18,\n            100000e18 - 1,\n            ROI_MULTIPLIER\n        );\n\n        compensationPlans[4] = CompensationPlan(\n            4,\n            20,\n            20,\n            8,\n            500 * DAYS_IN_SECONDS,\n            100000e18,\n            150000e18,\n            uint256(ROI_MULTIPLIER).mul(5).div(4)\n        );\n    }\n\n    function _addLevelBonus() private {\n        bonusPlan[1] = BonusPlan(1, 20, 2);\n        bonusPlan[2] = BonusPlan(2, 5, 4);\n        bonusPlan[3] = BonusPlan(3, 5, 12);\n        bonusPlan[4] = BonusPlan(4, 5, 20);\n        bonusPlan[5] = BonusPlan(5, 5, 26);\n        bonusPlan[6] = BonusPlan(6, 5, 38);\n        bonusPlan[7] = BonusPlan(7, 5, 46);\n        bonusPlan[8] = BonusPlan(8, 5, 62);\n        bonusPlan[9] = BonusPlan(9, 5, 78);\n        bonusPlan[10] = BonusPlan(10, 5, 94);\n        bonusPlan[11] = BonusPlan(11, 20, 108);\n    }\n\n    function _addPackageLimits() private {\n        uint256 nextReset =\n            block.timestamp + (block.timestamp % DAYS_IN_SECONDS);\n        packageLimit[1].investmentLimit = 10e25;\n        packageLimit[1].timeLimit = block.timestamp + 400 * DAYS_IN_SECONDS;\n        packageLimit[2].investmentLimit = 75e24;\n        packageLimit[2].timeLimit = block.timestamp + 300 * DAYS_IN_SECONDS;\n        packageLimit[3].dailyLimit = 20;\n        packageLimit[3].investmentLimit = 5e25;\n        packageLimit[3].timeLimit = block.timestamp + 200 * DAYS_IN_SECONDS;\n        packageLimit[3].nextReset = nextReset;\n        packageLimit[4].dailyLimit = 5;\n        packageLimit[4].investmentLimit = 25e24;\n        packageLimit[4].timeLimit = block.timestamp + 100 * DAYS_IN_SECONDS;\n        packageLimit[4].nextReset = nextReset;\n    }\n\n    function _checkPackageLimit(uint8 compensationPlanID, uint256 amount)\n        private\n    {\n        require(\n            packageLimit[compensationPlanID].investmentLimit >=\n                packageLimit[compensationPlanID].investmentMade + amount,\n            \"Cannot stake tokens, limit exceeded\"\n        );\n        require(\n            packageLimit[compensationPlanID].timeLimit >= block.timestamp,\n            \"Investment time exceeded\"\n        );\n\n        if (compensationPlanID > 2)\n            require(\n                _checkDailyPackageLimit(compensationPlanID),\n                \"Daily plan subscription limit reached\"\n            );\n\n        packageLimit[compensationPlanID].investmentMade += amount;\n    }\n\n    function _checkDailyPackageLimit(uint8 compensationPlanID)\n        private\n        returns (bool)\n    {\n        PackageLimit storage package = packageLimit[compensationPlanID];\n\n        if (block.timestamp >= package.nextReset) {\n            uint256 nextReset =\n                block.timestamp + (block.timestamp % DAYS_IN_SECONDS);\n            package.nextReset = nextReset;\n            delete package.lastSubscribers;\n        }\n\n        if (package.lastSubscribers.length < package.dailyLimit) {\n            package.lastSubscribers.push(block.timestamp);\n            return true;\n        }\n\n        return false;\n    }\n\n    function _giveDifferentialDirectIncome(\n        User memory user,\n        uint256 totalAmount\n    ) private {\n        User storage referrer = users[user.referrer];\n        bool[4] memory distributedPlans;\n        uint256 referrerDifferentialDirectIncome;\n        uint256 commissionableLeft;\n        uint8 planID = 0;\n        uint256 amount = 0;\n        bool paymentMissed = false;\n        address referrerAddress;\n\n        for (uint256 index = 0; index < user.subscriptions.length; index++)\n            if (\n                commissionableLeft <\n                compensationPlans[user.subscriptions[index].compensationPlanID]\n                    .commissionable\n            )\n                commissionableLeft = compensationPlans[\n                    user.subscriptions[index].compensationPlanID\n                ]\n                    .commissionable;\n\n        for (\n            uint256 index = 1;\n            commissionableLeft > 0 &&\n                !(distributedPlans[0] == true &&\n                    distributedPlans[1] == true &&\n                    distributedPlans[2] == true &&\n                    distributedPlans[3] == true);\n            index++\n        ) {\n            if (referrer.referrer == address(0)) {\n                amount = amount.add(\n                    totalAmount.mul(commissionableLeft).div(100)\n                );\n\n                referrer.differentialDirectIncome = referrer\n                    .differentialDirectIncome\n                    .add(amount);\n\n                referrer.scholarshipFund = referrer.scholarshipFund.add(\n                    amount.div(10)\n                );\n\n                referrer.totalDirectIncome = referrer.totalDirectIncome.add(\n                    amount\n                );\n                emit DifferentialDirectIncomeSent(\n                    userIds[user.id],\n                    userIds[referrer.id],\n                    amount,\n                    index,\n                    block.timestamp\n                );\n                commissionableLeft = 0;\n                break;\n            }\n\n            for (\n                uint256 planIdIndex;\n                planIdIndex < referrer.subscriptions.length;\n                planIdIndex++\n            )\n                if (\n                    planID <\n                    referrer.subscriptions[planIdIndex].compensationPlanID\n                )\n                    planID = referrer.subscriptions[planIdIndex]\n                        .compensationPlanID;\n\n            planID--;\n            if (distributedPlans[planID]) continue;\n            for (\n                uint256 subscriptionIndex = 0;\n                subscriptionIndex < referrer.subscriptions.length;\n                subscriptionIndex++\n            ) {\n                if (\n                    compensationPlans[\n                        referrer.subscriptions[subscriptionIndex]\n                            .compensationPlanID\n                    ]\n                        .differentialDirectIncome >\n                    referrerDifferentialDirectIncome\n                )\n                    referrerDifferentialDirectIncome = compensationPlans[\n                        referrer.subscriptions[subscriptionIndex]\n                            .compensationPlanID\n                    ]\n                        .differentialDirectIncome;\n            }\n\n            if (\n                referrer.paymentTimestamp[1] - referrer.paymentTimestamp[0] >\n                30 * DAYS_IN_SECONDS\n            ) {\n                paymentMissed = true;\n                referrerAddress = userIds[referrer.id];\n                emit DifferentialDirectIncomeSent(\n                    userIds[user.id],\n                    userIds[referrer.id],\n                    0,\n                    index,\n                    block.timestamp\n                );\n                referrer = users[OWNER];\n            }\n\n            if (commissionableLeft <= referrerDifferentialDirectIncome) {\n                amount = amount.add(\n                    totalAmount.mul(commissionableLeft).div(100)\n                );\n                referrer.differentialDirectIncome = referrer\n                    .differentialDirectIncome\n                    .add(amount);\n                referrer.scholarshipFund = referrer.scholarshipFund.add(\n                    amount.div(10)\n                );\n                referrer.totalDirectIncome = referrer.totalDirectIncome.add(\n                    amount\n                );\n\n                emit DifferentialDirectIncomeSent(\n                    userIds[user.id],\n                    userIds[referrer.id],\n                    amount,\n                    index,\n                    block.timestamp\n                );\n                commissionableLeft = 0;\n            } else {\n                amount = amount.add(\n                    totalAmount.mul(referrerDifferentialDirectIncome).div(100)\n                );\n                referrer.differentialDirectIncome = referrer\n                    .differentialDirectIncome\n                    .add(amount);\n                referrer.scholarshipFund = referrer.scholarshipFund.add(\n                    amount.div(10)\n                );\n\n                referrer.totalDirectIncome = referrer.totalDirectIncome.add(\n                    amount\n                );\n\n                emit DifferentialDirectIncomeSent(\n                    userIds[user.id],\n                    userIds[referrer.id],\n                    amount,\n                    index,\n                    block.timestamp\n                );\n                commissionableLeft = commissionableLeft.sub(\n                    referrerDifferentialDirectIncome\n                );\n            }\n\n            distributedPlans[planID] = true;\n\n            if (paymentMissed) {\n                referrerAddress = userIds[referrer.id];\n                referrer = users[referrerAddress];\n            }\n\n            if (referrer.referrer == address(0)) break;\n            referrer = users[referrer.referrer];\n            amount = 0;\n        }\n    }\n\n    function _giveEarlyBirdIncentive(User storage user) private {\n        if (\n            block.timestamp.sub(user.subscriptions[0].startTime) <=\n            60 * DAYS_IN_SECONDS\n        )\n            if (user.points >= 94 && user.earlyBirdIncentive != 2500e18) {\n                user.earlyBirdIncentive = 2500e18;\n                emit EarlyBirdIncentiveSent(\n                    msg.sender,\n                    userIds[user.id],\n                    user.earlyBirdIncentive,\n                    block.timestamp\n                );\n            } else if (\n                user.points >= 78 && user.earlyBirdIncentive != 1000e18\n            ) {\n                user.earlyBirdIncentive = 1000e18;\n                emit EarlyBirdIncentiveSent(\n                    msg.sender,\n                    userIds[user.id],\n                    user.earlyBirdIncentive,\n                    block.timestamp\n                );\n            }\n    }\n\n    function _shareLevelIncome(uint256 amount_) private {\n        User storage user = users[users[msg.sender].referrer];\n        uint256 amount;\n        uint8 planID = 0;\n\n        for (\n            uint256 planIdIndex;\n            planIdIndex < user.subscriptions.length;\n            planIdIndex++\n        ) {\n            if (planID < user.subscriptions[planIdIndex].compensationPlanID)\n                planID = user.subscriptions[planIdIndex].compensationPlanID;\n        }\n\n        for (uint8 index = 1; index <= 11; index++) {\n            if (index == 11 && planID != 4) continue;\n            amount = amount_.mul(bonusPlan[index].bonus).div(100);\n            if (\n                user.points < bonusPlan[index].points ||\n                user.paymentTimestamp[1] - user.paymentTimestamp[0] >\n                30 * DAYS_IN_SECONDS\n            ) {\n                users[OWNER].levelBonus = users[OWNER].levelBonus.add(amount);\n                users[OWNER].scholarshipFund = users[OWNER].scholarshipFund.add(\n                    amount.div(10)\n                );\n\n                emit LevelBonusSent(\n                    msg.sender,\n                    OWNER,\n                    amount,\n                    index,\n                    block.timestamp\n                );\n                emit LevelBonusSent(\n                    msg.sender,\n                    userIds[user.id],\n                    0,\n                    index,\n                    block.timestamp\n                );\n            } else {\n                user.levelBonus = user.levelBonus.add(amount);\n                user.scholarshipFund = user.scholarshipFund.add(amount.div(10));\n\n                emit LevelBonusSent(\n                    msg.sender,\n                    userIds[user.id],\n                    amount,\n                    index,\n                    block.timestamp\n                );\n            }\n\n            amount = 0;\n            if (user.referrer == address(0)) break;\n            user = users[user.referrer];\n        }\n    }\n\n    function giveRewards(\n        address[] calldata userAddress,\n        uint256[] calldata planID,\n        uint256[] calldata rewards\n    ) public {\n        require(msg.sender == OWNER, \"Only owner can call this function\");\n\n        for (uint256 index = 0; index < userAddress.length; index++) {\n            users[userAddress[index]].reward = users[userAddress[index]]\n                .reward\n                .add(rewards[index]);\n            emit RewardsAdded(\n                userAddress[index],\n                planID[index],\n                rewards[index],\n                block.timestamp\n            );\n        }\n    }\n\n    function calculateRateOfInterest(address userAddress)\n        public\n        returns (uint256, uint256)\n    {\n        uint256 time = 0;\n        uint256 totalAmount = 0;\n        uint256 principalAmount = 0;\n\n        User memory user = users[userAddress];\n\n        for (uint256 index = 0; index < user.subscriptions.length; index++) {\n            Subscription storage subscription =\n                users[userIds[user.id]].subscriptions[index];\n            if (!subscription.isActive) continue;\n\n            if (subscription.lastWithdrawedTime == 0) {\n                time = block.timestamp.sub(subscription.startTime);\n                if (\n                    time >\n                    compensationPlans[subscription.compensationPlanID]\n                        .stakingPeriod\n                )\n                    time = compensationPlans[subscription.compensationPlanID]\n                        .stakingPeriod;\n            } else {\n                time = subscription.lastWithdrawedTime - subscription.startTime;\n                if (\n                    block.timestamp.sub(subscription.lastWithdrawedTime).add(\n                        time\n                    ) >\n                    compensationPlans[subscription.compensationPlanID]\n                        .stakingPeriod\n                )\n                    time =\n                        compensationPlans[subscription.compensationPlanID]\n                            .stakingPeriod -\n                        time;\n                else\n                    time = block.timestamp.sub(subscription.lastWithdrawedTime);\n            }\n            time = time.div(DAYS_IN_SECONDS);\n            uint256 amount = 0;\n            amount = subscription.amountInvested;\n            amount = amount\n                .mul(time)\n                .mul(\n                compensationPlans[subscription.compensationPlanID]\n                    .rateOfInterest\n            )\n                .div(ROI_MULTIPLIER)\n                .div(100);\n\n            if (\n                subscription.startTime.add(\n                    compensationPlans[subscription.compensationPlanID]\n                        .stakingPeriod\n                ) <= block.timestamp\n            ) {\n                principalAmount = principalAmount.add(\n                    subscription.amountInvested\n                );\n                subscription.isActive = false;\n            }\n            subscription.amountWithdrawed = subscription.amountWithdrawed.add(\n                amount\n            );\n            subscription.lastWithdrawedTime = block.timestamp;\n            totalAmount = totalAmount.add(amount);\n        }\n        return (totalAmount, principalAmount);\n    }\n}\n"
    },
    "IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    }
  }
}