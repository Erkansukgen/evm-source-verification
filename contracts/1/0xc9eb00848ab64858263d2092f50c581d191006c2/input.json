{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Redeemer.sol": {
      "content": "pragma solidity 0.7.4;\n\ninterface IESDS {\n    function redeemCoupons(uint256 epoch_, uint256 couponAmount) external;\n    function transferCoupons(address sender, address recipient, uint256 epoch_, uint256 amount) external;\n    function epoch() external view returns (uint256);\n    function totalRedeemable() external view returns (uint256);\n    function balanceOfCoupons(address account_, uint256 epoch_) external view returns (uint256);\n    function advance() external;\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IFreeFromUpTo {\n    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\n}\n\ncontract Redeemer {\n\n    IERC20 constant private ESD = IERC20(0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723);\n    IESDS constant private ESDS = IESDS(0x443D2f2755DB5942601fa062Cc248aAA153313D3);\n    \n    address constant private COUPON_HOLDER = 0xC8482E19C3fcD56B499d376aB1aAd069442Ba0Cb;\n    IFreeFromUpTo public constant chi = IFreeFromUpTo(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\n\n    uint256[] private epochs;\n    \n    modifier discountCHI {\n        uint256 gasStart = gasleft();\n        _;\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\n        chi.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\n    }\n    \n    function currentBlock() external view returns (uint256, uint256, uint256) {\n        return (ESDS.epoch(), block.number, block.timestamp);\n    }\n\n    function redeem__(uint256 _targetEpoch) external discountCHI {\n        \n        // Copied from CouponClipper and optimized for gas.\n        // https://github.com/Austin-Williams/coupon-clipper/blob/89da6a20bcb78888d4624237520a9299d4dbb6e7/contracts/CouponClipper.sol#L127-L128\n        // For gas efficiency, we dont use SafeMath. Does not impact safety since this is only for checking the timestamp.\n        // In case of underflow, we return and exit the function early.\n        // In case of overflow, we will revert on the `ESDS.advance()` call.\n        if (block.timestamp < ((_targetEpoch - 106) * 28800) + 1602201600) { return; }\n\n        // Advance. revert if we can't advance (someone already beat us to it)\n        ESDS.advance();\n        \n        // Check how many can be redeemed this epoch\n        uint256 totalRedeemable = ESDS.totalRedeemable();\n        \n        // Return early if no more coupons can be redeemed this epoch.\n        if (totalRedeemable == 0) { return; }\n        \n        // Iterate over epochs list and try to redeem as much as possible\n        for (uint i = 0; i < epochs.length; i++) {\n            \n            // Look up coupon balance of COUPON_HOLDER\n            uint256 couponBalance = ESDS.balanceOfCoupons(address(COUPON_HOLDER), epochs[i]);\n            \n            // If COUPON_HOLDER has no coupons in epochs[i], skip to next epoch in the list\n            if (couponBalance == 0) {\n                continue;\n            }\n            \n            // Transfer coupons from epochs[i] to this contract\n            // Revert on failure. COUPON_HOLDER must approve this contract to use his coupons.\n            ESDS.transferCoupons(address(COUPON_HOLDER), address(this), epochs[i], couponBalance);\n            \n            // Can redeem full amount from epochs[i]\n            if (totalRedeemable > couponBalance) {\n                totalRedeemable = totalRedeemable - couponBalance;\n                ESDS.redeemCoupons(epochs[i], couponBalance);\n            } else {\n                // totalRedeemable <= couponBalance\n                // Cannot redeem the full amount of coupons from epochs[i]\n                // Try to redeem as much as possible and quit\n                ESDS.redeemCoupons(epochs[i], totalRedeemable);\n                return;\n            }\n        }\n    }\n    \n    // Set epochs to redeem\n    function setEpochs(uint256[] calldata sourceEpochs) external {\n        require(msg.sender == COUPON_HOLDER);\n        epochs = sourceEpochs;\n    }\n    \n    // Function to check if the epochs are set correctly\n    function getEpochs() external view returns (uint256[] memory) {\n        return epochs;\n    }\n    \n    // Withdraw any coupons and ESD to COUPON_HOLDER\n    function withdraw() external {\n        \n        // Withdraw any ESDS held by this contract to COUPON_HOLDER\n        for (uint i = 0; i < epochs.length; i++) {\n            uint256 couponBalance = ESDS.balanceOfCoupons(address(this), epochs[i]);\n            if (couponBalance > 0) {\n                ESDS.transferCoupons(address(this), COUPON_HOLDER, epochs[i], couponBalance);\n            }\n        }\n        \n        // Withdraw any ESD to COUPON_HOLDER\n        uint256 tokenBalance = ESD.balanceOf(address(this));\n        if (tokenBalance > 0) {\n            ESD.transfer(COUPON_HOLDER, tokenBalance);\n        }\n    }\n    \n    // Rescue tokens that are stuck to COUPON_HOLDER (In case user sends other ERC20 tokens to this contract)\n    function withdraw(address tokenAddress) external {\n        \n        IERC20 lostToken = IERC20(tokenAddress);\n        uint256 balance = lostToken.balanceOf(address(this));\n        if (balance > 0) {\n            lostToken.transfer(COUPON_HOLDER, balance);\n        }\n    }\n}"
    }
  }
}