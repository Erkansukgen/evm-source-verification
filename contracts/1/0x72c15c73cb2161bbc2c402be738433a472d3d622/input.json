{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "localhost/AdapterRegistry.sol": {
      "content": "// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\nimport {\n    ProtocolBalance,\n    ProtocolMetadata,\n    AdapterBalance,\n    AdapterMetadata,\n    FullTokenBalance,\n    TokenBalance,\n    TokenMetadata,\n    Component\n} from \"./Structs.sol\";\nimport { Strings } from \"./Strings.sol\";\nimport { Ownable } from \"./Ownable.sol\";\nimport { ProtocolManager } from \"./ProtocolManager.sol\";\nimport { TokenAdapterManager } from \"./TokenAdapterManager.sol\";\nimport { ProtocolAdapter } from \"./adapters/ProtocolAdapter.sol\";\nimport { TokenAdapter } from \"./adapters/TokenAdapter.sol\";\n\n\n/**\n * @title Registry for protocols, adapters, and token adapters.\n * @notice getBalances() function implements the main functionality.\n * @author Igor Sobolev <sobolev@zerion.io>\n */\ncontract AdapterRegistry is Ownable, ProtocolManager, TokenAdapterManager {\n\n    using Strings for string;\n\n    /**\n     * @param tokenType String with type of the token.\n     * @param token Address of the token.\n     * @return Full token balance by token type and token address.\n     */\n    function getFullTokenBalance(\n        bytes32 tokenType,\n        address token\n    )\n        external\n        view\n        returns (FullTokenBalance memory)\n    {\n        Component[] memory components = getComponents(tokenType, token, 1e18);\n        return getFullTokenBalance(tokenType, token, 1e18, components);\n    }\n\n    /**\n     * @param tokenType String with type of the token.\n     * @param token Address of the token.\n     * @return Final full token balance by token type and token address.\n     */\n    function getFinalFullTokenBalance(\n        bytes32 tokenType,\n        address token\n    )\n        external\n        view\n        returns (FullTokenBalance memory)\n    {\n        Component[] memory finalComponents = getFinalComponents(tokenType, token, 1e18);\n        return getFullTokenBalance(tokenType, token, 1e18, finalComponents);\n    }\n\n    /**\n     * @param account Address of the account.\n     * @return ProtocolBalance array by the given account.\n     */\n    function getBalances(\n        address account\n    )\n        external\n        view\n        returns (ProtocolBalance[] memory)\n    {\n        bytes32[] memory protocolNames = getProtocolNames();\n\n        return getProtocolBalances(account, protocolNames);\n    }\n\n    /**\n     * @param account Address of the account.\n     * @param protocolNames Array of the protocols' names.\n     * @return ProtocolBalance array by the given account and names of protocols.\n     */\n    function getProtocolBalances(\n        address account,\n        bytes32[] memory protocolNames\n    )\n        public\n        view\n        returns (ProtocolBalance[] memory)\n    {\n        ProtocolBalance[] memory protocolBalances = new ProtocolBalance[](protocolNames.length);\n        uint256 counter = 0;\n\n        for (uint256 i = 0; i < protocolNames.length; i++) {\n            protocolBalances[i] = ProtocolBalance({\n                metadata: protocolMetadata[protocolNames[i]],\n                adapterBalances: getAdapterBalances(account, protocolAdapters[protocolNames[i]])\n            });\n            if (protocolBalances[i].adapterBalances.length > 0) {\n                counter++;\n            }\n        }\n\n        ProtocolBalance[] memory nonZeroProtocolBalances = new ProtocolBalance[](counter);\n        counter = 0;\n\n        for (uint256 i = 0; i < protocolNames.length; i++) {\n            if (protocolBalances[i].adapterBalances.length > 0) {\n                nonZeroProtocolBalances[counter] = protocolBalances[i];\n                counter++;\n            }\n        }\n\n        return nonZeroProtocolBalances;\n    }\n\n    /**\n     * @param account Address of the account.\n     * @param adapters Array of the protocol adapters' addresses.\n     * @return AdapterBalance array by the given parameters.\n     */\n    function getAdapterBalances(\n        address account,\n        address[] memory adapters\n    )\n        public\n        view\n        returns (AdapterBalance[] memory)\n    {\n        AdapterBalance[] memory adapterBalances = new AdapterBalance[](adapters.length);\n        uint256 counter = 0;\n\n        for (uint256 i = 0; i < adapterBalances.length; i++) {\n            adapterBalances[i] = getAdapterBalance(\n                account,\n                adapters[i],\n                supportedTokens[adapters[i]]\n            );\n            if (adapterBalances[i].balances.length > 0) {\n                counter++;\n            }\n        }\n\n        AdapterBalance[] memory nonZeroAdapterBalances = new AdapterBalance[](counter);\n        counter = 0;\n\n        for (uint256 i = 0; i < adapterBalances.length; i++) {\n            if (adapterBalances[i].balances.length > 0) {\n                nonZeroAdapterBalances[counter] = adapterBalances[i];\n                counter++;\n            }\n        }\n\n        return nonZeroAdapterBalances;\n    }\n\n    /**\n     * @param account Address of the account.\n     * @param adapter Address of the protocol adapter.\n     * @param tokens Array with tokens' addresses.\n     * @return AdapterBalance array by the given parameters.\n     */\n    function getAdapterBalance(\n        address account,\n        address adapter,\n        address[] memory tokens\n    )\n        public\n        view\n        returns (AdapterBalance memory)\n    {\n        if (adapter == address(0)) {\n            return AdapterBalance({\n                metadata: AdapterMetadata({\n                    adapterAddress: address(0),\n                    adapterType: bytes32(0)\n                }),\n                balances: new FullTokenBalance[](0)\n            });\n        }\n\n        bytes32 tokenType = ProtocolAdapter(adapter).tokenType();\n        uint256[] memory amounts = new uint256[](tokens.length);\n        uint256 counter;\n\n        for (uint256 i = 0; i < amounts.length; i++) {\n            try ProtocolAdapter(adapter).getBalance(tokens[i], account) returns (uint256 result) {\n                amounts[i] = result;\n            } catch {\n                amounts[i] = 0;\n            }\n            if (amounts[i] > 0) {\n                counter++;\n            }\n        }\n\n        FullTokenBalance[] memory finalFullTokenBalances = new FullTokenBalance[](counter);\n        counter = 0;\n\n        for (uint256 i = 0; i < amounts.length; i++) {\n            if (amounts[i] > 0) {\n                finalFullTokenBalances[counter] = getFullTokenBalance(\n                    tokenType,\n                    tokens[i],\n                    amounts[i],\n                    getFinalComponents(tokenType, tokens[i], amounts[i])\n                );\n                counter++;\n            }\n        }\n\n        return AdapterBalance({\n            metadata: AdapterMetadata({\n                adapterAddress: adapter,\n                adapterType: ProtocolAdapter(adapter).adapterType()\n            }),\n            balances: finalFullTokenBalances\n        });\n    }\n\n    /**\n     * @param tokenType Type of the base token.\n     * @param token Address of the base token.\n     * @param amount Amount of the base token.\n     * @param components Components of the base token.\n     * @return FullTokenBalance struct by the given components.\n     */\n    function getFullTokenBalance(\n        bytes32 tokenType,\n        address token,\n        uint256 amount,\n        Component[] memory components\n    )\n        internal\n        view\n        returns (FullTokenBalance memory)\n    {\n        TokenBalance[] memory componentTokenBalances = new TokenBalance[](components.length);\n\n        for (uint256 i = 0; i < components.length; i++) {\n            componentTokenBalances[i] = getTokenBalance(\n                components[i].tokenType,\n                components[i].token,\n                components[i].rate\n            );\n        }\n\n        return FullTokenBalance({\n            base: getTokenBalance(tokenType, token, amount),\n            underlying: componentTokenBalances\n        });\n    }\n\n    /**\n     * @param tokenType String with type of the token.\n     * @param token Address of the token.\n     * @param amount Amount of the token.\n     * @return Final components by token type and token address.\n     */\n    function getFinalComponents(\n        bytes32 tokenType,\n        address token,\n        uint256 amount\n    )\n        internal\n        view\n        returns (Component[] memory)\n    {\n        uint256 totalLength = getFinalComponentsNumber(tokenType, token, true);\n        Component[] memory finalTokens = new Component[](totalLength);\n        uint256 length;\n        uint256 init = 0;\n\n        Component[] memory components = getComponents(tokenType, token, amount);\n        Component[] memory finalComponents;\n\n        for (uint256 i = 0; i < components.length; i++) {\n            finalComponents = getFinalComponents(\n                components[i].tokenType,\n                components[i].token,\n                components[i].rate\n            );\n\n            length = finalComponents.length;\n\n            if (length == 0) {\n                finalTokens[init] = components[i];\n                init = init + 1;\n            } else {\n                for (uint256 j = 0; j < length; j++) {\n                    finalTokens[init + j] = finalComponents[j];\n                }\n\n                init = init + length;\n            }\n        }\n\n        return finalTokens;\n    }\n\n    /**\n     * @param tokenType String with type of the token.\n     * @param token Address of the token.\n     * @param initial Whether the function call is initial or recursive.\n     * @return Final tokens number by token type and token.\n     */\n    function getFinalComponentsNumber(\n        bytes32 tokenType,\n        address token,\n        bool initial\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 totalLength = 0;\n        Component[] memory components = getComponents(tokenType, token, 1e18);\n\n        if (components.length == 0) {\n            return initial ? uint256(0) : uint256(1);\n        }\n\n        for (uint256 i = 0; i < components.length; i++) {\n            totalLength = totalLength + getFinalComponentsNumber(\n                components[i].tokenType,\n                components[i].token,\n                false\n            );\n        }\n\n        return totalLength;\n    }\n\n    /**\n     * @param tokenType String with type of the token.\n     * @param token Address of the token.\n     * @param amount Amount of the token.\n     * @return Components by token type and token address.\n     */\n    function getComponents(\n        bytes32 tokenType,\n        address token,\n        uint256 amount\n    )\n        internal\n        view\n        returns (Component[] memory)\n    {\n        TokenAdapter adapter = TokenAdapter(tokenAdapter[tokenType]);\n        Component[] memory components;\n\n        if (address(adapter) != address(0)) {\n            try adapter.getComponents(token) returns (Component[] memory result) {\n                components = result;\n            } catch {\n                components = new Component[](0);\n            }\n        } else {\n            components = new Component[](0);\n        }\n\n        for (uint256 i = 0; i < components.length; i++) {\n            components[i].rate = components[i].rate * amount / 1e18;\n        }\n\n        return components;\n    }\n\n    /**\n     * @notice Fulfills TokenBalance struct using type, address, and balance of the token.\n     * @param tokenType String with type of the token.\n     * @param token Address of the token.\n     * @param amount Amount of tokens.\n     * @return TokenBalance struct with token info and balance.\n     */\n    function getTokenBalance(\n        bytes32 tokenType,\n        address token,\n        uint256 amount\n    )\n        internal\n        view\n        returns (TokenBalance memory)\n    {\n        TokenAdapter adapter = TokenAdapter(tokenAdapter[tokenType]);\n        TokenBalance memory tokenBalance;\n        tokenBalance.amount = amount;\n\n        if (address(adapter) != address(0)) {\n            try adapter.getMetadata(token) returns (TokenMetadata memory result) {\n                tokenBalance.metadata = result;\n            } catch {\n                tokenBalance.metadata = TokenMetadata({\n                    token: token,\n                    name: \"Not available\",\n                    symbol: \"N/A\",\n                    decimals: 0\n                });\n            }\n        } else {\n            tokenBalance.metadata = TokenMetadata({\n                token: token,\n                name: \"Not available\",\n                symbol: \"N/A\",\n                decimals: 0\n            });\n        }\n\n        return tokenBalance;\n    }\n}\n"
    },
    "localhost/ERC20.sol": {
      "content": "// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\n\ninterface ERC20 {\n    function approve(address, uint256) external returns (bool);\n    function transfer(address, uint256) external returns (bool);\n    function transferFrom(address, address, uint256) external returns (bool);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address) external view returns (uint256);\n    function allowance(address, address) external view returns (uint256);\n}\n"
    },
    "localhost/Ownable.sol": {
      "content": "// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\n\nabstract contract Ownable {\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"O: onlyOwner function!\");\n        _;\n    }\n\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @notice Initializes owner variable with msg.sender address.\n     */\n    constructor() internal {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /**\n     * @notice Transfers ownership to the desired address.\n     * The function is callable only by the owner.\n     */\n    function transferOwnership(address _owner) external onlyOwner {\n        require(_owner != address(0), \"O: new owner is the zero address!\");\n        emit OwnershipTransferred(owner, _owner);\n        owner = _owner;\n    }\n}\n"
    },
    "localhost/ProtocolManager.sol": {
      "content": "// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\nimport { Ownable } from \"./Ownable.sol\";\nimport { ProtocolMetadata } from \"./Structs.sol\";\nimport { Strings } from \"./Strings.sol\";\n\n\n/**\n * @title AdapterRegistry part responsible for protocols and adapters management.\n * @dev Base contract for AdapterRegistry.\n * @author Igor Sobolev <sobolev@zerion.io>\n */\nabstract contract ProtocolManager is Ownable {\n\n    using Strings for string;\n\n    bytes32 internal constant INITIAL_PROTOCOL_NAME = \"Initial protocol name\";\n\n    // protocol name => next protocol name (linked list)\n    mapping (bytes32 => bytes32) internal nextProtocolName;\n    // protocol name => protocol struct with info and adapters\n    mapping (bytes32 => ProtocolMetadata) internal protocolMetadata;\n    // protocol name => array of protocol adapters\n    mapping (bytes32 => address[]) internal protocolAdapters;\n    // protocol adapter => array of supported tokens\n    mapping (address => address[]) internal supportedTokens;\n\n    /**\n     * @notice Initializes contract storage.\n     */\n    constructor() internal {\n        nextProtocolName[INITIAL_PROTOCOL_NAME] = INITIAL_PROTOCOL_NAME;\n    }\n\n    /**\n     * @notice Adds new protocols.\n     * The function is callable only by the owner.\n     * @param protocolNames Names of the protocols to be added.\n     * @param metadata Array with new protocols metadata.\n     * @param adapters Nested arrays with new protocols' adapters.\n     * @param tokens Nested arrays with adapters' supported tokens.\n     */\n    function addProtocols(\n        bytes32[] memory protocolNames,\n        ProtocolMetadata[] memory metadata,\n        address[][] memory adapters,\n        address[][][] memory tokens\n    )\n        public\n        onlyOwner\n    {\n        require(protocolNames.length == metadata.length, \"PM: names & metadata differ!\");\n        require(protocolNames.length == adapters.length, \"PM: names & adapters differ!\");\n        require(protocolNames.length == tokens.length, \"PM: names & tokens differ!\");\n        require(protocolNames.length != 0, \"PM: empty!\");\n\n        for (uint256 i = 0; i < protocolNames.length; i++) {\n            addProtocol(protocolNames[i], metadata[i], adapters[i], tokens[i]);\n        }\n    }\n\n    /**\n     * @notice Removes protocols.\n     * The function is callable only by the owner.\n     * @param protocolNames Names of the protocols to be removed.\n     */\n    function removeProtocols(\n        bytes32[] memory protocolNames\n    )\n        public\n        onlyOwner\n    {\n        require(protocolNames.length != 0, \"PM: empty!\");\n\n        for (uint256 i = 0; i < protocolNames.length; i++) {\n            removeProtocol(protocolNames[i]);\n        }\n    }\n\n    /**\n     * @notice Updates a protocol info.\n     * The function is callable only by the owner.\n     * @param protocolName Name of the protocol to be updated.\n     * @param name Name of the protocol to be added instead.\n     * @param description Description of the protocol to be added instead.\n     * @param websiteURL URL of the protocol website to be added instead.\n     * @param iconURL URL of the protocol icon to be added instead.\n     */\n    function updateProtocolMetadata(\n        bytes32 protocolName,\n        string memory name,\n        string memory description,\n        string memory websiteURL,\n        string memory iconURL\n    )\n        public\n        onlyOwner\n    {\n        require(isValidProtocol(protocolName), \"PM: bad name!\");\n        require(abi.encodePacked(name, description, websiteURL, iconURL).length != 0, \"PM: empty!\");\n\n        ProtocolMetadata storage metadata = protocolMetadata[protocolName];\n\n        if (!name.isEmpty()) {\n            metadata.name = name;\n        }\n\n        if (!description.isEmpty()) {\n            metadata.description = description;\n        }\n\n        if (!websiteURL.isEmpty()) {\n            metadata.websiteURL = websiteURL;\n        }\n\n        if (!iconURL.isEmpty()) {\n            metadata.iconURL = iconURL;\n        }\n\n        metadata.version++;\n    }\n\n    /**\n     * @notice Adds protocol adapters.\n     * The function is callable only by the owner.\n     * @param protocolName Name of the protocol to be updated.\n     * @param adapters Array of new adapters to be added.\n     * @param tokens Array of new adapters' supported tokens.\n     */\n    function addProtocolAdapters(\n        bytes32 protocolName,\n        address[] memory adapters,\n        address[][] memory tokens\n    )\n        public\n        onlyOwner\n    {\n        require(isValidProtocol(protocolName), \"PM: bad name!\");\n        require(adapters.length != 0, \"PM: empty!\");\n\n        for (uint256 i = 0; i < adapters.length; i++) {\n            addProtocolAdapter(protocolName, adapters[i], tokens[i]);\n        }\n\n        protocolMetadata[protocolName].version++;\n    }\n\n    /**\n     * @notice Removes protocol adapters.\n     * The function is callable only by the owner.\n     * @param protocolName Name of the protocol to be updated.\n     * @param adapterIndices Array of adapter indexes to be removed.\n     * @dev NOTE: indexes will change during execution of this function!!!\n     */\n    function removeProtocolAdapters(\n        bytes32 protocolName,\n        uint256[] memory adapterIndices\n    )\n        public\n        onlyOwner\n    {\n        require(isValidProtocol(protocolName), \"PM: bad name!\");\n        require(adapterIndices.length != 0, \"PM: empty!\");\n\n        for (uint256 i = 0; i < adapterIndices.length; i++) {\n            removeProtocolAdapter(protocolName, adapterIndices[i]);\n        }\n\n        protocolMetadata[protocolName].version++;\n    }\n\n    /**\n     * @notice Updates a protocol adapter.\n     * The function is callable only by the owner.\n     * @param protocolName Name of the protocol to be updated.\n     * @param index Index of the adapter to be updated.\n     * @param newAdapterAddress New adapter address to be added instead.\n     * @param newSupportedTokens New supported tokens to be added instead.\n     */\n    function updateProtocolAdapter(\n        bytes32 protocolName,\n        uint256 index,\n        address newAdapterAddress,\n        address[] memory newSupportedTokens\n    )\n        public\n        onlyOwner\n    {\n        require(isValidProtocol(protocolName), \"PM: bad name!\");\n        require(index < protocolAdapters[protocolName].length, \"PM: bad index!\");\n        require(newAdapterAddress != address(0), \"PM: empty!\");\n\n        address adapterAddress = protocolAdapters[protocolName][index];\n\n        if (newAdapterAddress == adapterAddress) {\n            supportedTokens[adapterAddress] = newSupportedTokens;\n        } else {\n            protocolAdapters[protocolName][index] = newAdapterAddress;\n            supportedTokens[newAdapterAddress] = newSupportedTokens;\n            delete supportedTokens[adapterAddress];\n        }\n\n        protocolMetadata[protocolName].version++;\n    }\n\n    /**\n     * @return Array of protocol names.\n     */\n    function getProtocolNames()\n        public\n        view\n        returns (bytes32[] memory)\n    {\n        uint256 counter = 0;\n        bytes32 currentProtocolName = nextProtocolName[INITIAL_PROTOCOL_NAME];\n\n        while (currentProtocolName != INITIAL_PROTOCOL_NAME) {\n            currentProtocolName = nextProtocolName[currentProtocolName];\n            counter++;\n        }\n\n        bytes32[] memory protocolNames = new bytes32[](counter);\n        counter = 0;\n        currentProtocolName = nextProtocolName[INITIAL_PROTOCOL_NAME];\n\n        while (currentProtocolName != INITIAL_PROTOCOL_NAME) {\n            protocolNames[counter] = currentProtocolName;\n            currentProtocolName = nextProtocolName[currentProtocolName];\n            counter++;\n        }\n\n        return protocolNames;\n    }\n\n    /**\n     * @param protocolName Name of the protocol.\n     * @return Metadata of the protocol.\n     */\n    function getProtocolMetadata(\n        bytes32 protocolName\n    )\n        public\n        view\n        returns (ProtocolMetadata memory)\n    {\n        return (protocolMetadata[protocolName]);\n    }\n\n    /**\n     * @param protocolName Name of the protocol.\n     * @return Array of protocol adapters.\n     */\n    function getProtocolAdapters(\n        bytes32 protocolName\n    )\n        public\n        view\n        returns (address[] memory)\n    {\n        return protocolAdapters[protocolName];\n    }\n\n    /**\n     * @param adapter Address of the protocol adapter.\n     * @return Array of supported tokens.\n     */\n    function getSupportedTokens(\n        address adapter\n    )\n        public\n        view\n        returns (address[] memory)\n    {\n        return supportedTokens[adapter];\n    }\n\n    /**\n     * @param protocolName Name of the protocol.\n     * @return Whether the protocol name is valid.\n     */\n    function isValidProtocol(\n        bytes32 protocolName\n    )\n        public\n        view\n        returns (bool)\n    {\n        return nextProtocolName[protocolName] != bytes32(0) && protocolName != INITIAL_PROTOCOL_NAME;\n    }\n\n    /**\n     * @notice Adds a new protocol.\n     * The function is callable only by the owner.\n     * @param protocolName Name of the protocol to be added.\n     * @param metadata Info about new protocol.\n     * @param adapters Addresses of new protocol's adapters.\n     * @param tokens Addresses of new protocol's adapters' supported tokens.\n     */\n    function addProtocol(\n        bytes32 protocolName,\n        ProtocolMetadata memory metadata,\n        address[] memory adapters,\n        address[][] memory tokens\n    )\n        internal\n    {\n        require(protocolName != INITIAL_PROTOCOL_NAME, \"PM: initial name!\");\n        require(protocolName != bytes32(0), \"PM: empty name!\");\n        require(nextProtocolName[protocolName] == bytes32(0), \"PM: name exists!\");\n        require(adapters.length == tokens.length, \"PM: adapters & tokens differ!\");\n\n        nextProtocolName[protocolName] = nextProtocolName[INITIAL_PROTOCOL_NAME];\n        nextProtocolName[INITIAL_PROTOCOL_NAME] = protocolName;\n\n        protocolMetadata[protocolName] = ProtocolMetadata({\n            name: metadata.name,\n            description: metadata.description,\n            websiteURL: metadata.websiteURL,\n            iconURL: metadata.iconURL,\n            version: metadata.version\n        });\n\n        for (uint256 i = 0; i < adapters.length; i++) {\n            addProtocolAdapter(protocolName, adapters[i], tokens[i]);\n        }\n    }\n\n    /**\n     * @notice Removes one of the protocols.\n     * @param protocolName Name of the protocol to be removed.\n     */\n    function removeProtocol(\n        bytes32 protocolName\n    )\n        internal\n    {\n        require(isValidProtocol(protocolName), \"PM: bad name!\");\n\n        bytes32 prevProtocolName;\n        bytes32 currentProtocolName = nextProtocolName[protocolName];\n        while (currentProtocolName != protocolName) {\n            prevProtocolName = currentProtocolName;\n            currentProtocolName = nextProtocolName[currentProtocolName];\n        }\n\n        delete protocolMetadata[protocolName];\n\n        nextProtocolName[prevProtocolName] = nextProtocolName[protocolName];\n        delete nextProtocolName[protocolName];\n\n        uint256 length = protocolAdapters[protocolName].length;\n        for (uint256 i = length - 1; i < length; i--) {\n            removeProtocolAdapter(protocolName, i);\n        }\n    }\n\n    /**\n     * @notice Adds a protocol adapter.\n     * The function is callable only by the owner.\n     * @param protocolName Name of the protocol to be updated.\n     * @param adapter New adapter to be added.\n     * @param tokens New adapter's supported tokens.\n     */\n    function addProtocolAdapter(\n        bytes32 protocolName,\n        address adapter,\n        address[] memory tokens\n    )\n        internal\n    {\n        if (adapter == address(0)) {\n            require(tokens.length == 0, \"PM: tokens for zero adapter!\");\n        }\n        require(supportedTokens[adapter].length == 0, \"PM: exists!\");\n\n        protocolAdapters[protocolName].push(adapter);\n        supportedTokens[adapter] = tokens;\n    }\n\n    /**\n     * @notice Removes a protocol adapter.\n     * The function is callable only by the owner.\n     * @param protocolName Name of the protocol to be updated.\n     * @param index Adapter index to be removed.\n     */\n    function removeProtocolAdapter(\n        bytes32 protocolName,\n        uint256 index\n    )\n        internal\n    {\n        uint256 length = protocolAdapters[protocolName].length;\n        require(index < length, \"PM: bad index!\");\n\n        delete supportedTokens[protocolAdapters[protocolName][index]];\n\n        if (index != length - 1) {\n            protocolAdapters[protocolName][index] = protocolAdapters[protocolName][length - 1];\n        }\n\n        protocolAdapters[protocolName].pop();\n    }\n}\n"
    },
    "localhost/Strings.sol": {
      "content": "// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @notice Library for strings.\n * @author Igor Sobolev <sobolev@zerion.io>\n */\nlibrary Strings {\n\n    function isEmpty(string memory s) internal pure returns (bool) {\n        return bytes(s).length == 0;\n    }\n\n    function isEqualTo(string memory s1, string memory s2) internal pure returns (bool) {\n        return keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2));\n    }\n}\n"
    },
    "localhost/Structs.sol": {
      "content": "// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\n\nstruct ProtocolBalance {\n    ProtocolMetadata metadata;\n    AdapterBalance[] adapterBalances;\n}\n\n\nstruct ProtocolMetadata {\n    string name;\n    string description;\n    string websiteURL;\n    string iconURL;\n    uint256 version;\n}\n\n\nstruct AdapterBalance {\n    AdapterMetadata metadata;\n    FullTokenBalance[] balances;\n}\n\n\nstruct AdapterMetadata {\n    address adapterAddress;\n    bytes32 adapterType; // \"Asset\", \"Debt\"\n}\n\n\n// token and its underlying tokens (if exist) balances\nstruct FullTokenBalance {\n    TokenBalance base;\n    TokenBalance[] underlying;\n}\n\n\nstruct TokenBalance {\n    TokenMetadata metadata;\n    uint256 amount;\n}\n\n\n// ERC20-style token metadata\n// 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE address is used for ETH\nstruct TokenMetadata {\n    address token;\n    string name;\n    string symbol;\n    uint8 decimals;\n}\n\n\nstruct Component {\n    address token;\n    bytes32 tokenType;  // \"ERC20\" by default\n    uint256 rate;  // price per full share (1e18)\n}\n\n\n//================================InteractiveAdapters structs=====================================\n\n\nstruct Action {\n    ActionType actionType;\n    bytes32 protocolName;\n    uint256 adapterIndex;\n    address[] tokens;\n    uint256[] amounts;\n    AmountType[] amountTypes;\n    bytes data;\n}\n\n\nstruct Approval {\n    address token;\n    uint256 amount;\n    AmountType amountType;\n    uint256 nonce;\n}\n\n\nenum ActionType { None, Deposit, Withdraw }\n\n\nenum AmountType { None, Relative, Absolute }\n"
    },
    "localhost/TokenAdapterManager.sol": {
      "content": "// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\nimport { Ownable } from \"./Ownable.sol\";\nimport { Strings } from \"./Strings.sol\";\n\n\n/**\n * @title AdapterRegistry part responsible for token adapters management.\n * @dev Base contract for AdapterRegistry.\n * @author Igor Sobolev <sobolev@zerion.io>\n */\nabstract contract TokenAdapterManager is Ownable {\n\n    using Strings for string;\n\n    bytes32 internal constant INITIAL_NAME = \"Initial token name\";\n\n    // adapter name => next adapter name (linked list)\n    mapping (bytes32 => bytes32) internal nextTokenAdapterName;\n    // adapter name => adapter info\n    mapping (bytes32 => address) internal tokenAdapter;\n\n    /**\n     * @notice Initializes contract storage.\n     */\n    constructor() internal {\n        nextTokenAdapterName[INITIAL_NAME] = INITIAL_NAME;\n    }\n\n    /**\n     * @notice Adds new token adapters.\n     * The function is callable only by the owner.\n     * @param tokenAdapterNames Names of token adapters to be added.\n     * @param adapters Addresses of token adapters to be added.\n     */\n    function addTokenAdapters(\n        bytes32[] memory tokenAdapterNames,\n        address[] memory adapters\n    )\n        public\n        onlyOwner\n    {\n        uint256 length = tokenAdapterNames.length;\n        require(length == adapters.length, \"TAM: lengths differ!\");\n        require(length != 0, \"PM: empty!\");\n\n        for (uint256 i = 0; i < length; i++) {\n            addTokenAdapter(tokenAdapterNames[i], adapters[i]);\n        }\n    }\n\n    /**\n     * @notice Removes token adapters.\n     * The function is callable only by the owner.\n     * @param tokenAdapterNames Names of token adapters to be removed.\n     */\n    function removeTokenAdapters(\n        bytes32[] memory tokenAdapterNames\n    )\n        public\n        onlyOwner\n    {\n        require(tokenAdapterNames.length != 0, \"PM: empty!\");\n\n        for (uint256 i = 0; i < tokenAdapterNames.length; i++) {\n            removeTokenAdapter(tokenAdapterNames[i]);\n        }\n    }\n\n    /**\n     * @notice Updates token adapter.\n     * The function is callable only by the owner.\n     * @param tokenAdapterName Name of token adapter to be updated.\n     * @param adapter Address of token adapter to be added instead.\n     */\n    function updateTokenAdapter(\n        bytes32 tokenAdapterName,\n        address adapter\n    )\n        public\n        onlyOwner\n    {\n        require(isValidTokenAdapter(tokenAdapterName), \"TAM: bad name!\");\n        require(adapter != address(0), \"TAM: zero!\");\n\n        tokenAdapter[tokenAdapterName] = adapter;\n    }\n\n    /**\n     * @return Array of token adapter names.\n     */\n    function getTokenAdapterNames()\n        public\n        view\n        returns (bytes32[] memory)\n    {\n        uint256 counter = 0;\n        bytes32 currentTokenAdapterName = nextTokenAdapterName[INITIAL_NAME];\n\n        while (currentTokenAdapterName != INITIAL_NAME) {\n            currentTokenAdapterName = nextTokenAdapterName[currentTokenAdapterName];\n            counter++;\n        }\n\n        bytes32[] memory tokenAdapterNames = new bytes32[](counter);\n        counter = 0;\n        currentTokenAdapterName = nextTokenAdapterName[INITIAL_NAME];\n\n        while (currentTokenAdapterName != INITIAL_NAME) {\n            tokenAdapterNames[counter] = currentTokenAdapterName;\n            currentTokenAdapterName = nextTokenAdapterName[currentTokenAdapterName];\n            counter++;\n        }\n\n        return tokenAdapterNames;\n    }\n\n    /**\n     * @param tokenAdapterName Name of token adapter.\n     * @return Address of token adapter.\n     */\n    function getTokenAdapter(\n        bytes32 tokenAdapterName\n    )\n        public\n        view\n        returns (address)\n    {\n        return tokenAdapter[tokenAdapterName];\n    }\n\n    /**\n     * @param tokenAdapterName Name of token adapter.\n     * @return Whether token adapter is valid.\n     */\n    function isValidTokenAdapter(\n        bytes32 tokenAdapterName\n    )\n        public\n        view\n        returns (bool)\n    {\n        return nextTokenAdapterName[tokenAdapterName] != bytes32(0) && tokenAdapterName != INITIAL_NAME;\n    }\n\n    /**\n     * @notice Adds new token adapter.\n     * The function is callable only by the owner.\n     * @param tokenAdapterName Name of token adapter to be added.\n     * @param adapter Address of token adapter to be added.\n     */\n    function addTokenAdapter(\n        bytes32 tokenAdapterName,\n        address adapter\n    )\n        internal\n    {\n        require(tokenAdapterName != INITIAL_NAME, \"TAM: initial name!\");\n        require(tokenAdapterName != bytes32(0), \"TAM: empty name!\");\n        require(nextTokenAdapterName[tokenAdapterName] == bytes32(0), \"TAM: name exists!\");\n        require(adapter != address(0), \"TAM: zero!\");\n\n        nextTokenAdapterName[tokenAdapterName] = nextTokenAdapterName[INITIAL_NAME];\n        nextTokenAdapterName[INITIAL_NAME] = tokenAdapterName;\n\n        tokenAdapter[tokenAdapterName] = adapter;\n    }\n\n    /**\n     * @notice Removes one of token adapters.\n     * @param tokenAdapterName Name of token adapter to be removed.\n     */\n    function removeTokenAdapter(\n        bytes32 tokenAdapterName\n    )\n        internal\n    {\n        require(isValidTokenAdapter(tokenAdapterName), \"TAM: bad name!\");\n\n        bytes32 prevTokenAdapterName;\n        bytes32 currentTokenAdapterName = nextTokenAdapterName[tokenAdapterName];\n        while (currentTokenAdapterName != tokenAdapterName) {\n            prevTokenAdapterName = currentTokenAdapterName;\n            currentTokenAdapterName = nextTokenAdapterName[currentTokenAdapterName];\n        }\n\n        nextTokenAdapterName[prevTokenAdapterName] = nextTokenAdapterName[tokenAdapterName];\n        delete nextTokenAdapterName[tokenAdapterName];\n\n        delete tokenAdapter[tokenAdapterName];\n    }\n}\n"
    },
    "localhost/adapters/ProtocolAdapter.sol": {
      "content": "// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title Protocol adapter interface.\n * @dev adapterType(), tokenType(), and getBalance() functions MUST be implemented.\n * @author Igor Sobolev <sobolev@zerion.io>\n */\nabstract contract ProtocolAdapter {\n\n    /**\n     * @dev MUST return \"Asset\" or \"Debt\".\n     * SHOULD be implemented by the public constant state variable.\n     */\n    function adapterType() external pure virtual returns (bytes32);\n\n    /**\n     * @dev MUST return token type (default is \"ERC20\").\n     * SHOULD be implemented by the public constant state variable.\n     */\n    function tokenType() external pure virtual returns (bytes32);\n\n    /**\n     * @dev MUST return amount of the given token locked on the protocol by the given account.\n     */\n    function getBalance(address token, address account) public view virtual returns (uint256);\n}\n"
    },
    "localhost/adapters/TokenAdapter.sol": {
      "content": "// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\nimport { ERC20 } from \"../ERC20.sol\";\nimport { TokenMetadata, Component } from \"../Structs.sol\";\n\n\n/**\n * @title Token adapter interface.\n * @dev getMetadata() and getComponents() functions MUST be implemented.\n * @author Igor Sobolev <sobolev@zerion.io>\n */\nabstract contract TokenAdapter {\n\n    /**\n     * @dev MUST return array of Component structs with underlying tokens rates for the given token.\n     * struct Component {\n     *     address token;    // Address of token contract\n     *     string tokenType; // Token type (\"ERC20\" by default)\n     *     uint256 rate;     // Price per share (1e18)\n     * }\n     */\n    function getComponents(address token) external view virtual returns (Component[] memory);\n\n    /**\n     * @dev MUST return TokenMetadata struct with ERC20-style token info.\n     * It is recommended to override getName(), getSymbol() and getDecimals() functions.\n     * struct TokenMetadata {\n     *     address token;\n     *     string name;\n     *     string symbol;\n     *     uint8 decimals;\n     * }\n     */\n    function getMetadata(address token) public view virtual returns (TokenMetadata memory) {\n        return TokenMetadata({\n            token: token,\n            name: getName(token),\n            symbol: getSymbol(token),\n            decimals: getDecimals(token)\n        });\n    }\n\n    /**\n     * @dev MUST return string that will be treated like token name.\n     */\n    function getName(address token) internal view virtual returns (string memory) {\n        return ERC20(token).name();\n    }\n\n    /**\n     * @dev MUST return string that will be treated like token symbol.\n     */\n    function getSymbol(address token) internal view virtual returns (string memory) {\n        return ERC20(token).symbol();\n    }\n\n    /**\n     * @dev MUST return uint8 that will be treated like token decimals.\n     */\n    function getDecimals(address token) internal view virtual returns (uint8) {\n        return ERC20(token).decimals();\n    }\n}\n"
    }
  }
}